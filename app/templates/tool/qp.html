{% extends 'base.html' %}

{% block title %}Quoted-Printable 编码/解码 - 聪明山{% endblock %}

{% block extra_css %}
<style>
  .tool-panel { background: rgba(255,255,255,.9); border: 1px solid rgba(0,0,0,.06); backdrop-filter: blur(6px); }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .result-area { min-height: 220px; }
  .section-title { font-weight: 700; letter-spacing: .2px; }
  .mid-actions { min-height: 100%; display: flex; align-items: center; justify-content: center; }
  .mid-actions .btn { width: 140px; }
  .btn-copy { position:absolute; right:1rem; top:.75rem; }
</style>
{% endblock %}

{% block content %}
<section class="py-4">
  <div class="container">
    <div class="d-flex align-items-center mb-3">
      <a href="{{ url_for('tool.menu') }}" class="text-decoration-none me-2"><i class="bi bi-arrow-left"></i></a>
      <h1 class="mb-0 section-title">Quoted-Printable 编码 / 解码</h1>
    </div>
    <p class="text-muted mb-3">符合 RFC 2045 的 QP 编码，支持软换行（软回车）与尾空格处理。</p>

    <div class="row g-4 align-items-stretch">
      <div class="col-12 col-lg-5">
        <div class="p-3 rounded tool-panel h-100">
          <label class="form-label fw-semibold">左侧（原文）</label>
          <textarea id="leftArea" class="form-control mono result-area" rows="12" placeholder="原文在此输入。编码时 → 右侧，解码结果将从右侧 → 左侧"></textarea>
          <div class="mt-3">
            <label class="form-label fw-semibold">选项</label>
            <div class="row g-2">
              <div class="col-12 col-md-6">
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="softLineBreak" checked>
                  <label class="form-check-label" for="softLineBreak">软换行（在行末添加 =\r\n）</label>
                </div>
              </div>
              <div class="col-12 col-md-6">
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="escapeTrailingSpaces" checked>
                  <label class="form-check-label" for="escapeTrailingSpaces">转义行尾空格和制表符</label>
                </div>
              </div>
              <div class="col-12 col-md-6">
                <div class="form-check">
                  <input class="form-check-input" type="checkbox" id="crlf" checked>
                  <label class="form-check-label" for="crlf">使用 CRLF 作为换行（\r\n）</label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="col-12 col-lg-2">
        <div class="mid-actions h-100">
          <div class="d-flex flex-column gap-3 w-100 align-items-center">
            <button id="btnEncode" class="btn btn-primary"><i class="bi bi-arrow-right"></i> 编码</button>
            <button id="btnDecode" class="btn btn-outline-primary"><i class="bi bi-arrow-left"></i> 解码</button>
            <button id="btnSwap" class="btn btn-outline-secondary"><i class="bi bi-arrow-left-right"></i> 交换两侧</button>
          </div>
        </div>
      </div>

      <div class="col-12 col-lg-5">
        <div class="p-3 rounded tool-panel h-100 position-relative">
          <label class="form-label fw-semibold">右侧（编码文本）</label>
          <button id="btnCopyRight" class="btn btn-sm btn-outline-secondary btn-copy"><i class="bi bi-clipboard"></i> 复制</button>
          <textarea id="rightArea" class="form-control mono result-area" rows="12" placeholder="编码文本在此显示或粘贴以解码"></textarea>
          <div class="d-flex justify-content-between mt-2">
            <small class="text-muted">快捷键：<span class="kbd">Ctrl</span> + <span class="kbd">Enter</span> 编码（左 → 右）</small>
            <span id="statusText" class="text-muted"></span>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
{% endblock %}

{% block extra_js %}
<script>
  (function(){
    const leftArea = document.getElementById('leftArea');
    const rightArea = document.getElementById('rightArea');
    const btnEncode = document.getElementById('btnEncode');
    const btnDecode = document.getElementById('btnDecode');
    const btnSwap = document.getElementById('btnSwap');
    const btnCopyRight = document.getElementById('btnCopyRight');
    const statusText = document.getElementById('statusText');

    const softLineBreak = document.getElementById('softLineBreak');
    const escapeTrailingSpaces = document.getElementById('escapeTrailingSpaces');
    const crlf = document.getElementById('crlf');

    function showStatus(msg){ statusText.textContent = msg; }

    function qpEncode(input) {
      const lines = input.split(/\r?\n/);
      const out = [];
      const eol = crlf.checked ? '\r\n' : '\n';
      for (let line of lines) {
        let encoded = '';
        for (let i = 0; i < line.length; i++) {
          const ch = line[i];
          const code = ch.charCodeAt(0);
          // Per RFC 2045, tab(9) and space(32) are safe unless at EOL.
          // Other safe chars are 33-60 and 62-126.
          const safe = (code === 9 || code === 32) || (code >= 33 && code <= 60) || (code >= 62 && code <= 126);
          if (safe) encoded += ch; else encoded += '=' + code.toString(16).toUpperCase().padStart(2,'0');
        }
        if (escapeTrailingSpaces.checked) {
          encoded = encoded.replace(/[ \t]+$/g, (m) => m.split('').map(c => '=' + c.charCodeAt(0).toString(16).toUpperCase().padStart(2,'0')).join(''));
        }
        if (softLineBreak.checked) {
          // fold to <=76 characters using soft break
          while (encoded.length > 76) {
            out.push(encoded.slice(0, 75) + '=' );
            encoded = encoded.slice(75);
          }
        }
        out.push(encoded);
      }
      return out.join(eol);
    }

    function qpDecode(input) {
      // Join soft breaks
      const eolNormalized = input.replace(/=\r?\n/g, '');
      const bytes = [];
      for (let i = 0; i < eolNormalized.length; i++) {
        const ch = eolNormalized[i];
        if (ch === '=') {
          const hex = eolNormalized.slice(i + 1, i + 3);
          if (/^[0-9A-Fa-f]{2}$/.test(hex)) {
            bytes.push(parseInt(hex, 16));
            i += 2;
          } else {
            // invalid sequence, keep '='
            bytes.push('='.charCodeAt(0));
          }
        } else {
          bytes.push(ch.charCodeAt(0));
        }
      }
      try { return new TextDecoder().decode(new Uint8Array(bytes)); }
      catch { return '[解码失败]'; }
    }

    function encodeLeftToRight(){ rightArea.value = qpEncode(leftArea.value || ''); showStatus('完成'); }
    function decodeRightToLeft(){ leftArea.value = qpDecode(rightArea.value || ''); showStatus('完成'); }

    btnEncode.addEventListener('click', encodeLeftToRight);
    btnDecode.addEventListener('click', decodeRightToLeft);
    btnSwap.addEventListener('click', () => { const t = leftArea.value; leftArea.value = rightArea.value; rightArea.value = t; });
    btnCopyRight.addEventListener('click', async () => { try{ await navigator.clipboard.writeText(rightArea.value || ''); showStatus('已复制'); } catch { showStatus('复制失败'); } });

    leftArea.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'Enter') { e.preventDefault(); encodeLeftToRight(); } });
    rightArea.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'Enter') { e.preventDefault(); decodeRightToLeft(); } });
  })();
</script>
{% endblock %}


