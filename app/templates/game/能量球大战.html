<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>能量球大战 - 双人对战</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameCanvas {
            background: linear-gradient(135deg, #0f3460, #16537e);
            display: block;
        }
        
        #ui {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .player-info {
            padding: 10px;
            border-radius: 5px;
            min-width: 240px;
        }
        
        .player1-info {
            background: rgba(255, 100, 100, 0.3);
            border: 2px solid #ff6464;
        }
        
        .player2-info {
            background: rgba(100, 100, 255, 0.3);
            border: 2px solid #6464ff;
        }
        
        #controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 900px;
        }
        
        .control-row {
            margin: 5px 0;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            display: none;
            border: 3px solid #ffff00;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        button:hover {
            transform: scale(1.05);
        }

        #audioControls {
            margin-top: 10px;
            text-align: center;
        }
        
        #volumeControl {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <h1>⚡ 能量球大战 ⚡</h1>
    
    <div id="audioControls">
        <label>🔊 音效音量: </label>
        <input type="range" id="volumeControl" min="0" max="100" value="50">
        <span id="volumeDisplay">50%</span>
    </div>
    
    <div id="ui">
        <div class="player-info player1-info">
            <div>🔴 玩家1 (红色)</div>
            <div>生命值: <span id="p1Health">150</span></div>
            <div>能量: <span id="p1Energy">0</span></div>
            <div>护盾: <span id="p1Shield">0</span>s</div>
            <div>剑气: <span id="p1Swords">0</span>层</div>
            <div>速度: <span id="p1Speed">100</span>%</div>
            <div>得分: <span id="p1Score">0</span></div>
        </div>
        <div class="player-info player2-info">
            <div>🔵 玩家2 (蓝色)</div>
            <div>生命值: <span id="p2Health">150</span></div>
            <div>能量: <span id="p2Energy">0</span></div>
            <div>护盾: <span id="p2Shield">0</span>s</div>
            <div>剑气: <span id="p2Swords">0</span>层</div>
            <div>速度: <span id="p2Speed">100</span>%</div>
            <div>得分: <span id="p2Score">0</span></div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameOver">
            <div id="winner"></div>
            <button onclick="restartGame()">重新开始</button>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row"><strong>🎮 游戏控制</strong></div>
        <div class="control-row">🔴 玩家1: WASD移动 | 空格键发射能量弹</div>
        <div class="control-row">🔵 玩家2: 方向键移动 | 回车键发射能量弹</div>
        <div class="control-row"><strong>📋 道具系统 (含音效)</strong></div>
        <div class="control-row">• ⚡黄色能量球(+25能量) • ❤️红色爱心(+40生命) • 🛡️蓝色护盾(5秒无敌)</div>
        <div class="control-row">• 🚀火箭筒(追踪导弹) • ⚡紫色闪电(6秒小幅加速) • 🔥火焰球(穿透攻击)</div>
        <div class="control-row">• 💥爆裂弹(360°火焰散射) • ⚔️剑气护体(近战防御+叠加伤害翻倍) • 🌟金色星星(满能量+满血)</div>
        <div class="control-row">• ❄️冰冻球(减速敌人-极稀有) • 💀骷髅头毒球(-25生命)</div>
        <div class="control-row"><strong>⚠️ 特殊效果</strong></div>
        <div class="control-row">• 🚀导弹威力50，爆炸范围60像素 • 💥爆裂弹碰撞后360°发射小火焰</div>
        <div class="control-row">• ⚔️剑气叠加伤害翻倍，一次攻击消耗一层剑气 • ⚡加速效果让移动速度提升50%</div>
        <div class="control-row">• 🔥火焰球可穿透目标继续飞行 • ❄️冰冻效果持续8秒(超稀有道具)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 音效系统
        class AudioManager {
            constructor() {
                this.volume = 0.5;
                this.audioContext = null;
                this.sounds = {};
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.log('音频上下文创建失败，使用静音模式');
                }
            }
            
            createSounds() {
                this.sounds = {
                    heal: this.createHealSound(),
                    shield: this.createShieldSound(),
                    rocketFly: this.createRocketFlySound(),
                    speedBoost: this.createSpeedBoostSound(),
                    fireball: this.createFireballSound(),
                    goldenStar: this.createGoldenStarSound(),
                    freeze: this.createFreezeSound(),
                    explosion: this.createExplosionSound(),
                    hit: this.createHitSound(),
                    burstShot: this.createBurstShotSound(),
                    swordEquip: this.createSwordEquipSound(),
                    swordHit: this.createSwordHitSound()
                };
            }
            
            createHealSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 治疗音效 - 温和的上升音调
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(660, this.audioContext.currentTime + 0.3);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createShieldSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 护盾音效 - 能量充电声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(900, this.audioContext.currentTime + 0.4);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                };
            }
            
            createRocketFlySound() {
                if (!this.audioContext) return null;
                return () => {
                    // 火箭飞行音效 - "咻"声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.8);
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.8);
                };
            }
            
            createSpeedBoostSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 加速音效 - 快速上升
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(1800, this.audioContext.currentTime + 0.15);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }
            
            createFireballSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 火焰球音效 - 燃烧声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(300, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.linearRampToValueAtTime(100, this.audioContext.currentTime + 0.4);
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.45);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.45);
                };
            }
            
            createGoldenStarSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 金色星星音效 - 魔法和弦
                    const frequencies = [523, 659, 784, 1047];
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, this.audioContext.currentTime + 0.01);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.8);
                        }, index * 100);
                    });
                };
            }
            
            createFreezeSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 冰冻音效 - 结冰声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.6);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.6);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.6);
                };
            }
            
            createHitSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 受击音效 - 短促的撞击声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(100, this.audioContext.currentTime + 0.1);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.15);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.15);
                };
            }
            
            createBurstShotSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 爆裂弹音效 - 爆裂声
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 0.2);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.25);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.25);
                };
            }
            
            createSwordEquipSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 剑气装备音效 - 金属共鸣
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createSwordHitSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 剑气击中音效 - 金属碰撞
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.1);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.12);
                };
            }
            
            createExplosionSound() {
                if (!this.audioContext) return null;
                return () => {
                    // 爆炸音效 - 白噪音+低频轰鸣
                    const bufferSize = this.audioContext.sampleRate * 0.4;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    source.buffer = buffer;
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(this.volume * 0.5, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    source.start(this.audioContext.currentTime);
                    
                    // 低频轰鸣
                    const rumble = this.audioContext.createOscillator();
                    const rumbleGain = this.audioContext.createGain();
                    
                    rumble.connect(rumbleGain);
                    rumbleGain.connect(this.audioContext.destination);
                    
                    rumble.frequency.setValueAtTime(50, this.audioContext.currentTime);
                    rumble.frequency.exponentialRampToValueAtTime(20, this.audioContext.currentTime + 0.3);
                    rumble.type = 'sine';
                    
                    rumbleGain.gain.setValueAtTime(this.volume * 0.3, this.audioContext.currentTime);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                    
                    rumble.start(this.audioContext.currentTime);
                    rumble.stop(this.audioContext.currentTime + 0.3);
                };
            }
            
            play(soundName) {
                if (this.sounds[soundName] && this.audioContext && this.audioContext.state === 'running') {
                    try {
                        this.sounds[soundName]();
                    } catch (e) {
                        console.log('音效播放失败:', soundName);
                    }
                }
            }
            
            setVolume(volume) {
                this.volume = volume / 100;
            }
            
            resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }
        
        // 初始化音效管理器
        const audioManager = new AudioManager();
        
        // 音量控制
        const volumeControl = document.getElementById('volumeControl');
        const volumeDisplay = document.getElementById('volumeDisplay');
        
        volumeControl.addEventListener('input', (e) => {
            const volume = e.target.value;
            audioManager.setVolume(volume);
            volumeDisplay.textContent = volume + '%';
        });
        
        // 游戏状态
        let gameRunning = true;
        let keys = {};
        let frameCount = 0; // 添加帧计数器
        
        // 小火焰类
        class SmallFlame {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.width = 8;
                this.height = 8;
                this.speed = 4;
                this.life = 60;
                this.animFrame = 0;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                // 检测与玩家碰撞
                [player1, player2].forEach(player => {
                    if (this.x < player.x + player.width &&
                        this.x + this.width > player.x &&
                        this.y < player.y + player.height &&
                        this.y + this.height > player.y) {
                        player.takeDamage(15);
                        this.life = 0;
                    }
                });
                
                return this.life > 0;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.animFrame) * 1;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 10;
                
                // 外层 - 橙红色
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // 内层 - 黄色
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
        
        // 玩家对象
        class Player {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.width = 35;
                this.height = 35;
                this.color = color;
                this.health = 150;
                this.maxHealth = 150;
                this.energy = 0;
                this.score = 0;
                this.baseSpeed = 4;
                this.speed = 4;
                this.controls = controls;
                this.lastShot = 0;
                this.shootCooldown = 300;
                this.animFrame = 0;
                this.shieldTime = 0;
                this.speedBoostTime = 0;
                this.slowTime = 0;
                this.swordLayers = 0; // 剑气层数
                this.swordAnimFrame = 0;
            }
            
            update() {
                this.animFrame += 0.1;
                this.swordAnimFrame += 0.15;
                
                // 更新护盾时间
                if (this.shieldTime > 0) {
                    this.shieldTime -= 16;
                    if (this.shieldTime < 0) this.shieldTime = 0;
                }
                
                // 更新加速效果
                if (this.speedBoostTime > 0) {
                    this.speedBoostTime -= 16;
                    this.speed = this.baseSpeed * 1.5;
                    if (this.speedBoostTime <= 0) {
                        this.speed = this.baseSpeed;
                    }
                }
                
                // 更新减速效果
                if (this.slowTime > 0) {
                    this.slowTime -= 16;
                    this.speed = this.baseSpeed * 0.5;
                    if (this.slowTime <= 0) {
                        this.speed = this.baseSpeed;
                    }
                }
                
                // 移动控制
                if (keys[this.controls.up] && this.y > 0) this.y -= this.speed;
                if (keys[this.controls.down] && this.y < canvas.height - this.height) this.y += this.speed;
                if (keys[this.controls.left] && this.x > 0) this.x -= this.speed;
                if (keys[this.controls.right] && this.x < canvas.width - this.width) this.x += this.speed;
                
                // 射击控制
                if (keys[this.controls.shoot] && this.energy >= 10 && Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
                
                // 检测剑气与敌方的碰撞 - 每2帧检测一次
                if (this.swordLayers > 0 && frameCount % 2 === 0) {
                    const enemy = this === player1 ? player2 : player1;
                    const distance = Math.sqrt(
                        (this.x + this.width/2 - enemy.x - enemy.width/2) ** 2 +
                        (this.y + this.height/2 - enemy.y - enemy.height/2) ** 2
                    );
                    
                    if (distance < this.width/2 + enemy.width/2 + 20 + this.swordLayers * 5) {
                        // 叠加伤害翻倍：基础伤害5 * 剑气层数
                        const damage = 5 * this.swordLayers;
                        enemy.takeDamage(damage);
                        audioManager.play('swordHit');
                        this.score += 2 * this.swordLayers;
                    }
                }
            }
            
            shoot() {
                if (this.energy >= 10) {
                    this.energy -= 10;
                    bullets.push(new Bullet(
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        this.color,
                        this
                    ));
                }
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 2;
                
                // 绘制剑气环绕效果 - 恢复原始造型
                if (this.swordLayers > 0) {
                    for (let layer = 0; layer < this.swordLayers; layer++) {
                        const radius = this.width/2 + 20 + layer * 5;
                        const swordCount = 6 + layer * 2;
                        
                        for (let i = 0; i < swordCount; i++) {
                            const angle = (this.swordAnimFrame + layer * 0.5 + i * Math.PI * 2 / swordCount) % (Math.PI * 2);
                            const swordX = centerX + Math.cos(angle) * radius;
                            const swordY = centerY + Math.sin(angle) * radius;
                            
                            ctx.save();
                            ctx.translate(swordX, swordY);
                            ctx.rotate(angle + Math.PI/2);
                            
                            // 剑气颜色根据层数变化
                            const alpha = 0.6 + layer * 0.1;
                            ctx.globalAlpha = alpha;
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 8;
                            
                            // 绘制剑形 - 恢复原始大小
                            ctx.fillStyle = '#87ceeb';
                            ctx.fillRect(-2, -8, 4, 16);
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(-1, -6, 2, 12);
                            
                            ctx.restore();
                        }
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // 绘制加速效果
                if (this.speedBoostTime > 0) {
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width/2 + 8 + i * 4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // 绘制减速效果
                if (this.slowTime > 0) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#87ceeb';
                    for (let i = 0; i < 5; i++) {
                        const angle = (this.animFrame * 2 + i * Math.PI * 2 / 5) % (Math.PI * 2);
                        const x = centerX + Math.cos(angle) * (this.width/2 + 15);
                        const y = centerY + Math.sin(angle) * (this.width/2 + 15);
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // 绘制护盾效果
                if (this.shieldTime > 0) {
                    const shieldAlpha = 0.3 + Math.sin(this.animFrame * 2) * 0.2;
                    ctx.globalAlpha = shieldAlpha;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // 绘制外发光
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                
                // 绘制主体
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 8);
                ctx.fill();
                
                // 绘制机器人细节
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                const eyeSize = 4;
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY - 5, eyeSize, 0, Math.PI * 2);
                ctx.arc(centerX + 8, centerY - 5, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY - 5, 2, 0, Math.PI * 2);
                ctx.arc(centerX + 8, centerY - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY + 5, 6, 0, Math.PI);
                ctx.stroke();
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX, this.y - 8);
                ctx.stroke();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, this.y - 8, 3 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 8);
                ctx.stroke();
                
                // 绘制生命值条
                const barWidth = this.width;
                const barHeight = 5;
                const barY = this.y - 12;
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#44ff44';
                ctx.fillRect(this.x, barY, barWidth * (this.health / this.maxHealth), barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, barY, barWidth, barHeight);
            }
            
            takeDamage(damage) {
                // 一次攻击只消耗一层剑气
                if (this.swordLayers > 0) {
                    this.swordLayers--;
                    audioManager.play('swordHit');
                    // 如果还有护盾，护盾继续保护
                    if (this.shieldTime > 0) {
                        return;
                    }
                }
                
                // 护盾保护
                if (this.shieldTime > 0) {
                    return;
                }
                
                this.health -= damage;
                audioManager.play('hit');
                if (this.health <= 0) {
                    this.health = 0;
                    gameRunning = false;
                }
            }
            
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                audioManager.play('heal');
            }
            
            activateShield() {
                this.shieldTime = 5000;
                audioManager.play('shield');
            }
            
            activateSpeedBoost() {
                this.speedBoostTime = 6000;
                audioManager.play('speedBoost');
            }
            
            applySlow() {
                this.slowTime = 8000;
                audioManager.play('freeze');
            }
            
            addSwordLayer() {
                this.swordLayers = Math.min(this.swordLayers + 1, 5); // 最多5层
                audioManager.play('swordEquip');
            }
            
            getShieldTimeSeconds() {
                return Math.ceil(this.shieldTime / 1000);
            }
            
            getSpeedPercentage() {
                return Math.round((this.speed / this.baseSpeed) * 100);
            }
        }
        
        // 子弹类
        class Bullet {
            constructor(x, y, color, owner) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.color = color;
                this.owner = owner;
                this.speed = 7;
                this.life = 100;
                this.animFrame = 0;
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.2;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    target.takeDamage(20);
                    this.owner.score += 10;
                    return false;
                }
                
                return true;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 2;
                
                // 外发光
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;
                
                // 外圈
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // 中圈
                ctx.fillStyle = this.color === '#ff6464' ? '#ff8888' : '#8888ff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/3 + pulse * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 内核
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/5, 0, Math.PI * 2);
                ctx.fill();
                
                // 边框增强
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // 爆裂弹类 - 修正为360°散射
        class BurstBullet {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.owner = owner;
                this.speed = 6;
                this.life = 80;
                this.animFrame = 0;
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    this.burst();
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    this.burst();
                    return false;
                }
                
                return true;
            }
            
            burst() {
                audioManager.play('explosion');
                
                // 360°发射小火焰，密一点
                const flameCount = 16; // 增加火焰数量
                for (let i = 0; i < flameCount; i++) {
                    const angle = (i * Math.PI * 2) / flameCount;
                    smallFlames.push(new SmallFlame(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        angle
                    ));
                }
                
                // 直接伤害
                [player1, player2].forEach(player => {
                    const distance = Math.sqrt(
                        (player.x + player.width/2 - this.x - this.width/2) ** 2 +
                        (player.y + player.height/2 - this.y - this.height/2) ** 2
                    );
                    
                    if (distance <= 30 && player !== this.owner) {
                        player.takeDamage(25);
                        this.owner.score += 15;
                    }
                });
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 3;
                
                // 爆裂弹特效 - 橙黄色闪烁
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 25;
                
                // 外层 - 橙色
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // 中层 - 黄色
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/3 + pulse * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // 内核 - 白色
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/5, 0, Math.PI * 2);
                ctx.fill();
                
                // 闪烁效果
                if (Math.sin(this.animFrame * 2) > 0) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + pulse + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        // 火焰弹类
        class FireBullet {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 18;
                this.height = 18;
                this.owner = owner;
                this.speed = 8;
                this.life = 120;
                this.pierced = false;
                this.animFrame = 0;
                this.trail = [];
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                // 添加尾迹效果
                this.trail.push({
                    x: this.x + this.width/2,
                    y: this.y + this.height/2,
                    life: 15,
                    size: Math.random() * 8 + 4
                });
                this.trail = this.trail.filter(t => t.life-- > 0);
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (!this.pierced && this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    target.takeDamage(35);
                    this.owner.score += 15;
                    this.pierced = true;
                }
                
                return true;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                // 绘制火焰尾迹
                this.trail.forEach((t, i) => {
                    const alpha = t.life / 15;
                    ctx.globalAlpha = alpha * 0.6;
                    
                    // 橙色外层
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 黄色内层
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // 主体火焰效果
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                // 外层火焰 - 橙红色
                const outerSize = this.width/2 + Math.sin(this.animFrame) * 3;
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 中层火焰 - 橙色
                const midSize = this.width/2.5 + Math.sin(this.animFrame * 1.2) * 2;
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, midSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 内层火焰 - 黄色
                const innerSize = this.width/3.5 + Math.sin(this.animFrame * 1.5) * 1;
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 核心 - 白热
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/6, 0, Math.PI * 2);
                ctx.fill();
                
                // 火花效果
                for (let i = 0; i < 6; i++) {
                    const angle = (this.animFrame + i * Math.PI / 3) % (Math.PI * 2);
                    const sparkX = centerX + Math.cos(angle) * (outerSize + 5);
                    const sparkY = centerY + Math.sin(angle) * (outerSize + 5);
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        // 火箭弹类
        class Rocket {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.owner = owner;
                this.speed = 3.5;
                this.life = 3000;
                this.target = owner === player1 ? player2 : player1;
                this.trail = [];
                this.explosionRadius = 60;
                this.animFrame = 0;
                this.angle = 0;
                
                // 发射时播放飞行音效
                audioManager.play('rocketFly');
            }
            
            update() {
                this.life -= 16;
                this.animFrame += 0.2;
                
                // 增强尾迹效果
                this.trail.push({
                    x: this.x + this.width/2,
                    y: this.y + this.height/2,
                    life: 25,
                    size: Math.random() * 6 + 3
                });
                this.trail = this.trail.filter(t => t.life-- > 0);
                
                const dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
                const dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.angle = Math.atan2(dy, dx);
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                    this.x += this.vx;
                    this.y += this.vy;
                }
                
                if (this.x < this.target.x + this.target.width &&
                    this.x + this.width > this.target.x &&
                    this.y < this.target.y + this.target.height &&
                    this.y + this.height > this.target.y) {
                    this.explode();
                    return false;
                }
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    this.explode();
                    return false;
                }
                
                return true;
            }
            
            explode() {
                audioManager.play('explosion');
                explosions.push(new Explosion(this.x + this.width/2, this.y + this.height/2, this.explosionRadius));
                
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                [player1, player2].forEach(player => {
                    const playerCenterX = player.x + player.width/2;
                    const playerCenterY = player.y + player.height/2;
                    const distance = Math.sqrt(
                        (playerCenterX - centerX) ** 2 + 
                        (playerCenterY - centerY) ** 2
                    );
                    
                    if (distance <= this.explosionRadius && player !== this.owner) {
                        player.takeDamage(50);
                        this.owner.score += 25;
                    }
                });
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                // 绘制推进器尾迹
                this.trail.forEach((t, i) => {
                    const alpha = t.life / 25;
                    ctx.globalAlpha = alpha;
                    
                    // 蓝色推进器火焰
                    ctx.fillStyle = '#0066ff';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // 白色核心
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // 保存画布状态
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.angle);
                
                // 导弹主体阴影
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                
                // 导弹主体 - 金属灰色
                ctx.fillStyle = '#666666';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height * 0.8);
                
                // 导弹头部 - 红色
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.moveTo(this.width/2, 0);
                ctx.lineTo(-this.width/2, -this.height/3);
                ctx.lineTo(-this.width/2, this.height/3);
                ctx.closePath();
                ctx.fill();
                
                // 导弹尾翼
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-this.width/2, -this.height/2, this.width/4, this.height/6);
                ctx.fillRect(-this.width/2, this.height/2 - this.height/6, this.width/4, this.height/6);
                
                // 导弹身体细节
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.width/4, -this.height/3);
                ctx.lineTo(-this.width/4, this.height/3);
                ctx.stroke();
                
                // 闪烁警示灯
                if (Math.sin(this.animFrame * 3) > 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                ctx.shadowBlur = 0;
            }
        }
        
        // 爆炸效果类
        class Explosion {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.currentRadius = 0;
                this.life = 30;
                this.maxLife = 30;
            }
            
            update() {
                this.life--;
                this.currentRadius = (this.radius * (this.maxLife - this.life)) / this.maxLife;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            }
        }
        
        // 能量球类
        class EnergyOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 20;
                this.height = 20;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.15;
                
                if (this.checkCollision(player1)) {
                    player1.energy += 25;
                    player1.score += 5;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.energy += 25;
                    player2.score += 5;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('⚡', centerX, centerY + 5);
            }
        }
        
        // 回血道具类
        class HealthOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 20;
                this.height = 20;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    player1.heal(40);
                    player1.score += 8;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.heal(40);
                    player2.score += 8;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const heartSize = 8 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#ff69b4';
                ctx.shadowBlur = 15;
                
                ctx.fillStyle = '#ff1493';
                ctx.beginPath();
                
                ctx.arc(centerX - heartSize/3, centerY - heartSize/3, heartSize/2, 0, Math.PI, true);
                ctx.arc(centerX + heartSize/3, centerY - heartSize/3, heartSize/2, 0, Math.PI, true);
                ctx.lineTo(centerX, centerY + heartSize/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.arc(centerX - heartSize/4, centerY - heartSize/2, heartSize/6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 护盾道具类
        class ShieldOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.1;
                
                if (this.checkCollision(player1)) {
                    player1.activateShield();
                    player1.score += 15;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.activateShield();
                    player2.score += 15;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#00bfff';
                ctx.shadowBlur = 20;
                
                ctx.strokeStyle = '#00bfff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(0, 191, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size - 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🛡️', centerX, centerY + 5);
            }
        }
        
        // 火箭筒道具类
        class RocketLauncher {
            constructor() {
                this.x = Math.random() * (canvas.width - 30);
                this.y = Math.random() * (canvas.height - 30);
                this.width = 25;
                this.height = 25;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.08;
                
                if (this.checkCollision(player1)) {
                    rockets.push(new Rocket(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 20;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    rockets.push(new Rocket(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 20;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🚀', centerX, centerY + 6);
                
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // 加速道具类
        class SpeedBoost {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.2;
                
                if (this.checkCollision(player1)) {
                    player1.activateSpeedBoost();
                    player1.score += 8;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.activateSpeedBoost();
                    player2.score += 8;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#9932cc';
                ctx.shadowBlur = 15;
                
                ctx.fillStyle = '#9932cc';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('⚡', centerX, centerY + 5);
            }
        }
        
        // 火焰球道具类
        class FireBall {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 23;
                this.height = 23;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.15;
                
                if (this.checkCollision(player1)) {
                    fireBullets.push(new FireBullet(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 18;
                    audioManager.play('fireball');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    fireBullets.push(new FireBullet(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 18;
                    audioManager.play('fireball');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🔥', centerX, centerY + 5);
            }
        }
        
        // 爆裂弹道具类
        class BurstBallOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 24;
                this.height = 24;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.18;
                
                if (this.checkCollision(player1)) {
                    burstBullets.push(new BurstBullet(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 16;
                    audioManager.play('burstShot');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    burstBullets.push(new BurstBullet(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 16;
                    audioManager.play('burstShot');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 25;
                
                // 外层 - 橙色
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // 内层 - 黄色
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('💥', centerX, centerY + 5);
                
                // 闪烁边框
                if (Math.sin(this.pulse * 2) > 0) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        // 剑气道具类
        class SwordOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 24;
                this.height = 24;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    player1.addSwordLayer();
                    player1.score += 12;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.addSwordLayer();
                    player2.score += 12;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#87ceeb';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#87ceeb';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('⚔️', centerX, centerY + 5);
                
                // 旋转剑气效果
                for (let i = 0; i < 4; i++) {
                    const angle = (this.pulse + i * Math.PI / 2) % (Math.PI * 2);
                    const swordX = centerX + Math.cos(angle) * (size + 8);
                    const swordY = centerY + Math.sin(angle) * (size + 8);
                    
                    ctx.save();
                    ctx.translate(swordX, swordY);
                    ctx.rotate(angle + Math.PI/2);
                    ctx.globalAlpha = 0.6;
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1, -4, 2, 8);
                    
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }
        }
        
        // 金色星星道具类
        class GoldenStar {
            constructor() {
                this.x = Math.random() * (canvas.width - 30);
                this.y = Math.random() * (canvas.height - 30);
                this.width = 28;
                this.height = 28;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.1;
                
                if (this.checkCollision(player1)) {
                    player1.heal(150);
                    player1.energy = 100;
                    player1.score += 30;
                    audioManager.play('goldenStar');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.heal(150);
                    player2.energy = 100;
                    player2.score += 30;
                    audioManager.play('goldenStar');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 4;
                
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 30;
                
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🌟', centerX, centerY + 6);
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // 冰冻球道具类
        class IceBall {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    const target = player2;
                    target.applySlow();
                    player1.score += 25;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    const target = player1;
                    target.applySlow();
                    player2.score += 25;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#87ceeb';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#87ceeb';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 6, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('❄️', centerX, centerY + 5);
            }
        }
        
        // 毒球类 - 移除音效
        class PoisonOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.2;
                
                if (this.checkCollision(player1)) {
                    player1.takeDamage(25);
                    // 移除毒球音效
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.takeDamage(25);
                    // 移除毒球音效
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#8b0000';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('💀', centerX, centerY + 6);
            }
        }
        
        // 初始化游戏对象
        const player1 = new Player(50, 300, '#ff6464', {
            up: 'w', down: 's', left: 'a', right: 'd', shoot: ' '
        });
        
        const player2 = new Player(715, 300, '#6464ff', {
            up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Enter'
        });
        
        let bullets = [];
        let fireBullets = [];
        let burstBullets = [];
        let smallFlames = [];
        let rockets = [];
        let explosions = [];
        let energyOrbs = [];
        let healthOrbs = [];
        let shieldOrbs = [];
        let rocketLaunchers = [];
        let speedBoosts = [];
        let fireBalls = [];
        let burstBallOrbs = [];
        let swordOrbs = [];
        let goldenStars = [];
        let iceBalls = [];
        let poisonOrbs = [];
        
        // 事件监听
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            e.preventDefault();
            audioManager.resumeContext();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // 生成道具
        function spawnOrbs() {
            // 基础道具
            if (Math.random() < 0.015 && energyOrbs.length < 3) {
                energyOrbs.push(new EnergyOrb());
            }
            if (Math.random() < 0.008 && healthOrbs.length < 2) {
                healthOrbs.push(new HealthOrb());
            }
            
            // 防御道具
            if (Math.random() < 0.0008 && shieldOrbs.length < 1) {
                shieldOrbs.push(new ShieldOrb());
            }
            if (Math.random() < 0.002 && swordOrbs.length < 1) {
                swordOrbs.push(new SwordOrb());
            }
            
            // 攻击道具
            if (Math.random() < 0.0004 && rocketLaunchers.length < 1) {
                rocketLaunchers.push(new RocketLauncher());
            }
            if (Math.random() < 0.004 && fireBalls.length < 1) {
                fireBalls.push(new FireBall());
            }
            if (Math.random() < 0.003 && burstBallOrbs.length < 1) {
                burstBallOrbs.push(new BurstBallOrb());
            }
            
            // 加速道具
            if (Math.random() < 0.001 && speedBoosts.length < 1) {
                speedBoosts.push(new SpeedBoost());
            }
            
            // 超稀有道具
            if (Math.random() < 0.0001 && goldenStars.length < 1) {
                goldenStars.push(new GoldenStar());
            }
            
            // 冰冻球 - 极其稀有
            if (Math.random() < 0.0002 && iceBalls.length < 1) {
                iceBalls.push(new IceBall());
            }
            
            // 危险道具
            if (Math.random() < 0.006 && poisonOrbs.length < 2) {
                poisonOrbs.push(new PoisonOrb());
            }
        }
        
        // 更新UI
        function updateUI() {
            document.getElementById('p1Health').textContent = player1.health;
            document.getElementById('p1Energy').textContent = player1.energy;
            document.getElementById('p1Shield').textContent = player1.getShieldTimeSeconds();
            document.getElementById('p1Swords').textContent = player1.swordLayers;
            document.getElementById('p1Speed').textContent = player1.getSpeedPercentage();
            document.getElementById('p1Score').textContent = player1.score;
            
            document.getElementById('p2Health').textContent = player2.health;
            document.getElementById('p2Energy').textContent = player2.energy;
            document.getElementById('p2Shield').textContent = player2.getShieldTimeSeconds();
            document.getElementById('p2Swords').textContent = player2.swordLayers;
            document.getElementById('p2Speed').textContent = player2.getSpeedPercentage();
            document.getElementById('p2Score').textContent = player2.score;
        }
        
        // 游戏循环
        function gameLoop() {
            frameCount++; // 增加帧计数
            
            if (!gameRunning) {
                showGameOver();
                return;
            }
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 更新玩家
            player1.update();
            player2.update();
            
            // 更新子弹和特殊武器
            bullets = bullets.filter(bullet => bullet.update());
            fireBullets = fireBullets.filter(bullet => bullet.update());
            burstBullets = burstBullets.filter(bullet => bullet.update());
            smallFlames = smallFlames.filter(flame => flame.update());
            rockets = rockets.filter(rocket => rocket.update());
            explosions = explosions.filter(explosion => explosion.update());
            
            // 更新道具
            energyOrbs = energyOrbs.filter(orb => orb.update());
            healthOrbs = healthOrbs.filter(orb => orb.update());
            shieldOrbs = shieldOrbs.filter(orb => orb.update());
            rocketLaunchers = rocketLaunchers.filter(launcher => launcher.update());
            speedBoosts = speedBoosts.filter(boost => boost.update());
            fireBalls = fireBalls.filter(ball => ball.update());
            burstBallOrbs = burstBallOrbs.filter(orb => orb.update());
            swordOrbs = swordOrbs.filter(orb => orb.update());
            goldenStars = goldenStars.filter(star => star.update());
            iceBalls = iceBalls.filter(ball => ball.update());
            poisonOrbs = poisonOrbs.filter(orb => orb.update());
            
            // 生成新道具
            spawnOrbs();
            
            // 绘制所有对象
            energyOrbs.forEach(orb => orb.draw());
            healthOrbs.forEach(orb => orb.draw());
            shieldOrbs.forEach(orb => orb.draw());
            rocketLaunchers.forEach(launcher => launcher.draw());
            speedBoosts.forEach(boost => boost.draw());
            fireBalls.forEach(ball => ball.draw());
            burstBallOrbs.forEach(orb => orb.draw());
            swordOrbs.forEach(orb => orb.draw());
            goldenStars.forEach(star => star.draw());
            iceBalls.forEach(ball => ball.draw());
            poisonOrbs.forEach(orb => orb.draw());
            bullets.forEach(bullet => bullet.draw());
            fireBullets.forEach(bullet => bullet.draw());
            burstBullets.forEach(bullet => bullet.draw());
            smallFlames.forEach(flame => flame.draw());
            rockets.forEach(rocket => rocket.draw());
            explosions.forEach(explosion => explosion.draw());
            player1.draw();
            player2.draw();
            
            // 更新UI
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // 显示游戏结束
        function showGameOver() {
            const gameOverDiv = document.getElementById('gameOver');
            const winnerDiv = document.getElementById('winner');
            
            if (player1.health <= 0) {
                winnerDiv.innerHTML = '🎉 玩家2 (蓝色机器人) 获胜！🎉';
            } else if (player2.health <= 0) {
                winnerDiv.innerHTML = '🎉 玩家1 (红色机器人) 获胜！🎉';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        // 重新开始游戏
        function restartGame() {
            gameRunning = true;
            frameCount = 0; // 重置帧计数
            
            // 重置玩家
            player1.health = 150;
            player1.energy = 0;
            player1.score = 0;
            player1.shieldTime = 0;
            player1.speedBoostTime = 0;
            player1.slowTime = 0;
            player1.swordLayers = 0;
            player1.speed = player1.baseSpeed;
            player1.x = 50;
            player1.y = 300;
            
            player2.health = 150;
            player2.energy = 0;
            player2.score = 0;
            player2.shieldTime = 0;
            player2.speedBoostTime = 0;
            player2.slowTime = 0;
            player2.swordLayers = 0;
            player2.speed = player2.baseSpeed;
            player2.x = 715;
            player2.y = 300;
            
            // 清空数组
            bullets = [];
            fireBullets = [];
            burstBullets = [];
            smallFlames = [];
            rockets = [];
            explosions = [];
            energyOrbs = [];
            healthOrbs = [];
            shieldOrbs = [];
            rocketLaunchers = [];
            speedBoosts = [];
            fireBalls = [];
            burstBallOrbs = [];
            swordOrbs = [];
            goldenStars = [];
            iceBalls = [];
            poisonOrbs = [];
            
            // 隐藏游戏结束界面
            document.getElementById('gameOver').style.display = 'none';
            
            // 重新开始游戏循环
            gameLoop();
        }
        
        // 开始游戏
        gameLoop();
    </script>
</body>
</html>
