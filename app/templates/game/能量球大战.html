<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èƒ½é‡çƒå¤§æˆ˜ - åŒäººå¯¹æˆ˜</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 20px #00ffff;
        }
        
        #gameCanvas {
            background: linear-gradient(135deg, #0f3460, #16537e);
            display: block;
        }
        
        #ui {
            display: flex;
            justify-content: space-between;
            width: 800px;
            margin-bottom: 10px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .player-info {
            padding: 10px;
            border-radius: 5px;
            min-width: 240px;
        }
        
        .player1-info {
            background: rgba(255, 100, 100, 0.3);
            border: 2px solid #ff6464;
        }
        
        .player2-info {
            background: rgba(100, 100, 255, 0.3);
            border: 2px solid #6464ff;
        }
        
        #controls {
            margin-top: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 900px;
        }
        
        .control-row {
            margin: 5px 0;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            display: none;
            border: 3px solid #ffff00;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            color: white;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        
        button:hover {
            transform: scale(1.05);
        }

        #audioControls {
            margin-top: 10px;
            text-align: center;
        }
        
        #volumeControl {
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <h1>âš¡ èƒ½é‡çƒå¤§æˆ˜ âš¡</h1>
    
    <div id="audioControls">
        <label>ğŸ”Š éŸ³æ•ˆéŸ³é‡: </label>
        <input type="range" id="volumeControl" min="0" max="100" value="50">
        <span id="volumeDisplay">50%</span>
    </div>
    
    <div id="ui">
        <div class="player-info player1-info">
            <div>ğŸ”´ ç©å®¶1 (çº¢è‰²)</div>
            <div>ç”Ÿå‘½å€¼: <span id="p1Health">150</span></div>
            <div>èƒ½é‡: <span id="p1Energy">0</span></div>
            <div>æŠ¤ç›¾: <span id="p1Shield">0</span>s</div>
            <div>å‰‘æ°”: <span id="p1Swords">0</span>å±‚</div>
            <div>é€Ÿåº¦: <span id="p1Speed">100</span>%</div>
            <div>å¾—åˆ†: <span id="p1Score">0</span></div>
        </div>
        <div class="player-info player2-info">
            <div>ğŸ”µ ç©å®¶2 (è“è‰²)</div>
            <div>ç”Ÿå‘½å€¼: <span id="p2Health">150</span></div>
            <div>èƒ½é‡: <span id="p2Energy">0</span></div>
            <div>æŠ¤ç›¾: <span id="p2Shield">0</span>s</div>
            <div>å‰‘æ°”: <span id="p2Swords">0</span>å±‚</div>
            <div>é€Ÿåº¦: <span id="p2Speed">100</span>%</div>
            <div>å¾—åˆ†: <span id="p2Score">0</span></div>
        </div>
    </div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="gameOver">
            <div id="winner"></div>
            <button onclick="restartGame()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>
    
    <div id="controls">
        <div class="control-row"><strong>ğŸ® æ¸¸æˆæ§åˆ¶</strong></div>
        <div class="control-row">ğŸ”´ ç©å®¶1: WASDç§»åŠ¨ | ç©ºæ ¼é”®å‘å°„èƒ½é‡å¼¹</div>
        <div class="control-row">ğŸ”µ ç©å®¶2: æ–¹å‘é”®ç§»åŠ¨ | å›è½¦é”®å‘å°„èƒ½é‡å¼¹</div>
        <div class="control-row"><strong>ğŸ“‹ é“å…·ç³»ç»Ÿ (å«éŸ³æ•ˆ)</strong></div>
        <div class="control-row">â€¢ âš¡é»„è‰²èƒ½é‡çƒ(+25èƒ½é‡) â€¢ â¤ï¸çº¢è‰²çˆ±å¿ƒ(+40ç”Ÿå‘½) â€¢ ğŸ›¡ï¸è“è‰²æŠ¤ç›¾(5ç§’æ— æ•Œ)</div>
        <div class="control-row">â€¢ ğŸš€ç«ç®­ç­’(è¿½è¸ªå¯¼å¼¹) â€¢ âš¡ç´«è‰²é—ªç”µ(6ç§’å°å¹…åŠ é€Ÿ) â€¢ ğŸ”¥ç«ç„°çƒ(ç©¿é€æ”»å‡»)</div>
        <div class="control-row">â€¢ ğŸ’¥çˆ†è£‚å¼¹(360Â°ç«ç„°æ•£å°„) â€¢ âš”ï¸å‰‘æ°”æŠ¤ä½“(è¿‘æˆ˜é˜²å¾¡+å åŠ ä¼¤å®³ç¿»å€) â€¢ ğŸŒŸé‡‘è‰²æ˜Ÿæ˜Ÿ(æ»¡èƒ½é‡+æ»¡è¡€)</div>
        <div class="control-row">â€¢ â„ï¸å†°å†»çƒ(å‡é€Ÿæ•Œäºº-æç¨€æœ‰) â€¢ ğŸ’€éª·é«…å¤´æ¯’çƒ(-25ç”Ÿå‘½)</div>
        <div class="control-row"><strong>âš ï¸ ç‰¹æ®Šæ•ˆæœ</strong></div>
        <div class="control-row">â€¢ ğŸš€å¯¼å¼¹å¨åŠ›50ï¼Œçˆ†ç‚¸èŒƒå›´60åƒç´  â€¢ ğŸ’¥çˆ†è£‚å¼¹ç¢°æ’å360Â°å‘å°„å°ç«ç„°</div>
        <div class="control-row">â€¢ âš”ï¸å‰‘æ°”å åŠ ä¼¤å®³ç¿»å€ï¼Œä¸€æ¬¡æ”»å‡»æ¶ˆè€—ä¸€å±‚å‰‘æ°” â€¢ âš¡åŠ é€Ÿæ•ˆæœè®©ç§»åŠ¨é€Ÿåº¦æå‡50%</div>
        <div class="control-row">â€¢ ğŸ”¥ç«ç„°çƒå¯ç©¿é€ç›®æ ‡ç»§ç»­é£è¡Œ â€¢ â„ï¸å†°å†»æ•ˆæœæŒç»­8ç§’(è¶…ç¨€æœ‰é“å…·)</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // éŸ³æ•ˆç³»ç»Ÿ
        class AudioManager {
            constructor() {
                this.volume = 0.5;
                this.audioContext = null;
                this.sounds = {};
                this.init();
            }
            
            init() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡åˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨é™éŸ³æ¨¡å¼');
                }
            }
            
            createSounds() {
                this.sounds = {
                    heal: this.createHealSound(),
                    shield: this.createShieldSound(),
                    rocketFly: this.createRocketFlySound(),
                    speedBoost: this.createSpeedBoostSound(),
                    fireball: this.createFireballSound(),
                    goldenStar: this.createGoldenStarSound(),
                    freeze: this.createFreezeSound(),
                    explosion: this.createExplosionSound(),
                    hit: this.createHitSound(),
                    burstShot: this.createBurstShotSound(),
                    swordEquip: this.createSwordEquipSound(),
                    swordHit: this.createSwordHitSound()
                };
            }
            
            createHealSound() {
                if (!this.audioContext) return null;
                return () => {
                    // æ²»ç–—éŸ³æ•ˆ - æ¸©å’Œçš„ä¸Šå‡éŸ³è°ƒ
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(660, this.audioContext.currentTime + 0.3);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createShieldSound() {
                if (!this.audioContext) return null;
                return () => {
                    // æŠ¤ç›¾éŸ³æ•ˆ - èƒ½é‡å……ç”µå£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(900, this.audioContext.currentTime + 0.4);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.5);
                };
            }
            
            createRocketFlySound() {
                if (!this.audioContext) return null;
                return () => {
                    // ç«ç®­é£è¡ŒéŸ³æ•ˆ - "å’»"å£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.8);
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.8);
                };
            }
            
            createSpeedBoostSound() {
                if (!this.audioContext) return null;
                return () => {
                    // åŠ é€ŸéŸ³æ•ˆ - å¿«é€Ÿä¸Šå‡
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(1800, this.audioContext.currentTime + 0.15);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.2);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }
            
            createFireballSound() {
                if (!this.audioContext) return null;
                return () => {
                    // ç«ç„°çƒéŸ³æ•ˆ - ç‡ƒçƒ§å£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(150, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(300, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.linearRampToValueAtTime(100, this.audioContext.currentTime + 0.4);
                    oscillator.type = 'sawtooth';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.45);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.45);
                };
            }
            
            createGoldenStarSound() {
                if (!this.audioContext) return null;
                return () => {
                    // é‡‘è‰²æ˜Ÿæ˜ŸéŸ³æ•ˆ - é­”æ³•å’Œå¼¦
                    const frequencies = [523, 659, 784, 1047];
                    frequencies.forEach((freq, index) => {
                        setTimeout(() => {
                            const oscillator = this.audioContext.createOscillator();
                            const gainNode = this.audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(this.audioContext.destination);
                            
                            oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                            oscillator.type = 'sine';
                            
                            gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                            gainNode.gain.linearRampToValueAtTime(this.volume * 0.2, this.audioContext.currentTime + 0.01);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                            
                            oscillator.start(this.audioContext.currentTime);
                            oscillator.stop(this.audioContext.currentTime + 0.8);
                        }, index * 100);
                    });
                };
            }
            
            createFreezeSound() {
                if (!this.audioContext) return null;
                return () => {
                    // å†°å†»éŸ³æ•ˆ - ç»“å†°å£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.6);
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.6);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.6);
                };
            }
            
            createHitSound() {
                if (!this.audioContext) return null;
                return () => {
                    // å—å‡»éŸ³æ•ˆ - çŸ­ä¿ƒçš„æ’å‡»å£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(100, this.audioContext.currentTime + 0.1);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.15);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.15);
                };
            }
            
            createBurstShotSound() {
                if (!this.audioContext) return null;
                return () => {
                    // çˆ†è£‚å¼¹éŸ³æ•ˆ - çˆ†è£‚å£°
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(400, this.audioContext.currentTime + 0.2);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.4, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.25);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.25);
                };
            }
            
            createSwordEquipSound() {
                if (!this.audioContext) return null;
                return () => {
                    // å‰‘æ°”è£…å¤‡éŸ³æ•ˆ - é‡‘å±å…±é¸£
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1200, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(800, this.audioContext.currentTime + 0.3);
                    oscillator.type = 'triangle';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.4);
                };
            }
            
            createSwordHitSound() {
                if (!this.audioContext) return null;
                return () => {
                    // å‰‘æ°”å‡»ä¸­éŸ³æ•ˆ - é‡‘å±ç¢°æ’
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(1500, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.1);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume * 0.3, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.12);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.12);
                };
            }
            
            createExplosionSound() {
                if (!this.audioContext) return null;
                return () => {
                    // çˆ†ç‚¸éŸ³æ•ˆ - ç™½å™ªéŸ³+ä½é¢‘è½°é¸£
                    const bufferSize = this.audioContext.sampleRate * 0.4;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    const filter = this.audioContext.createBiquadFilter();
                    
                    source.buffer = buffer;
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(1000, this.audioContext.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.3);
                    
                    gainNode.gain.setValueAtTime(this.volume * 0.5, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.4);
                    
                    source.start(this.audioContext.currentTime);
                    
                    // ä½é¢‘è½°é¸£
                    const rumble = this.audioContext.createOscillator();
                    const rumbleGain = this.audioContext.createGain();
                    
                    rumble.connect(rumbleGain);
                    rumbleGain.connect(this.audioContext.destination);
                    
                    rumble.frequency.setValueAtTime(50, this.audioContext.currentTime);
                    rumble.frequency.exponentialRampToValueAtTime(20, this.audioContext.currentTime + 0.3);
                    rumble.type = 'sine';
                    
                    rumbleGain.gain.setValueAtTime(this.volume * 0.3, this.audioContext.currentTime);
                    rumbleGain.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
                    
                    rumble.start(this.audioContext.currentTime);
                    rumble.stop(this.audioContext.currentTime + 0.3);
                };
            }
            
            play(soundName) {
                if (this.sounds[soundName] && this.audioContext && this.audioContext.state === 'running') {
                    try {
                        this.sounds[soundName]();
                    } catch (e) {
                        console.log('éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', soundName);
                    }
                }
            }
            
            setVolume(volume) {
                this.volume = volume / 100;
            }
            
            resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }
        
        // åˆå§‹åŒ–éŸ³æ•ˆç®¡ç†å™¨
        const audioManager = new AudioManager();
        
        // éŸ³é‡æ§åˆ¶
        const volumeControl = document.getElementById('volumeControl');
        const volumeDisplay = document.getElementById('volumeDisplay');
        
        volumeControl.addEventListener('input', (e) => {
            const volume = e.target.value;
            audioManager.setVolume(volume);
            volumeDisplay.textContent = volume + '%';
        });
        
        // æ¸¸æˆçŠ¶æ€
        let gameRunning = true;
        let keys = {};
        let frameCount = 0; // æ·»åŠ å¸§è®¡æ•°å™¨
        
        // å°ç«ç„°ç±»
        class SmallFlame {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.width = 8;
                this.height = 8;
                this.speed = 4;
                this.life = 60;
                this.animFrame = 0;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                // æ£€æµ‹ä¸ç©å®¶ç¢°æ’
                [player1, player2].forEach(player => {
                    if (this.x < player.x + player.width &&
                        this.x + this.width > player.x &&
                        this.y < player.y + player.height &&
                        this.y + this.height > player.y) {
                        player.takeDamage(15);
                        this.life = 0;
                    }
                });
                
                return this.life > 0;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.animFrame) * 1;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 10;
                
                // å¤–å±‚ - æ©™çº¢è‰²
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…å±‚ - é»„è‰²
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
        
        // ç©å®¶å¯¹è±¡
        class Player {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.width = 35;
                this.height = 35;
                this.color = color;
                this.health = 150;
                this.maxHealth = 150;
                this.energy = 0;
                this.score = 0;
                this.baseSpeed = 4;
                this.speed = 4;
                this.controls = controls;
                this.lastShot = 0;
                this.shootCooldown = 300;
                this.animFrame = 0;
                this.shieldTime = 0;
                this.speedBoostTime = 0;
                this.slowTime = 0;
                this.swordLayers = 0; // å‰‘æ°”å±‚æ•°
                this.swordAnimFrame = 0;
            }
            
            update() {
                this.animFrame += 0.1;
                this.swordAnimFrame += 0.15;
                
                // æ›´æ–°æŠ¤ç›¾æ—¶é—´
                if (this.shieldTime > 0) {
                    this.shieldTime -= 16;
                    if (this.shieldTime < 0) this.shieldTime = 0;
                }
                
                // æ›´æ–°åŠ é€Ÿæ•ˆæœ
                if (this.speedBoostTime > 0) {
                    this.speedBoostTime -= 16;
                    this.speed = this.baseSpeed * 1.5;
                    if (this.speedBoostTime <= 0) {
                        this.speed = this.baseSpeed;
                    }
                }
                
                // æ›´æ–°å‡é€Ÿæ•ˆæœ
                if (this.slowTime > 0) {
                    this.slowTime -= 16;
                    this.speed = this.baseSpeed * 0.5;
                    if (this.slowTime <= 0) {
                        this.speed = this.baseSpeed;
                    }
                }
                
                // ç§»åŠ¨æ§åˆ¶
                if (keys[this.controls.up] && this.y > 0) this.y -= this.speed;
                if (keys[this.controls.down] && this.y < canvas.height - this.height) this.y += this.speed;
                if (keys[this.controls.left] && this.x > 0) this.x -= this.speed;
                if (keys[this.controls.right] && this.x < canvas.width - this.width) this.x += this.speed;
                
                // å°„å‡»æ§åˆ¶
                if (keys[this.controls.shoot] && this.energy >= 10 && Date.now() - this.lastShot > this.shootCooldown) {
                    this.shoot();
                    this.lastShot = Date.now();
                }
                
                // æ£€æµ‹å‰‘æ°”ä¸æ•Œæ–¹çš„ç¢°æ’ - æ¯2å¸§æ£€æµ‹ä¸€æ¬¡
                if (this.swordLayers > 0 && frameCount % 2 === 0) {
                    const enemy = this === player1 ? player2 : player1;
                    const distance = Math.sqrt(
                        (this.x + this.width/2 - enemy.x - enemy.width/2) ** 2 +
                        (this.y + this.height/2 - enemy.y - enemy.height/2) ** 2
                    );
                    
                    if (distance < this.width/2 + enemy.width/2 + 20 + this.swordLayers * 5) {
                        // å åŠ ä¼¤å®³ç¿»å€ï¼šåŸºç¡€ä¼¤å®³5 * å‰‘æ°”å±‚æ•°
                        const damage = 5 * this.swordLayers;
                        enemy.takeDamage(damage);
                        audioManager.play('swordHit');
                        this.score += 2 * this.swordLayers;
                    }
                }
            }
            
            shoot() {
                if (this.energy >= 10) {
                    this.energy -= 10;
                    bullets.push(new Bullet(
                        this.x + this.width/2, 
                        this.y + this.height/2, 
                        this.color,
                        this
                    ));
                }
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 2;
                
                // ç»˜åˆ¶å‰‘æ°”ç¯ç»•æ•ˆæœ - æ¢å¤åŸå§‹é€ å‹
                if (this.swordLayers > 0) {
                    for (let layer = 0; layer < this.swordLayers; layer++) {
                        const radius = this.width/2 + 20 + layer * 5;
                        const swordCount = 6 + layer * 2;
                        
                        for (let i = 0; i < swordCount; i++) {
                            const angle = (this.swordAnimFrame + layer * 0.5 + i * Math.PI * 2 / swordCount) % (Math.PI * 2);
                            const swordX = centerX + Math.cos(angle) * radius;
                            const swordY = centerY + Math.sin(angle) * radius;
                            
                            ctx.save();
                            ctx.translate(swordX, swordY);
                            ctx.rotate(angle + Math.PI/2);
                            
                            // å‰‘æ°”é¢œè‰²æ ¹æ®å±‚æ•°å˜åŒ–
                            const alpha = 0.6 + layer * 0.1;
                            ctx.globalAlpha = alpha;
                            ctx.shadowColor = '#00ffff';
                            ctx.shadowBlur = 8;
                            
                            // ç»˜åˆ¶å‰‘å½¢ - æ¢å¤åŸå§‹å¤§å°
                            ctx.fillStyle = '#87ceeb';
                            ctx.fillRect(-2, -8, 4, 16);
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(-1, -6, 2, 12);
                            
                            ctx.restore();
                        }
                    }
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                
                // ç»˜åˆ¶åŠ é€Ÿæ•ˆæœ
                if (this.speedBoostTime > 0) {
                    ctx.globalAlpha = 0.3;
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 2; i++) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width/2 + 8 + i * 4, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // ç»˜åˆ¶å‡é€Ÿæ•ˆæœ
                if (this.slowTime > 0) {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#87ceeb';
                    for (let i = 0; i < 5; i++) {
                        const angle = (this.animFrame * 2 + i * Math.PI * 2 / 5) % (Math.PI * 2);
                        const x = centerX + Math.cos(angle) * (this.width/2 + 15);
                        const y = centerY + Math.sin(angle) * (this.width/2 + 15);
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // ç»˜åˆ¶æŠ¤ç›¾æ•ˆæœ
                if (this.shieldTime > 0) {
                    const shieldAlpha = 0.3 + Math.sin(this.animFrame * 2) * 0.2;
                    ctx.globalAlpha = shieldAlpha;
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + 12, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // ç»˜åˆ¶å¤–å‘å…‰
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;
                
                // ç»˜åˆ¶ä¸»ä½“
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 8);
                ctx.fill();
                
                // ç»˜åˆ¶æœºå™¨äººç»†èŠ‚
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'white';
                const eyeSize = 4;
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY - 5, eyeSize, 0, Math.PI * 2);
                ctx.arc(centerX + 8, centerY - 5, eyeSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(centerX - 8, centerY - 5, 2, 0, Math.PI * 2);
                ctx.arc(centerX + 8, centerY - 5, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY + 5, 6, 0, Math.PI);
                ctx.stroke();
                
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(centerX, this.y);
                ctx.lineTo(centerX, this.y - 8);
                ctx.stroke();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, this.y - 8, 3 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, this.width, this.height, 8);
                ctx.stroke();
                
                // ç»˜åˆ¶ç”Ÿå‘½å€¼æ¡
                const barWidth = this.width;
                const barHeight = 5;
                const barY = this.y - 12;
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(this.x, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(this.x, barY, barWidth, barHeight);
                
                ctx.fillStyle = '#44ff44';
                ctx.fillRect(this.x, barY, barWidth * (this.health / this.maxHealth), barHeight);
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, barY, barWidth, barHeight);
            }
            
            takeDamage(damage) {
                // ä¸€æ¬¡æ”»å‡»åªæ¶ˆè€—ä¸€å±‚å‰‘æ°”
                if (this.swordLayers > 0) {
                    this.swordLayers--;
                    audioManager.play('swordHit');
                    // å¦‚æœè¿˜æœ‰æŠ¤ç›¾ï¼ŒæŠ¤ç›¾ç»§ç»­ä¿æŠ¤
                    if (this.shieldTime > 0) {
                        return;
                    }
                }
                
                // æŠ¤ç›¾ä¿æŠ¤
                if (this.shieldTime > 0) {
                    return;
                }
                
                this.health -= damage;
                audioManager.play('hit');
                if (this.health <= 0) {
                    this.health = 0;
                    gameRunning = false;
                }
            }
            
            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                audioManager.play('heal');
            }
            
            activateShield() {
                this.shieldTime = 5000;
                audioManager.play('shield');
            }
            
            activateSpeedBoost() {
                this.speedBoostTime = 6000;
                audioManager.play('speedBoost');
            }
            
            applySlow() {
                this.slowTime = 8000;
                audioManager.play('freeze');
            }
            
            addSwordLayer() {
                this.swordLayers = Math.min(this.swordLayers + 1, 5); // æœ€å¤š5å±‚
                audioManager.play('swordEquip');
            }
            
            getShieldTimeSeconds() {
                return Math.ceil(this.shieldTime / 1000);
            }
            
            getSpeedPercentage() {
                return Math.round((this.speed / this.baseSpeed) * 100);
            }
        }
        
        // å­å¼¹ç±»
        class Bullet {
            constructor(x, y, color, owner) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.color = color;
                this.owner = owner;
                this.speed = 7;
                this.life = 100;
                this.animFrame = 0;
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.2;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    target.takeDamage(20);
                    this.owner.score += 10;
                    return false;
                }
                
                return true;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 2;
                
                // å¤–å‘å…‰
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;
                
                // å¤–åœˆ
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­åœˆ
                ctx.fillStyle = this.color === '#ff6464' ? '#ff8888' : '#8888ff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/3 + pulse * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…æ ¸
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/5, 0, Math.PI * 2);
                ctx.fill();
                
                // è¾¹æ¡†å¢å¼º
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // çˆ†è£‚å¼¹ç±» - ä¿®æ­£ä¸º360Â°æ•£å°„
        class BurstBullet {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 16;
                this.height = 16;
                this.owner = owner;
                this.speed = 6;
                this.life = 80;
                this.animFrame = 0;
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    this.burst();
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    this.burst();
                    return false;
                }
                
                return true;
            }
            
            burst() {
                audioManager.play('explosion');
                
                // 360Â°å‘å°„å°ç«ç„°ï¼Œå¯†ä¸€ç‚¹
                const flameCount = 16; // å¢åŠ ç«ç„°æ•°é‡
                for (let i = 0; i < flameCount; i++) {
                    const angle = (i * Math.PI * 2) / flameCount;
                    smallFlames.push(new SmallFlame(
                        this.x + this.width/2,
                        this.y + this.height/2,
                        angle
                    ));
                }
                
                // ç›´æ¥ä¼¤å®³
                [player1, player2].forEach(player => {
                    const distance = Math.sqrt(
                        (player.x + player.width/2 - this.x - this.width/2) ** 2 +
                        (player.y + player.height/2 - this.y - this.height/2) ** 2
                    );
                    
                    if (distance <= 30 && player !== this.owner) {
                        player.takeDamage(25);
                        this.owner.score += 15;
                    }
                });
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const pulse = Math.sin(this.animFrame) * 3;
                
                // çˆ†è£‚å¼¹ç‰¹æ•ˆ - æ©™é»„è‰²é—ªçƒ
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 25;
                
                // å¤–å±‚ - æ©™è‰²
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/2 + pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å±‚ - é»„è‰²
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/3 + pulse * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…æ ¸ - ç™½è‰²
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/5, 0, Math.PI * 2);
                ctx.fill();
                
                // é—ªçƒæ•ˆæœ
                if (Math.sin(this.animFrame * 2) > 0) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, this.width/2 + pulse + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        // ç«ç„°å¼¹ç±»
        class FireBullet {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 18;
                this.height = 18;
                this.owner = owner;
                this.speed = 8;
                this.life = 120;
                this.pierced = false;
                this.animFrame = 0;
                this.trail = [];
                
                const target = owner === player1 ? player2 : player1;
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.animFrame += 0.3;
                
                // æ·»åŠ å°¾è¿¹æ•ˆæœ
                this.trail.push({
                    x: this.x + this.width/2,
                    y: this.y + this.height/2,
                    life: 15,
                    size: Math.random() * 8 + 4
                });
                this.trail = this.trail.filter(t => t.life-- > 0);
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    return false;
                }
                
                const target = this.owner === player1 ? player2 : player1;
                if (!this.pierced && this.x < target.x + target.width &&
                    this.x + this.width > target.x &&
                    this.y < target.y + target.height &&
                    this.y + this.height > target.y) {
                    target.takeDamage(35);
                    this.owner.score += 15;
                    this.pierced = true;
                }
                
                return true;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                // ç»˜åˆ¶ç«ç„°å°¾è¿¹
                this.trail.forEach((t, i) => {
                    const alpha = t.life / 15;
                    ctx.globalAlpha = alpha * 0.6;
                    
                    // æ©™è‰²å¤–å±‚
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // é»„è‰²å†…å±‚
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // ä¸»ä½“ç«ç„°æ•ˆæœ
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                // å¤–å±‚ç«ç„° - æ©™çº¢è‰²
                const outerSize = this.width/2 + Math.sin(this.animFrame) * 3;
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.arc(centerX, centerY, outerSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å±‚ç«ç„° - æ©™è‰²
                const midSize = this.width/2.5 + Math.sin(this.animFrame * 1.2) * 2;
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, midSize, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…å±‚ç«ç„° - é»„è‰²
                const innerSize = this.width/3.5 + Math.sin(this.animFrame * 1.5) * 1;
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerSize, 0, Math.PI * 2);
                ctx.fill();
                
                // æ ¸å¿ƒ - ç™½çƒ­
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.width/6, 0, Math.PI * 2);
                ctx.fill();
                
                // ç«èŠ±æ•ˆæœ
                for (let i = 0; i < 6; i++) {
                    const angle = (this.animFrame + i * Math.PI / 3) % (Math.PI * 2);
                    const sparkX = centerX + Math.cos(angle) * (outerSize + 5);
                    const sparkY = centerY + Math.sin(angle) * (outerSize + 5);
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        // ç«ç®­å¼¹ç±»
        class Rocket {
            constructor(x, y, owner) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.owner = owner;
                this.speed = 3.5;
                this.life = 3000;
                this.target = owner === player1 ? player2 : player1;
                this.trail = [];
                this.explosionRadius = 60;
                this.animFrame = 0;
                this.angle = 0;
                
                // å‘å°„æ—¶æ’­æ”¾é£è¡ŒéŸ³æ•ˆ
                audioManager.play('rocketFly');
            }
            
            update() {
                this.life -= 16;
                this.animFrame += 0.2;
                
                // å¢å¼ºå°¾è¿¹æ•ˆæœ
                this.trail.push({
                    x: this.x + this.width/2,
                    y: this.y + this.height/2,
                    life: 25,
                    size: Math.random() * 6 + 3
                });
                this.trail = this.trail.filter(t => t.life-- > 0);
                
                const dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
                const dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.angle = Math.atan2(dy, dx);
                    this.vx = (dx / distance) * this.speed;
                    this.vy = (dy / distance) * this.speed;
                    this.x += this.vx;
                    this.y += this.vy;
                }
                
                if (this.x < this.target.x + this.target.width &&
                    this.x + this.width > this.target.x &&
                    this.y < this.target.y + this.target.height &&
                    this.y + this.height > this.target.y) {
                    this.explode();
                    return false;
                }
                
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height || this.life <= 0) {
                    this.explode();
                    return false;
                }
                
                return true;
            }
            
            explode() {
                audioManager.play('explosion');
                explosions.push(new Explosion(this.x + this.width/2, this.y + this.height/2, this.explosionRadius));
                
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                [player1, player2].forEach(player => {
                    const playerCenterX = player.x + player.width/2;
                    const playerCenterY = player.y + player.height/2;
                    const distance = Math.sqrt(
                        (playerCenterX - centerX) ** 2 + 
                        (playerCenterY - centerY) ** 2
                    );
                    
                    if (distance <= this.explosionRadius && player !== this.owner) {
                        player.takeDamage(50);
                        this.owner.score += 25;
                    }
                });
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                
                // ç»˜åˆ¶æ¨è¿›å™¨å°¾è¿¹
                this.trail.forEach((t, i) => {
                    const alpha = t.life / 25;
                    ctx.globalAlpha = alpha;
                    
                    // è“è‰²æ¨è¿›å™¨ç«ç„°
                    ctx.fillStyle = '#0066ff';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ç™½è‰²æ ¸å¿ƒ
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, t.size * alpha * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
                
                // ä¿å­˜ç”»å¸ƒçŠ¶æ€
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(this.angle);
                
                // å¯¼å¼¹ä¸»ä½“é˜´å½±
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                
                // å¯¼å¼¹ä¸»ä½“ - é‡‘å±ç°è‰²
                ctx.fillStyle = '#666666';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height * 0.8);
                
                // å¯¼å¼¹å¤´éƒ¨ - çº¢è‰²
                ctx.fillStyle = '#ff3300';
                ctx.beginPath();
                ctx.moveTo(this.width/2, 0);
                ctx.lineTo(-this.width/2, -this.height/3);
                ctx.lineTo(-this.width/2, this.height/3);
                ctx.closePath();
                ctx.fill();
                
                // å¯¼å¼¹å°¾ç¿¼
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(-this.width/2, -this.height/2, this.width/4, this.height/6);
                ctx.fillRect(-this.width/2, this.height/2 - this.height/6, this.width/4, this.height/6);
                
                // å¯¼å¼¹èº«ä½“ç»†èŠ‚
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-this.width/4, -this.height/3);
                ctx.lineTo(-this.width/4, this.height/3);
                ctx.stroke();
                
                // é—ªçƒè­¦ç¤ºç¯
                if (Math.sin(this.animFrame * 3) > 0) {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
                ctx.shadowBlur = 0;
            }
        }
        
        // çˆ†ç‚¸æ•ˆæœç±»
        class Explosion {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.currentRadius = 0;
                this.life = 30;
                this.maxLife = 30;
            }
            
            update() {
                this.life--;
                this.currentRadius = (this.radius * (this.maxLife - this.life)) / this.maxLife;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalAlpha = 1;
            }
        }
        
        // èƒ½é‡çƒç±»
        class EnergyOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 20;
                this.height = 20;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.15;
                
                if (this.checkCollision(player1)) {
                    player1.energy += 25;
                    player1.score += 5;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.energy += 25;
                    player2.score += 5;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('âš¡', centerX, centerY + 5);
            }
        }
        
        // å›è¡€é“å…·ç±»
        class HealthOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 20;
                this.height = 20;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    player1.heal(40);
                    player1.score += 8;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.heal(40);
                    player2.score += 8;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const heartSize = 8 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#ff69b4';
                ctx.shadowBlur = 15;
                
                ctx.fillStyle = '#ff1493';
                ctx.beginPath();
                
                ctx.arc(centerX - heartSize/3, centerY - heartSize/3, heartSize/2, 0, Math.PI, true);
                ctx.arc(centerX + heartSize/3, centerY - heartSize/3, heartSize/2, 0, Math.PI, true);
                ctx.lineTo(centerX, centerY + heartSize/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.arc(centerX - heartSize/4, centerY - heartSize/2, heartSize/6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // æŠ¤ç›¾é“å…·ç±»
        class ShieldOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.1;
                
                if (this.checkCollision(player1)) {
                    player1.activateShield();
                    player1.score += 15;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.activateShield();
                    player2.score += 15;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#00bfff';
                ctx.shadowBlur = 20;
                
                ctx.strokeStyle = '#00bfff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(0, 191, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size - 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ›¡ï¸', centerX, centerY + 5);
            }
        }
        
        // ç«ç®­ç­’é“å…·ç±»
        class RocketLauncher {
            constructor() {
                this.x = Math.random() * (canvas.width - 30);
                this.y = Math.random() * (canvas.height - 30);
                this.width = 25;
                this.height = 25;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.08;
                
                if (this.checkCollision(player1)) {
                    rockets.push(new Rocket(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 20;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    rockets.push(new Rocket(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 20;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸš€', centerX, centerY + 6);
                
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // åŠ é€Ÿé“å…·ç±»
        class SpeedBoost {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.2;
                
                if (this.checkCollision(player1)) {
                    player1.activateSpeedBoost();
                    player1.score += 8;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.activateSpeedBoost();
                    player2.score += 8;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#9932cc';
                ctx.shadowBlur = 15;
                
                ctx.fillStyle = '#9932cc';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('âš¡', centerX, centerY + 5);
            }
        }
        
        // ç«ç„°çƒé“å…·ç±»
        class FireBall {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 23;
                this.height = 23;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.15;
                
                if (this.checkCollision(player1)) {
                    fireBullets.push(new FireBullet(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 18;
                    audioManager.play('fireball');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    fireBullets.push(new FireBullet(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 18;
                    audioManager.play('fireball');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#ff4500';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ”¥', centerX, centerY + 5);
            }
        }
        
        // çˆ†è£‚å¼¹é“å…·ç±»
        class BurstBallOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 24;
                this.height = 24;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.18;
                
                if (this.checkCollision(player1)) {
                    burstBullets.push(new BurstBullet(player1.x + player1.width/2, player1.y + player1.height/2, player1));
                    player1.score += 16;
                    audioManager.play('burstShot');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    burstBullets.push(new BurstBullet(player2.x + player2.width/2, player2.y + player2.height/2, player2));
                    player2.score += 16;
                    audioManager.play('burstShot');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 3;
                
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 25;
                
                // å¤–å±‚ - æ©™è‰²
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // å†…å±‚ - é»„è‰²
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ’¥', centerX, centerY + 5);
                
                // é—ªçƒè¾¹æ¡†
                if (Math.sin(this.pulse * 2) > 0) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        // å‰‘æ°”é“å…·ç±»
        class SwordOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 24;
                this.height = 24;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    player1.addSwordLayer();
                    player1.score += 12;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.addSwordLayer();
                    player2.score += 12;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#87ceeb';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#87ceeb';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('âš”ï¸', centerX, centerY + 5);
                
                // æ—‹è½¬å‰‘æ°”æ•ˆæœ
                for (let i = 0; i < 4; i++) {
                    const angle = (this.pulse + i * Math.PI / 2) % (Math.PI * 2);
                    const swordX = centerX + Math.cos(angle) * (size + 8);
                    const swordY = centerY + Math.sin(angle) * (size + 8);
                    
                    ctx.save();
                    ctx.translate(swordX, swordY);
                    ctx.rotate(angle + Math.PI/2);
                    ctx.globalAlpha = 0.6;
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-1, -4, 2, 8);
                    
                    ctx.restore();
                }
                ctx.globalAlpha = 1;
            }
        }
        
        // é‡‘è‰²æ˜Ÿæ˜Ÿé“å…·ç±»
        class GoldenStar {
            constructor() {
                this.x = Math.random() * (canvas.width - 30);
                this.y = Math.random() * (canvas.height - 30);
                this.width = 28;
                this.height = 28;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.1;
                
                if (this.checkCollision(player1)) {
                    player1.heal(150);
                    player1.energy = 100;
                    player1.score += 30;
                    audioManager.play('goldenStar');
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.heal(150);
                    player2.energy = 100;
                    player2.score += 30;
                    audioManager.play('goldenStar');
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 4;
                
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 30;
                
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 22px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸŒŸ', centerX, centerY + 6);
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        // å†°å†»çƒé“å…·ç±»
        class IceBall {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.12;
                
                if (this.checkCollision(player1)) {
                    const target = player2;
                    target.applySlow();
                    player1.score += 25;
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    const target = player1;
                    target.applySlow();
                    player2.score += 25;
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#87ceeb';
                ctx.shadowBlur = 25;
                
                ctx.fillStyle = '#87ceeb';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(centerX, centerY, size + 6, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('â„ï¸', centerX, centerY + 5);
            }
        }
        
        // æ¯’çƒç±» - ç§»é™¤éŸ³æ•ˆ
        class PoisonOrb {
            constructor() {
                this.x = Math.random() * (canvas.width - 25);
                this.y = Math.random() * (canvas.height - 25);
                this.width = 22;
                this.height = 22;
                this.pulse = 0;
            }
            
            update() {
                this.pulse += 0.2;
                
                if (this.checkCollision(player1)) {
                    player1.takeDamage(25);
                    // ç§»é™¤æ¯’çƒéŸ³æ•ˆ
                    return false;
                }
                
                if (this.checkCollision(player2)) {
                    player2.takeDamage(25);
                    // ç§»é™¤æ¯’çƒéŸ³æ•ˆ
                    return false;
                }
                
                return true;
            }
            
            checkCollision(player) {
                return this.x < player.x + player.width &&
                       this.x + this.width > player.x &&
                       this.y < player.y + player.height &&
                       this.y + this.height > player.y;
            }
            
            draw() {
                const centerX = this.x + this.width/2;
                const centerY = this.y + this.height/2;
                const size = this.width/2 + Math.sin(this.pulse) * 2;
                
                ctx.shadowColor = '#8b0000';
                ctx.shadowBlur = 20;
                
                ctx.fillStyle = '#8b0000';
                ctx.beginPath();
                ctx.arc(centerX, centerY, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ’€', centerX, centerY + 6);
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆå¯¹è±¡
        const player1 = new Player(50, 300, '#ff6464', {
            up: 'w', down: 's', left: 'a', right: 'd', shoot: ' '
        });
        
        const player2 = new Player(715, 300, '#6464ff', {
            up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Enter'
        });
        
        let bullets = [];
        let fireBullets = [];
        let burstBullets = [];
        let smallFlames = [];
        let rockets = [];
        let explosions = [];
        let energyOrbs = [];
        let healthOrbs = [];
        let shieldOrbs = [];
        let rocketLaunchers = [];
        let speedBoosts = [];
        let fireBalls = [];
        let burstBallOrbs = [];
        let swordOrbs = [];
        let goldenStars = [];
        let iceBalls = [];
        let poisonOrbs = [];
        
        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            e.preventDefault();
            audioManager.resumeContext();
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // ç”Ÿæˆé“å…·
        function spawnOrbs() {
            // åŸºç¡€é“å…·
            if (Math.random() < 0.015 && energyOrbs.length < 3) {
                energyOrbs.push(new EnergyOrb());
            }
            if (Math.random() < 0.008 && healthOrbs.length < 2) {
                healthOrbs.push(new HealthOrb());
            }
            
            // é˜²å¾¡é“å…·
            if (Math.random() < 0.0008 && shieldOrbs.length < 1) {
                shieldOrbs.push(new ShieldOrb());
            }
            if (Math.random() < 0.002 && swordOrbs.length < 1) {
                swordOrbs.push(new SwordOrb());
            }
            
            // æ”»å‡»é“å…·
            if (Math.random() < 0.0004 && rocketLaunchers.length < 1) {
                rocketLaunchers.push(new RocketLauncher());
            }
            if (Math.random() < 0.004 && fireBalls.length < 1) {
                fireBalls.push(new FireBall());
            }
            if (Math.random() < 0.003 && burstBallOrbs.length < 1) {
                burstBallOrbs.push(new BurstBallOrb());
            }
            
            // åŠ é€Ÿé“å…·
            if (Math.random() < 0.001 && speedBoosts.length < 1) {
                speedBoosts.push(new SpeedBoost());
            }
            
            // è¶…ç¨€æœ‰é“å…·
            if (Math.random() < 0.0001 && goldenStars.length < 1) {
                goldenStars.push(new GoldenStar());
            }
            
            // å†°å†»çƒ - æå…¶ç¨€æœ‰
            if (Math.random() < 0.0002 && iceBalls.length < 1) {
                iceBalls.push(new IceBall());
            }
            
            // å±é™©é“å…·
            if (Math.random() < 0.006 && poisonOrbs.length < 2) {
                poisonOrbs.push(new PoisonOrb());
            }
        }
        
        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('p1Health').textContent = player1.health;
            document.getElementById('p1Energy').textContent = player1.energy;
            document.getElementById('p1Shield').textContent = player1.getShieldTimeSeconds();
            document.getElementById('p1Swords').textContent = player1.swordLayers;
            document.getElementById('p1Speed').textContent = player1.getSpeedPercentage();
            document.getElementById('p1Score').textContent = player1.score;
            
            document.getElementById('p2Health').textContent = player2.health;
            document.getElementById('p2Energy').textContent = player2.energy;
            document.getElementById('p2Shield').textContent = player2.getShieldTimeSeconds();
            document.getElementById('p2Swords').textContent = player2.swordLayers;
            document.getElementById('p2Speed').textContent = player2.getSpeedPercentage();
            document.getElementById('p2Score').textContent = player2.score;
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            frameCount++; // å¢åŠ å¸§è®¡æ•°
            
            if (!gameRunning) {
                showGameOver();
                return;
            }
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // æ›´æ–°ç©å®¶
            player1.update();
            player2.update();
            
            // æ›´æ–°å­å¼¹å’Œç‰¹æ®Šæ­¦å™¨
            bullets = bullets.filter(bullet => bullet.update());
            fireBullets = fireBullets.filter(bullet => bullet.update());
            burstBullets = burstBullets.filter(bullet => bullet.update());
            smallFlames = smallFlames.filter(flame => flame.update());
            rockets = rockets.filter(rocket => rocket.update());
            explosions = explosions.filter(explosion => explosion.update());
            
            // æ›´æ–°é“å…·
            energyOrbs = energyOrbs.filter(orb => orb.update());
            healthOrbs = healthOrbs.filter(orb => orb.update());
            shieldOrbs = shieldOrbs.filter(orb => orb.update());
            rocketLaunchers = rocketLaunchers.filter(launcher => launcher.update());
            speedBoosts = speedBoosts.filter(boost => boost.update());
            fireBalls = fireBalls.filter(ball => ball.update());
            burstBallOrbs = burstBallOrbs.filter(orb => orb.update());
            swordOrbs = swordOrbs.filter(orb => orb.update());
            goldenStars = goldenStars.filter(star => star.update());
            iceBalls = iceBalls.filter(ball => ball.update());
            poisonOrbs = poisonOrbs.filter(orb => orb.update());
            
            // ç”Ÿæˆæ–°é“å…·
            spawnOrbs();
            
            // ç»˜åˆ¶æ‰€æœ‰å¯¹è±¡
            energyOrbs.forEach(orb => orb.draw());
            healthOrbs.forEach(orb => orb.draw());
            shieldOrbs.forEach(orb => orb.draw());
            rocketLaunchers.forEach(launcher => launcher.draw());
            speedBoosts.forEach(boost => boost.draw());
            fireBalls.forEach(ball => ball.draw());
            burstBallOrbs.forEach(orb => orb.draw());
            swordOrbs.forEach(orb => orb.draw());
            goldenStars.forEach(star => star.draw());
            iceBalls.forEach(ball => ball.draw());
            poisonOrbs.forEach(orb => orb.draw());
            bullets.forEach(bullet => bullet.draw());
            fireBullets.forEach(bullet => bullet.draw());
            burstBullets.forEach(bullet => bullet.draw());
            smallFlames.forEach(flame => flame.draw());
            rockets.forEach(rocket => rocket.draw());
            explosions.forEach(explosion => explosion.draw());
            player1.draw();
            player2.draw();
            
            // æ›´æ–°UI
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }
        
        // æ˜¾ç¤ºæ¸¸æˆç»“æŸ
        function showGameOver() {
            const gameOverDiv = document.getElementById('gameOver');
            const winnerDiv = document.getElementById('winner');
            
            if (player1.health <= 0) {
                winnerDiv.innerHTML = 'ğŸ‰ ç©å®¶2 (è“è‰²æœºå™¨äºº) è·èƒœï¼ğŸ‰';
            } else if (player2.health <= 0) {
                winnerDiv.innerHTML = 'ğŸ‰ ç©å®¶1 (çº¢è‰²æœºå™¨äºº) è·èƒœï¼ğŸ‰';
            }
            
            gameOverDiv.style.display = 'block';
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            gameRunning = true;
            frameCount = 0; // é‡ç½®å¸§è®¡æ•°
            
            // é‡ç½®ç©å®¶
            player1.health = 150;
            player1.energy = 0;
            player1.score = 0;
            player1.shieldTime = 0;
            player1.speedBoostTime = 0;
            player1.slowTime = 0;
            player1.swordLayers = 0;
            player1.speed = player1.baseSpeed;
            player1.x = 50;
            player1.y = 300;
            
            player2.health = 150;
            player2.energy = 0;
            player2.score = 0;
            player2.shieldTime = 0;
            player2.speedBoostTime = 0;
            player2.slowTime = 0;
            player2.swordLayers = 0;
            player2.speed = player2.baseSpeed;
            player2.x = 715;
            player2.y = 300;
            
            // æ¸…ç©ºæ•°ç»„
            bullets = [];
            fireBullets = [];
            burstBullets = [];
            smallFlames = [];
            rockets = [];
            explosions = [];
            energyOrbs = [];
            healthOrbs = [];
            shieldOrbs = [];
            rocketLaunchers = [];
            speedBoosts = [];
            fireBalls = [];
            burstBallOrbs = [];
            swordOrbs = [];
            goldenStars = [];
            iceBalls = [];
            poisonOrbs = [];
            
            // éšè—æ¸¸æˆç»“æŸç•Œé¢
            document.getElementById('gameOver').style.display = 'none';
            
            // é‡æ–°å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop();
        }
        
        // å¼€å§‹æ¸¸æˆ
        gameLoop();
    </script>
</body>
</html>
