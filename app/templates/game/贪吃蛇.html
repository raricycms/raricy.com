<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>贪吃蛇大作战 - 终极版（含手机虚拟按键）</title>

    <!-- 复古字体 -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

    <style>
        :root{
            --bg-color:#212121;
            --primary-color:#4CAF50;
            --primary-hover-color:#66BB6A;
            --surface-color:#333333;
            --text-color:#E0E0E0;
            --border-color:#555555;
            --snake1-color:#81C784;
            --snake2-color:#64B5F6;
            --control-size: 14vw; /* controls responsive size */
            --control-min: 48px;
            --control-max: 84px;
        }

        html,body{
            height:100%;
            margin:0;
            font-family:'Press Start 2P', cursive;
            background:var(--bg-color);
            color:var(--text-color);
        }

        /* 居中容器 */
        #game-container{
            min-height:100vh;
            display:flex;
            align-items:center;
            justify-content:center;
            padding:20px;
            box-sizing:border-box;
        }

        /* 菜单 */
        #menu{
            text-align:center;
        }
        #menu h1{
            color:var(--primary-color);
            font-size:2.2rem;
            margin:0 0 24px 0;
            text-shadow:3px 3px 0 #000;
        }
        .menu-btn{
            background-color:var(--primary-color);
            color:white;
            border:2px solid var(--border-color);
            padding:12px 20px;
            margin:8px;
            font-family:inherit;
            cursor:pointer;
            border-radius:8px;
            box-shadow:4px 4px 0 #000;
            transition:all .12s ease;
        }
        .menu-btn:active{ transform: translateY(2px); box-shadow:2px 2px 0 #000; }
        .menu-btn:hover{ background:var(--primary-hover-color); transform: translateY(-2px); box-shadow:6px 6px 0 #000; }

        /* 游戏主体 */
        #game-area{
            display:none;
            width:100%;
            max-width:960px;
            background:transparent;
            flex-direction:column;
            gap:12px;
            align-items:center;
        }

        #info-panel{
            width:100%;
            display:flex;
            justify-content:space-between;
            gap:10px;
            box-sizing:border-box;
        }
        #player1-info,#player2-info{
            background:var(--surface-color);
            border:2px solid var(--border-color);
            padding:8px 12px;
            border-radius:6px;
            min-width:80px;
            text-align:center;
            font-size:0.9rem;
        }

        /* 画布自适应 */
        .canvas-wrapper{
            display:flex;
            justify-content:center;
            align-items:center;
            width:100%;
        }

        canvas{
            background:#1a1a1a;
            border:3px solid var(--border-color);
            box-shadow:inset 0 0 10px #000;
            border-radius:6px;
            touch-action: none; /* 防止触摸拖拽页面时影响游戏 */
            -webkit-user-select:none;
            user-select:none;
        }

        /* 模态窗口 */
        #modal-overlay{
            position:fixed;
            inset:0;
            display:none;
            align-items:center;
            justify-content:center;
            background:rgba(0,0,0,0.7);
            z-index:1000;
        }
        #modal-overlay.visible{ display:flex; }
        #modal-box{
            width:90%;
            max-width:640px;
            background:var(--surface-color);
            border:3px solid var(--border-color);
            padding:22px;
            border-radius:10px;
            box-shadow:0 8px 30px rgba(0,0,0,0.6);
            color:var(--text-color);
        }
        #modal-box h2{ color:var(--primary-color); text-align:center; margin-top:0; }

        /* 手机控制区域（固定在视口底部） */
        #mobile-controls{
            position:fixed;
            left:0;
            right:0;
            bottom:env(safe-area-inset-bottom, 16px);
            display:flex;
            justify-content:space-between;
            align-items:flex-end;
            padding:12px 16px;
            pointer-events:auto;
            z-index:900;
            box-sizing:border-box;
        }

        .controls{
            display:flex;
            gap:10px;
            pointer-events:auto;
            align-items:center;
            user-select:none;
        }

        /* 方向盘风格（两行） */
        .dpad{
            display:flex;
            flex-direction:column;
            gap:8px;
            align-items:center;
        }
        .control-row{
            display:flex;
            gap:8px;
            align-items:center;
        }

        .control-btn{
            width: var(--control-size);
            height: var(--control-size);
            min-width:var(--control-min);
            min-height:var(--control-min);
            max-width:var(--control-max);
            max-height:var(--control-max);
            display:inline-flex;
            align-items:center;
            justify-content:center;
            border-radius:10px;
            background:var(--surface-color);
            border:3px solid var(--border-color);
            box-shadow:4px 4px 0 #000;
            font-size:1.1rem;
            font-family:inherit;
            color:var(--text-color);
            touch-action: none; /* 禁止浏览器默认触控行为 */
        }
        .control-btn:active, .control-btn.pressed{
            transform: translateY(3px);
            box-shadow:2px 2px 0 #000;
            background:var(--primary-hover-color);
            color:#000;
        }

        /* 当需要隐藏时使用 */
        .hidden{ display:none !important; }

        /* 小屏格局调整 */
        @media (max-width:420px){
            #menu h1{ font-size:1.6rem; }
            .menu-btn{ padding:10px 12px; font-size:0.8rem; }
            :root{ --control-size: 20vw; --control-min:48px; --control-max:72px; }
        }
    </style>
</head>
<body>
    <div id="game-container">

        <!-- 菜单 -->
        <div id="menu">
            <h1>贪吃蛇大作战</h1>
            <button id="single-player-btn" class="menu-btn">单人模式</button>
            <button id="dual-player-btn" class="menu-btn">双人对战</button>
            <button id="how-to-play-btn" class="menu-btn">玩法说明</button>
        </div>

        <!-- 游戏区 -->
        <div id="game-area">
            <div id="info-panel">
                <div id="player1-info">P1: 0</div>
                <div id="player2-info">P2: 0</div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="game-canvas"></canvas>
            </div>
        </div>

    </div>

    <!-- 模态框 -->
    <div id="modal-overlay">
        <div id="modal-box" role="dialog" aria-modal="true">
            <h2>玩法说明</h2>
            <p><strong>通用规则:</strong></p>
            <ul>
                <li>控制你的蛇吃掉食物（红色方块）来增长身体。</li>
                <li>撞到墙壁或自己的身体会导致游戏结束。</li>
            </ul>
            <p><strong>单人模式:</strong></p>
            <ul>
                <li>控制: <strong>WASD</strong> 或 <strong>方向键</strong>。</li>
                <li>目标: 挑战最高长度！</li>
            </ul>
            <p><strong>双人对战:</strong></p>
            <ul>
                <li>地图上会同时存在 <strong>2个</strong> 食物。</li>
                <li>玩家1 (绿蛇): 使用 <strong>WASD</strong> 控制（或左侧虚拟按键）。</li>
                <li>玩家2 (蓝蛇): 使用 <strong>方向键</strong> 控制（或右侧虚拟按键）。</li>
                <li>一名玩家死亡后，其身体会变成“尸体”留在场上。</li>
            </ul>
            <div style="text-align:center; margin-top:18px;">
                <button id="close-modal-btn" class="menu-btn">关闭</button>
            </div>
        </div>
    </div>

    <!-- 手机虚拟按键（左右两组） -->
    <div id="mobile-controls" aria-hidden="false">
        <!-- P1 左侧 D-Pad -->
        <div id="p1-controls" class="controls">
            <div class="dpad" data-player="1" aria-label="玩家1 控制">
                <div class="control-row">
                    <button class="control-btn" data-dir="Up" aria-label="上">▲</button>
                </div>
                <div class="control-row">
                    <button class="control-btn" data-dir="Left" aria-label="左">◀</button>
                    <button class="control-btn" data-dir="Down" aria-label="下">▼</button>
                    <button class="control-btn" data-dir="Right" aria-label="右">▶</button>
                </div>
            </div>
        </div>

        <!-- P2 右侧 D-Pad -->
        <div id="p2-controls" class="controls">
            <div class="dpad" data-player="2" aria-label="玩家2 控制">
                <div class="control-row">
                    <button class="control-btn" data-dir="Up" aria-label="上">▲</button>
                </div>
                <div class="control-row">
                    <button class="control-btn" data-dir="Left" aria-label="左">◀</button>
                    <button class="control-btn" data-dir="Down" aria-label="下">▼</button>
                    <button class="control-btn" data-dir="Right" aria-label="右">▶</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ====== DOM 元素 ======
        const menu = document.getElementById('menu');
        const gameArea = document.getElementById('game-area');
        const singlePlayerBtn = document.getElementById('single-player-btn');
        const dualPlayerBtn = document.getElementById('dual-player-btn');
        const howToPlayBtn = document.getElementById('how-to-play-btn');
        const modalOverlay = document.getElementById('modal-overlay');
        const closeModalBtn = document.getElementById('close-modal-btn');

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const player1Info = document.getElementById('player1-info');
        const player2Info = document.getElementById('player2-info');

        const p1ControlsWrap = document.getElementById('p1-controls');
        const p2ControlsWrap = document.getElementById('p2-controls');
        const mobileControls = document.getElementById('mobile-controls');

        // ====== 游戏常量 & 变量 ======
        const GRID_SIZE = 20;
        const GAME_SPEED = 120;
        const SNAKE_COLOR_1 = getComputedStyle(document.documentElement).getPropertyValue('--snake1-color').trim();
        const SNAKE_COLOR_2 = getComputedStyle(document.documentElement).getPropertyValue('--snake2-color').trim();

        const P1_CONTROLS = { 'w':'Up','W':'Up','s':'Down','S':'Down','a':'Left','A':'Left','d':'Right','D':'Right' };
        const P2_CONTROLS = { 'ArrowUp':'Up','ArrowDown':'Down','ArrowLeft':'Left','ArrowRight':'Right' };
        const SINGLE_MODE_CONTROLS = { ...P1_CONTROLS, ...P2_CONTROLS };
        const OPPOSITE_DIRECTIONS = { 'Up':'Down','Down':'Up','Left':'Right','Right':'Left' };

        let gameMode = null;
        let gameInterval = null;
        let isGameOver = false;
        let player1 = {}, player2 = {};
        let foods = [];
        let mobileControlsBound = false;

        // ====== 事件绑定（菜单 / 模态 / 键盘） ======
        singlePlayerBtn.addEventListener('click', () => startGame('single'));
        dualPlayerBtn.addEventListener('click', () => startGame('dual'));
        howToPlayBtn.addEventListener('click', () => modalOverlay.classList.add('visible'));
        closeModalBtn.addEventListener('click', () => modalOverlay.classList.remove('visible'));
        modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) modalOverlay.classList.remove('visible'); });

        document.addEventListener('keydown', handleKeyPress);

        // ====== 启动游戏 ======
        function startGame(mode){
            gameMode = mode;
            isGameOver = false;
            // 切换 UI
            menu.style.display = 'none';
            gameArea.style.display = 'flex';

            // 画布尺寸（逻辑像素） - 保持与原逻辑兼容
            let desiredWidth = (mode === 'dual') ? 840 : 420;
            let desiredHeight = 420;

            // 响应式：如果窗口比默认窄，按窗口宽度缩放画布但保持比例
            const maxWidth = Math.min(desiredWidth, Math.floor(window.innerWidth - 40));
            if (maxWidth < desiredWidth) {
                // 按比例缩放
                const scale = maxWidth / desiredWidth;
                desiredWidth = Math.floor(desiredWidth * scale);
                desiredHeight = Math.floor(desiredHeight * scale);
            }

            // 高 DPI 支持
            const dpr = window.devicePixelRatio || 1;
            canvas.style.width = desiredWidth + 'px';
            canvas.style.height = desiredHeight + 'px';
            canvas.width = desiredWidth * dpr;
            canvas.height = desiredHeight * dpr;
            // 将绘图坐标缩放回 CSS 像素级别，保持 GRID_SIZE 不变
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            // 显示 / 隐藏 info 与控制器
            if (mode === 'single') {
                player2Info.style.display = 'none';
                p2ControlsWrap.classList.add('hidden');
            } else {
                player2Info.style.display = 'block';
                p2ControlsWrap.classList.remove('hidden');
            }

            // 初始化实体
            initPlayers();
            initFood();

            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, GAME_SPEED);

            // 绑定手机控制（仅绑定一次）
            if (!mobileControlsBound) {
                bindMobileControls();
                mobileControlsBound = true;
            }

            draw();
        }

        // ====== 初始化玩家 ======
        function initPlayers(){
            const logicalCanvasWidth = parseInt(canvas.style.width);
            const logicalCanvasHeight = parseInt(canvas.style.height);

            const p1StartX = Math.floor((logicalCanvasWidth / (gameMode === 'dual' ? 4 : 2)) / GRID_SIZE) * GRID_SIZE;
            const p1StartY = Math.floor((logicalCanvasHeight / 2) / GRID_SIZE) * GRID_SIZE;
            player1 = { snake:[{x:p1StartX,y:p1StartY}], direction:'Right', nextDirection:'Right', color:SNAKE_COLOR_1, isAlive:true, hasMoved:false, score:1, controls: (gameMode === 'single')?SINGLE_MODE_CONTROLS:P1_CONTROLS };

            if (gameMode === 'dual') {
                const p2StartX = Math.floor((logicalCanvasWidth * 3/4) / GRID_SIZE) * GRID_SIZE;
                const p2StartY = Math.floor((logicalCanvasHeight / 2) / GRID_SIZE) * GRID_SIZE;
                player2 = { snake:[{x:p2StartX,y:p2StartY}], direction:'Left', nextDirection:'Left', color:SNAKE_COLOR_2, isAlive:true, hasMoved:false, score:1, controls: P2_CONTROLS };
            } else {
                player2 = {};
            }
        }

        // ====== 游戏循环 ======
        function gameLoop(){
            if (isGameOver){ clearInterval(gameInterval); displayGameOver(); return; }
            update();
            draw();
        }

        function update(){
            if (player1.isAlive && player1.hasMoved) updatePlayer(player1, player2);
            if (gameMode === 'dual' && player2.isAlive && player2.hasMoved) updatePlayer(player2, player1);
            if (gameMode === 'dual' && (!player1.isAlive && !player2.isAlive)) isGameOver = true;
        }

        function updatePlayer(player, otherPlayer){
            if (player.nextDirection !== OPPOSITE_DIRECTIONS[player.direction]) player.direction = player.nextDirection;

            const currentHead = player.snake[0];
            const nextHead = { x: currentHead.x, y: currentHead.y };
            switch (player.direction){
                case 'Up': nextHead.y -= GRID_SIZE; break;
                case 'Down': nextHead.y += GRID_SIZE; break;
                case 'Left': nextHead.x -= GRID_SIZE; break;
                case 'Right': nextHead.x += GRID_SIZE; break;
            }

            const logicalWidth = parseInt(canvas.style.width);
            const logicalHeight = parseInt(canvas.style.height);

            // 撞墙
            if (nextHead.x < 0 || nextHead.x >= logicalWidth || nextHead.y < 0 || nextHead.y >= logicalHeight) { killPlayer(player, nextHead); return; }

            // 撞自己
            for (let i = 1; i < player.snake.length; i++){
                if (nextHead.x === player.snake[i].x && nextHead.y === player.snake[i].y){ killPlayer(player, nextHead); return; }
            }

            // 撞敌人活体
            if (gameMode === 'dual' && otherPlayer.isAlive){
                for (const seg of otherPlayer.snake){ if (nextHead.x === seg.x && nextHead.y === seg.y){ killPlayer(player, nextHead); return; } }
            }

            // 吃食物
            const eatenFoodIndex = foods.findIndex(f => nextHead.x === f.x && nextHead.y === f.y);
            if (eatenFoodIndex !== -1){
                player.score++;
                foods.splice(eatenFoodIndex,1);
                foods.push(generateSingleFood());
            } else if (gameMode === 'dual' && !otherPlayer.isAlive && otherPlayer.snake.length > 0) {
                // 碰撞尸体：每撞一节尸体，尸体消失，该玩家分数-1（若为0则死亡）
                for (let i = 0; i < otherPlayer.snake.length; i++){
                    if (nextHead.x === otherPlayer.snake[i].x && nextHead.y === otherPlayer.snake[i].y){
                        otherPlayer.snake.splice(i,1);
                        if (player.score > 1) {
                            player.score--;
                        } else {
                            killPlayer(player, nextHead);
                            return;
                        }
                        break;
                    }
                }
            }

            player.snake.unshift(nextHead);
            while (player.snake.length > player.score) player.snake.pop();
        }

        function killPlayer(player, finalHead){
            player.snake.unshift(finalHead);
            player.isAlive = false;
            if (gameMode === 'single') isGameOver = true;
        }

        // ====== 绘制 ======
        function draw(){
            const w = canvas.width; const h = canvas.height;
            // 因为我们用了 ctx.setTransform(dpr,0,0,dpr,0,0) 来缩放，所以需要用 CSS 像素进行清理
            ctx.clearRect(0,0,parseInt(canvas.style.width), parseInt(canvas.style.height));

            drawSnake(player1);
            if (gameMode === 'dual' && player2.snake) drawSnake(player2);

            // 绘制食物
            foods.forEach(food => {
                ctx.fillStyle = '#F44336'; ctx.strokeStyle = '#D32F2F';
                ctx.fillRect(food.x, food.y, GRID_SIZE, GRID_SIZE);
                ctx.strokeRect(food.x, food.y, GRID_SIZE, GRID_SIZE);
            });

            updateInfoPanel();
        }

        function drawSnake(player){
            if (!player || !player.snake || player.snake.length === 0) return;
            // 头部
            ctx.fillStyle = player.isAlive ? player.color : '#757575';
            ctx.fillRect(player.snake[0].x, player.snake[0].y, GRID_SIZE, GRID_SIZE);
            // 身体
            for (let i = 1; i < player.snake.length; i++){
                ctx.fillStyle = player.isAlive ? adjustColor(player.color, -30) : '#616161';
                ctx.fillRect(player.snake[i].x, player.snake[i].y, GRID_SIZE, GRID_SIZE);
            }
        }

        function updateInfoPanel(){
            player1Info.textContent = player1 && player1.isAlive ? `P1: ${player1.score}` : (player1? `P1-DEAD: ${player1.score}` : 'P1: 0');
            if (gameMode === 'dual' && player2 && player2.snake) {
                player2Info.textContent = player2.isAlive ? `P2: ${player2.score}` : `P2-DEAD: ${player2.score}`;
            }
        }

        // ====== 食物逻辑 ======
        function initFood(){
            foods = [];
            const foodCount = (gameMode === 'dual') ? 2 : 1;
            for (let i = 0; i < foodCount; i++) foods.push(generateSingleFood());
        }

        function generateSingleFood(){
            let foodX, foodY, onSomething;
            const snakes = [player1.snake];
            if (gameMode === 'dual' && player2.snake) snakes.push(player2.snake);

            const logicalWidth = parseInt(canvas.style.width);
            const logicalHeight = parseInt(canvas.style.height);

            do {
                onSomething = false;
                foodX = Math.floor(Math.random()*(logicalWidth/GRID_SIZE))*GRID_SIZE;
                foodY = Math.floor(Math.random()*(logicalHeight/GRID_SIZE))*GRID_SIZE;

                // 在蛇身上?
                for (const s of snakes){
                    for (const seg of s){ if (seg.x === foodX && seg.y === foodY) { onSomething = true; break; } }
                    if (onSomething) break;
                }
                if (onSomething) continue;
                // 在其他食物上?
                for (const f of foods){ if (f.x === foodX && f.y === foodY) { onSomething = true; break; } }
            } while (onSomething);

            return { x: foodX, y: foodY };
        }

        // ====== 游戏结束显示 & 返回菜单 ======
        function displayGameOver(){
            const logicalWidth = parseInt(canvas.style.width);
            const logicalHeight = parseInt(canvas.style.height);

            ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,logicalWidth, logicalHeight);
            ctx.fillStyle='white'; ctx.textAlign='center'; ctx.font='2rem "Press Start 2P"';
            if (gameMode === 'single'){
                ctx.fillText('GAME OVER', logicalWidth/2, logicalHeight/2 - 40);
                ctx.font='1.1rem "Press Start 2P"';
                ctx.fillText(`SCORE: ${player1.score}`, logicalWidth/2, logicalHeight/2 + 20);
            } else {
                ctx.fillText('DUEL OVER', logicalWidth/2, logicalHeight/2 - 80);
                ctx.font='1rem "Press Start 2P"';
                ctx.fillStyle = SNAKE_COLOR_1;
                ctx.fillText(`PLAYER 1: ${player1.score}`, logicalWidth/2, logicalHeight/2 - 30);
                ctx.fillStyle = SNAKE_COLOR_2;
                ctx.fillText(`PLAYER 2: ${player2.score}`, logicalWidth/2, logicalHeight/2 + 10);
                ctx.font='1.2rem "Press Start 2P"'; ctx.fillStyle='white';
                let resultText = 'DRAW!';
                if (player1.score > player2.score) resultText = 'PLAYER 1 WINS!';
                else if (player2.score > player1.score) resultText = 'PLAYER 2 WINS!';
                ctx.fillText(resultText, logicalWidth/2, logicalHeight/2 + 60);
            }
            ctx.font='0.8rem "Press Start 2P"'; ctx.fillStyle='#ccc';
            ctx.fillText('点击屏幕或按任意键返回菜单', logicalWidth/2, logicalHeight - 30);

            // 键盘返回（一次性）
            document.addEventListener('keydown', returnToMenu, { once:true });

            // 触摸 / 鼠标返回（一次性）
            canvas.addEventListener('pointerdown', returnToMenu, { once:true });
        }

        function returnToMenu(){
            // 清理 interval
            if (gameInterval) clearInterval(gameInterval);
            gameArea.style.display = 'none';
            menu.style.display = 'block';
            isGameOver = false;
            // 隐藏右侧 P2 控件（默认）
            p2ControlsWrap.classList.add('hidden');
        }

        // ====== 键盘处理 ======
        function handleKeyPress(event){
            if (isGameOver) return;
            const handlePlayerInput = (p) => {
                if (!p || !p.isAlive || !p.controls[event.key]) return;
                const newDir = p.controls[event.key];
                if (!p.hasMoved){ p.direction = newDir; p.hasMoved = true; }
                p.nextDirection = newDir;
            };
            handlePlayerInput(player1);
            if (gameMode === 'dual') handlePlayerInput(player2);
        }

        // ====== 手机虚拟按键绑定（使用 pointer 事件） ======
        function bindMobileControls(){
            // 所有按钮：使用事件委托更简洁
            mobileControls.addEventListener('pointerdown', onControlPointerDown);
            mobileControls.addEventListener('pointerup', onControlPointerUp);
            mobileControls.addEventListener('pointercancel', onControlPointerUp);
            mobileControls.addEventListener('pointerout', onControlPointerUp);
            mobileControls.addEventListener('pointerleave', onControlPointerUp);

            // 阻止默认拖拽行为（尤其是触摸）
            mobileControls.addEventListener('touchmove', (e) => { /* prevent default only when touching controls */ }, { passive:false });
        }

        // pointerdown 回调
        function onControlPointerDown(e){
            const btn = e.target.closest('.control-btn');
            if (!btn) return;
            e.preventDefault();
            btn.classList.add('pressed');

            // 找到所属玩家（向上寻找 .dpad）
            const dpad = btn.closest('.dpad');
            if (!dpad) return;
            const playerIndex = dpad.getAttribute('data-player') === '2' ? 2 : 1;
            const dir = btn.getAttribute('data-dir');
            if (!dir) return;

            // 设置方向（与键盘处理逻辑一致）
            const p = (playerIndex === 1) ? player1 : player2;
            if (!p || !p.isAlive) return;
            if (!p.hasMoved){ p.direction = dir; p.hasMoved = true; }
            p.nextDirection = dir;
        }

        // pointerup 回调：用于视觉反馈清理
        function onControlPointerUp(e){
            const btn = e.target.closest('.control-btn');
            if (!btn) return;
            btn.classList.remove('pressed');
        }

        // ====== 辅助函数 ======
        function adjustColor(hex, amount){
            // hex like #RRGGBB
            const c = hex.replace('#','');
            let out = '#';
            for (let i = 0; i < 3; i++){
                const part = parseInt(c.substr(i*2,2),16);
                let v = Math.max(0, Math.min(255, part + amount));
                out += ('0' + v.toString(16)).slice(-2);
            }
            return out;
        }

        // ====== 加载时初始化 UI 状态 ======
        function initUIState(){
            // 隐藏控制器（直到游戏开始）
            p1ControlsWrap.classList.add('hidden');
            p2ControlsWrap.classList.add('hidden');

            // 监听游戏开始显示相应控制器
            singlePlayerBtn.addEventListener('click', () => {
                p1ControlsWrap.classList.remove('hidden');
                p2ControlsWrap.classList.add('hidden');
            });
            dualPlayerBtn.addEventListener('click', () => {
                p1ControlsWrap.classList.remove('hidden');
                p2ControlsWrap.classList.remove('hidden');
            });

            // 当返回菜单时隐藏控制器（returnToMenu 中已有）
        }

        initUIState();

        // ====== 监听窗口尺寸变化，若在游戏中则重新调整画布（简单处理） ======
        window.addEventListener('resize', () => {
            if (gameArea.style.display !== 'flex') return;
            // 重新布局：先停止计时器，再重新 startGame 保持当前模式
            if (gameInterval) clearInterval(gameInterval);
            // 记录当前 mode 并重启
            const currentMode = gameMode;
            // 保留分数与状态不做复杂迁移，直接重启游戏（保证控件正常）
            startGame(currentMode);
        });

        // ====== 初始提示：绑定 mobileControls（一次） ======
        bindMobileControls();

        // ====== 防御性备注：防止页面滚动时误触控件导致页面滚动（简易） ======
        // 不在控件上时允许滚动，控件上时 pointerdown 会 preventDefault。
    </script>
</body>
</html>

