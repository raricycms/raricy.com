<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>落子棋盘</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: white;
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            text-align: center;
            background: rgba(0, 0, 0, 0.05);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .current-player {
            color: #333;
            font-size: 24px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .game-status {
            color: #333;
            font-size: 20px;
            font-weight: bold;
            min-height: 30px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .mode-selector {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .mode-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .mode-option input[type="radio"] {
            margin: 0;
        }

        .mode-option label {
            font-size: 16px;
            color: #333;
            cursor: pointer;
        }

        .keyboard-hint {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
        }

        .board-container {
            position: relative;
            display: inline-block;
        }

        .board {
            background: linear-gradient(135deg, #2d5a27, #4a7c59);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 
                inset 0 0 20px rgba(0, 0, 0, 0.3),
                0 10px 30px rgba(0, 0, 0, 0.2);
            display: grid;
            grid-template-columns: repeat(7, 80px);
            grid-template-rows: repeat(4, 80px);
            gap: 8px;
        }

        .cell {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: 
                inset 0 0 10px rgba(0, 0, 0, 0.2),
                0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 
                inset 0 0 10px rgba(0, 0, 0, 0.2),
                0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .cell.winning {
            animation: winningGlow 1s ease-in-out infinite alternate;
        }

        .cell.column-full {
            animation: fullColumnBlink 0.5s ease-in-out;
        }

        @keyframes winningGlow {
            from {
                box-shadow: 
                    inset 0 0 10px rgba(0, 0, 0, 0.2),
                    0 4px 15px rgba(255, 215, 0, 0.8);
            }
            to {
                box-shadow: 
                    inset 0 0 10px rgba(0, 0, 0, 0.2),
                    0 4px 25px rgba(255, 215, 0, 1);
            }
        }

        @keyframes fullColumnBlink {
            0%, 100% { 
                background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
            }
            50% { 
                background: radial-gradient(circle at 30% 30%, #ffcccc, #ffaaaa);
            }
        }

        .piece {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            position: absolute;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #e74c3c, #c0392b);
            border: 2px solid #a93226;
        }

        .piece.blue {
            background: radial-gradient(circle at 30% 30%, #74b9ff, #3498db, #2980b9);
            border: 2px solid #1f4e79;
        }

        .piece.obstacle {
            background: 
                radial-gradient(circle at 30% 30%, #d4a574, #b8956a, #8b6914),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 105, 20, 0.1) 2px,
                    rgba(139, 105, 20, 0.1) 4px
                );
            border: 2px solid #654321;
        }

        .piece.fade-out {
            opacity: 0;
            transform: scale(0.8);
        }

        .piece.blind-fade {
            animation: blindFadeOut 0.6s ease-out forwards;
        }

        .piece.blind2-fade {
            animation: blind2FadeOut 0.8s ease-out forwards;
        }

        .piece.blind2-invisible {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        @keyframes blindFadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes blind2FadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        .falling-piece {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }

        .falling-piece.red {
            background: radial-gradient(circle at 30% 30%, #ff6b6b, #e74c3c, #c0392b);
            border: 2px solid #a93226;
        }

        .falling-piece.blue {
            background: radial-gradient(circle at 30% 30%, #74b9ff, #3498db, #2980b9);
            border: 2px solid #1f4e79;
        }

        .falling-piece.obstacle {
            background: 
                radial-gradient(circle at 30% 30%, #d4a574, #b8956a, #8b6914),
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 2px,
                    rgba(139, 105, 20, 0.1) 2px,
                    rgba(139, 105, 20, 0.1) 4px
                );
            border: 2px solid #654321;
        }

        .falling-piece.blind2-fade-falling {
            animation: blind2FallAndFade 0.5s ease-out forwards;
        }

        @keyframes blind2FallAndFade {
            0% { 
                opacity: 1; 
            }
            70% { 
                opacity: 0.2; 
            }
            100% { 
                opacity: 0; 
            }
        }

        .btn {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }

        .reset-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .undo-btn {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .winner-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 25px 35px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            text-align: center;
            font-size: 22px;
            font-weight: bold;
            display: none;
            border: 3px solid #ffd700;
        }

        .winner-announcement.show {
            display: block;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .column-numbers {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            padding: 0 15px;
        }

        .column-number {
            width: 80px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #2d5a27;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
        }

        .obstacle-phase {
            color: #8b6914;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="winner-announcement" id="winner-announcement">
            <div id="winner-text"></div>
            <button class="btn reset-btn" onclick="resetGame()" style="margin-top: 15px; font-size: 14px; padding: 8px 16px;">再来一局</button>
        </div>

        <div class="mode-selector">
            <div class="mode-option">
                <input type="radio" id="normal-mode" name="game-mode" value="normal" checked>
                <label for="normal-mode">普通模式</label>
            </div>
            <div class="mode-option">
                <input type="radio" id="obstacle-mode" name="game-mode" value="obstacle">
                <label for="obstacle-mode">障碍模式</label>
            </div>
            <div class="mode-option">
                <input type="radio" id="blind-mode" name="game-mode" value="blind">
                <label for="blind-mode">盲棋模式</label>
            </div>
            <div class="mode-option">
                <input type="radio" id="blind2-mode" name="game-mode" value="blind2">
                <label for="blind2-mode">盲棋模式2</label>
            </div>
        </div>

        <div class="game-info">
            <div class="current-player">
                当前玩家: <span id="current-player-color">红色</span>
            </div>
            <div class="game-status" id="game-status"></div>
            <div class="controls">
                <button class="btn undo-btn" id="undo-btn" onclick="undoMove()">悔棋</button>
                <button class="btn reset-btn" onclick="resetGame()">重新开始</button>
            </div>
        </div>
        
        <div class="obstacle-phase" id="obstacle-phase" style="display: none;"></div>
        <div class="keyboard-hint">按数字键 1-7 可在对应列落子</div>
        
        <div class="board-container">
            <div class="column-numbers">
                <div class="column-number">1</div>
                <div class="column-number">2</div>
                <div class="column-number">3</div>
                <div class="column-number">4</div>
                <div class="column-number">5</div>
                <div class="column-number">6</div>
                <div class="column-number">7</div>
            </div>
            <div class="board" id="board"></div>
        </div>
    </div>

    <script>
        const ROWS = 4;
        const COLS = 7;
        let currentPlayer = 'red';
        let board = [];
        let columnHeights = [];
        let isDropping = false;
        let gameOver = false;
        let moveHistory = [];
        let gameMode = 'normal';
        let obstaclePhase = false;
        let obstaclesPlaced = 0;

        function initGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            columnHeights = Array(COLS).fill(0);
            currentPlayer = 'red';
            isDropping = false;
            gameOver = false;
            moveHistory = [];
            
            // 获取当前选择的游戏模式
            gameMode = document.querySelector('input[name="game-mode"]:checked').value;
            obstaclePhase = gameMode === 'obstacle';
            obstaclesPlaced = 0;
            
            updateCurrentPlayerDisplay();
            updateUndoButton();
            updateGameStatus('');
            updateObstaclePhase();
            hideWinnerAnnouncement();
            createBoard();
        }

        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.onclick = () => dropPiece(col);
                    boardElement.appendChild(cell);
                }
            }
        }

        function dropPiece(col) {
            if (isDropping || gameOver) {
                return;
            }

            // 检查列是否已满
            if (columnHeights[col] >= ROWS) {
                highlightFullColumn(col);
                return;
            }

            isDropping = true;
            const targetRow = ROWS - 1 - columnHeights[col];
            
            // 确定要放置的棋子类型
            let pieceType;
            if (obstaclePhase) {
                pieceType = 'obstacle';
            } else {
                pieceType = currentPlayer;
            }
            
            moveHistory.push({
                board: board.map(row => [...row]),
                columnHeights: [...columnHeights],
                currentPlayer: currentPlayer,
                obstaclePhase: obstaclePhase,
                obstaclesPlaced: obstaclesPlaced,
                row: targetRow,
                col: col
            });
            
            // 创建下落动画
            createFallingAnimation(col, targetRow, pieceType);
            
            board[targetRow][col] = pieceType;
            columnHeights[col]++;
            
            setTimeout(() => {
                // 根据模式决定如何放置棋子
                let placedPiece;
                if (gameMode === 'blind2' && pieceType !== 'obstacle') {
                    // 盲棋模式2：直接放置隐形棋子
                    placedPiece = placePieceInvisible(targetRow, col, pieceType);
                } else {
                    // 其他模式：正常放置棋子
                    placedPiece = placePiece(targetRow, col, pieceType);
                    
                    // 盲棋模式1：棋子放置后开始淡出
                    if (gameMode === 'blind' && pieceType !== 'obstacle') {
                        setTimeout(() => {
                            if (placedPiece && placedPiece.parentNode) {
                                placedPiece.classList.add('blind-fade');
                            }
                        }, 200);
                    }
                }
                
                handleMoveCompletion(targetRow, col, pieceType);
            }, 500);
        }

        function handleMoveCompletion(targetRow, col, pieceType) {
            if (obstaclePhase) {
                obstaclesPlaced++;
                if (obstaclesPlaced >= 2) {
                    obstaclePhase = false;
                    currentPlayer = 'red'; // 障碍放置完毕后，红色先手
                }
                updateObstaclePhase();
            } else {
                // 正常游戏阶段
                const winResult = checkWin(targetRow, col, currentPlayer);
                if (winResult.isWin) {
                    gameOver = true;
                    
                    // 盲棋模式下，胜利时显示所有棋子
                    if (gameMode === 'blind' || gameMode === 'blind2') {
                        showAllPieces();
                    }
                    
                    highlightWinningPieces(winResult.winningPieces);
                    showWinnerAnnouncement(`${currentPlayer === 'red' ? '红色' : '蓝色'}玩家获胜！`);
                } else if (checkDraw()) {
                    gameOver = true;
                    
                    // 平局时也显示所有棋子
                    if (gameMode === 'blind' || gameMode === 'blind2') {
                        showAllPieces();
                    }
                    
                    showWinnerAnnouncement('平局！');
                } else {
                    currentPlayer = currentPlayer === 'red' ? 'blue' : 'red';
                }
            }
            
            updateCurrentPlayerDisplay();
            updateUndoButton();
            isDropping = false;
        }

        function checkWin(row, col, player) {
            // 障碍棋子不参与获胜判断
            if (player === 'obstacle') {
                return { isWin: false, winningPieces: [] };
            }

            const directions = [
                [0, 1],   // 水平
                [1, 0],   // 垂直
                [1, 1],   // 对角线 \
                [1, -1]   // 对角线 /
            ];

            for (let [dr, dc] of directions) {
                const winningPieces = [];
                
                for (let direction = -1; direction <= 1; direction += 2) {
                    let r = row;
                    let c = col;
                    
                    while (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] === player) {
                        winningPieces.push([r, c]);
                        r += dr * direction;
                        c += dc * direction;
                    }
                }
                
                const uniquePieces = Array.from(new Set(winningPieces.map(p => p.join(',')))).map(p => p.split(',').map(Number));
                
                if (uniquePieces.length >= 4) {
                    return { isWin: true, winningPieces: uniquePieces };
                }
            }
            
            return { isWin: false, winningPieces: [] };
        }

        function checkDraw() {
            return columnHeights.every(height => height >= ROWS);
        }

        function showAllPieces() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const piece = cell.querySelector('.piece');
                if (piece) {
                    piece.style.opacity = '1';
                    piece.style.visibility = 'visible';
                    piece.classList.remove('blind-fade', 'blind2-fade', 'blind2-invisible');
                    // 停止所有动画
                    piece.style.animation = 'none';
                }
            });
        }

        function highlightWinningPieces(winningPieces) {
            const cells = document.querySelectorAll('.cell');
            winningPieces.forEach(([row, col]) => {
                const cellIndex = row * COLS + col;
                cells[cellIndex].classList.add('winning');
            });
        }

        function highlightFullColumn(col) {
            const cells = document.querySelectorAll('.cell');
            for (let row = 0; row < ROWS; row++) {
                const cellIndex = row * COLS + col;
                cells[cellIndex].classList.add('column-full');
            }
            
            setTimeout(() => {
                for (let row = 0; row < ROWS; row++) {
                    const cellIndex = row * COLS + col;
                    cells[cellIndex].classList.remove('column-full');
                }
            }, 500);
        }

        function undoMove() {
            // 盲棋模式不能悔棋
            if (gameMode === 'blind' || gameMode === 'blind2') {
                return;
            }

            if (moveHistory.length === 0 || isDropping) {
                return;
            }

            const lastMove = moveHistory.pop();
            const { row, col } = lastMove;
            
            // 找到要移除的棋子并添加淡出动画
            const cells = document.querySelectorAll('.cell');
            const targetCell = cells[row * COLS + col];
            const piece = targetCell.querySelector('.piece');
            
            if (piece) {
                piece.classList.add('fade-out');
                
                // 等待淡出动画完成后恢复状态
                setTimeout(() => {
                    // 恢复棋盘状态
                    board = lastMove.board;
                    columnHeights = lastMove.columnHeights;
                    currentPlayer = lastMove.currentPlayer;
                    obstaclePhase = lastMove.obstaclePhase;
                    obstaclesPlaced = lastMove.obstaclesPlaced;
                    gameOver = false;
                    
                    // 清空棋盘并重新放置所有棋子
                    const allCells = document.querySelectorAll('.cell');
                    allCells.forEach(cell => {
                        cell.innerHTML = '';
                        cell.classList.remove('winning');
                    });
                    
                    // 重新放置所有棋子（不包括刚移除的那个）
                    for (let r = 0; r < ROWS; r++) {
                        for (let c = 0; c < COLS; c++) {
                            if (board[r][c]) {
                                const placedPiece = placePieceDirectly(r, c, board[r][c]);
                                
                                // 盲棋模式下，悔棋后重新放置的棋子也要淡出（除了障碍棋子）
                                if (gameMode === 'blind' && board[r][c] !== 'obstacle') {
                                    placedPiece.classList.add('blind-fade');
                                } else if (gameMode === 'blind2' && board[r][c] !== 'obstacle') {
                                    placedPiece.classList.add('blind2-invisible');
                                }
                            }
                        }
                    }
                    
                    updateCurrentPlayerDisplay();
                    updateUndoButton();
                    updateGameStatus('');
                    updateObstaclePhase();
                    hideWinnerAnnouncement();
                }, 200);
            }
        }

        function createFallingAnimation(col, targetRow, pieceType) {
            // 确保board-container存在
            const boardContainer = document.querySelector('.board-container');
            if (!boardContainer) {
                console.error('Board container not found');
                return;
            }

            const fallingPiece = document.createElement('div');
            fallingPiece.className = `falling-piece ${pieceType}`;
            
            const cellSize = 80;
            const gap = 8;
            const padding = 15;
            const pieceOffset = 5;
            
            const startX = padding + col * (cellSize + gap) + pieceOffset;
            const startY = -80;
            
            // 盲棋模式2：所有棋子都下落到最底行的位置
            let endY;
            if (gameMode === 'blind2' && pieceType !== 'obstacle') {
                // 统一下落到最底行（第3行，索引为3）
                endY = padding + 3 * (cellSize + gap) + pieceOffset + 30;
            } else {
                // 其他模式：下落到实际目标位置
                endY = padding + targetRow * (cellSize + gap) + pieceOffset + 30;
            }
            
            fallingPiece.style.left = startX + 'px';
            fallingPiece.style.top = startY + 'px';
            fallingPiece.style.transition = 'none';
            
            // 盲棋模式2：下落过程中就开始淡出
            if (gameMode === 'blind2' && pieceType !== 'obstacle') {
                fallingPiece.classList.add('blind2-fade-falling');
            }
            
            boardContainer.appendChild(fallingPiece);
            
            // 使用setTimeout而不是requestAnimationFrame确保动画触发
            setTimeout(() => {
                fallingPiece.style.transition = 'top 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                fallingPiece.style.top = endY + 'px';
            }, 10);
            
            setTimeout(() => {
                if (boardContainer.contains(fallingPiece)) {
                    boardContainer.removeChild(fallingPiece);
                }
            }, 600);
        }

        function placePiece(row, col, pieceType) {
            const cells = document.querySelectorAll('.cell');
            const targetCell = cells[row * COLS + col];
            
            const piece = document.createElement('div');
            piece.className = `piece ${pieceType}`;
            
            piece.style.transform = 'scale(0.8)';
            setTimeout(() => {
                piece.style.transform = 'scale(1)';
            }, 50);
            
            targetCell.appendChild(piece);
            
            return piece;
        }

        function placePieceInvisible(row, col, pieceType) {
            const cells = document.querySelectorAll('.cell');
            const targetCell = cells[row * COLS + col];
            
            const piece = document.createElement('div');
            piece.className = `piece ${pieceType} blind2-invisible`;
            
            targetCell.appendChild(piece);
            
            return piece;
        }

        function placePieceDirectly(row, col, pieceType) {
            const cells = document.querySelectorAll('.cell');
            const targetCell = cells[row * COLS + col];
            
            const piece = document.createElement('div');
            piece.className = `piece ${pieceType}`;
            
            targetCell.appendChild(piece);
            
            return piece;
        }

        function updateCurrentPlayerDisplay() {
            const playerDisplay = document.getElementById('current-player-color');
            if (obstaclePhase) {
                playerDisplay.textContent = '放置障碍';
                playerDisplay.style.color = '#8b6914';
            } else {
                playerDisplay.textContent = currentPlayer === 'red' ? '红色' : '蓝色';
                playerDisplay.style.color = currentPlayer === 'red' ? '#ff6b6b' : '#74b9ff';
            }
        }

        function updateObstaclePhase() {
            const obstaclePhaseElement = document.getElementById('obstacle-phase');
            if (gameMode === 'obstacle' && obstaclePhase) {
                obstaclePhaseElement.style.display = 'block';
                obstaclePhaseElement.textContent = `障碍放置阶段 (${obstaclesPlaced}/2)`;
            } else {
                obstaclePhaseElement.style.display = 'none';
            }
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undo-btn');
            // 盲棋模式下禁用悔棋按钮
            if (gameMode === 'blind' || gameMode === 'blind2') {
                undoBtn.disabled = true;
            } else {
                undoBtn.disabled = moveHistory.length === 0;
            }
        }

        function updateGameStatus(message) {
            document.getElementById('game-status').textContent = message;
        }

        function showWinnerAnnouncement(message) {
            document.getElementById('winner-text').textContent = message;
            const announcement = document.getElementById('winner-announcement');
            announcement.classList.add('show');
        }

        function hideWinnerAnnouncement() {
            const announcement = document.getElementById('winner-announcement');
            announcement.classList.remove('show');
        }

        function resetGame() {
            initGame();
        }

        // 模式切换监听
        function setupModeChangeListeners() {
            const modeRadios = document.querySelectorAll('input[name="game-mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    // 切换模式时立即开始新的一局
                    initGame();
                });
            });
        }

        // 键盘事件监听
        document.addEventListener('keydown', function(event) {
            const key = event.key;
            if (key >= '1' && key <= '7') {
                const col = parseInt(key) - 1;
                dropPiece(col);
                event.preventDefault();
            }
        });

        // 页面加载完成后初始化
        window.addEventListener('load', function() {
            document.body.setAttribute('tabindex', '0');
            document.body.focus();
            setupModeChangeListeners();
            initGame();
        });
    </script>
</body>
</html>
