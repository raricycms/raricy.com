<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è‡ªåŠ¨å°„å‡»æ‰“æ€ªæ¸¸æˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #16213e, #0f3460);
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        #expBar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            margin-top: 5px;
        }
        
        #expFill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        
        #pauseBtn {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #4CAF50;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
        }
        
        #pauseBtn:hover {
            background: #4CAF50;
        }
        
        #gameGuide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        
        #guideContent {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #4CAF50;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
        }
        
        .guide-section {
            margin: 20px 0;
            text-align: left;
        }
        
        .enemy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .enemy-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .enemy-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
        
        #startGameBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #bossWarning {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            z-index: 250;
            display: none;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        #bossUI {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        #bossHealthBar {
            width: 400px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            margin: 10px 0;
        }
        
        #bossHealthFill {
            height: 100%;
            background: linear-gradient(90deg, #F44336, #FF5722);
            width: 100%;
            transition: width 0.3s;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        #gameOverContent {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #F44336;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        #gameOverContent h1 {
            color: #F44336;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #gameOverContent.perfect h1 {
            color: #FFD700;
            background: linear-gradient(45deg, #FFD700, #FFA000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #gameOverContent p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        #restartBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        #skillModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #4CAF50;
            display: none;
            z-index: 200;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #skillGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .skill-option {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #333;
            border: 2px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
        }
        
        .skill-option:hover {
            background: #4CAF50;
            border-color: #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .skill-option.max-level {
            background: linear-gradient(45deg, #FFD700, #FFA000);
            border-color: #FFD700;
            color: #000;
        }
        
        .skill-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .skill-info {
            flex: 1;
        }
        
        .skill-level {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            opacity: 0.8;
        }
        
        #skillsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-width: 200px;
        }
        
        .active-skill {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .active-skill .skill-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            font-size: 12px;
        }
        
        #buffs {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
        }
        
        .buff-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .perfect-ending {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #FFD700, #FFA000);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            z-index: 400;
            display: none;
        }

        /* Mobile joystick */
        #joystick {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 140px;
            height: 140px;
            z-index: 200;
            touch-action: none;
            display: none;
        }
        #joystick-base {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.4);
        }
        #joystick-thumb {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid #4CAF50;
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameGuide">
            <div id="guideContent">
                <h1>ğŸ® è‡ªåŠ¨å°„å‡»æ‰“æ€ªæ¸¸æˆ ğŸ®</h1>
                
                <div class="guide-section">
                    <h2>ğŸ¯ æ¸¸æˆç›®æ ‡</h2>
                    <p>æ§åˆ¶è§’è‰²è‡ªåŠ¨å°„å‡»æ•Œäººï¼Œæ”¶é›†ç»éªŒå‡çº§æŠ€èƒ½ï¼Œå‡»è´¥Bossï¼Œå°½å¯èƒ½å­˜æ´»æ›´é•¿æ—¶é—´ï¼</p>
                </div>
                
                <div class="guide-section">
                    <h2>ğŸ® æ“ä½œæ–¹å¼</h2>
                    <p>â€¢ WASD æˆ– æ–¹å‘é”®ï¼šç§»åŠ¨è§’è‰²</p>
                    <p>â€¢ è‡ªåŠ¨å°„å‡»æœ€è¿‘çš„æ•Œäºº</p>
                    <p>â€¢ é è¿‘ç»éªŒçƒå’Œé“å…·è‡ªåŠ¨æ‹¾å–</p>
                    <p>â€¢ ç©ºæ ¼é”®ï¼šæš‚åœ/ç»§ç»­æ¸¸æˆ</p>
                </div>
                
                <div class="guide-section">
                    <h2>ğŸ‘¾ æ•Œäººå›¾é‰´</h2>
                    <div class="enemy-grid">
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #F44336;">ğŸ”´</div>
                            <h4>åŸºç¡€æ•Œäºº</h4>
                            <p>æœ€å¸¸è§çš„æ•Œäººï¼Œè¡€é‡é€‚ä¸­ï¼Œè¿‘æˆ˜æ”»å‡»</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #795548;">ğŸ›¡ï¸</div>
                            <h4>é‡è£…å…µ</h4>
                            <p>è¡€é‡å¾ˆé«˜ï¼Œç§»åŠ¨ç¼“æ…¢ï¼Œé«˜ä¼¤å®³</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #9C27B0;">ğŸ”«</div>
                            <h4>æªæ‰‹</h4>
                            <p>è¿œç¨‹å°„å‡»ï¼Œä¸­ç­‰è¡€é‡å’Œé€Ÿåº¦</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #FF9800;">âš¡</div>
                            <h4>å¿«é€Ÿå…µ</h4>
                            <p>ç§»åŠ¨å¾ˆå¿«ï¼Œè¡€é‡è¾ƒä½</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #607D8B;">ğŸ¯</div>
                            <h4>ç‹™å‡»æ‰‹</h4>
                            <p>è¶…è¿œç¨‹é«˜ä¼¤å®³å°„å‡»</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #E91E63;">ğŸ’¥</div>
                            <h4>çˆ†ç ´å…µ</h4>
                            <p>æ­»äº¡æ—¶çˆ†ç‚¸ï¼Œä¼¤å®³å‘¨å›´æ•Œäºº</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #3F51B5;">ğŸ›¡ï¸</div>
                            <h4>æŠ¤ç›¾å…µ</h4>
                            <p>æ‹¥æœ‰æŠ¤ç›¾ï¼Œæ›´éš¾å‡»æ€</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #4CAF50;">â¤ï¸</div>
                            <h4>æ²»ç–—å…µ</h4>
                            <p>å¯ä»¥æ²»ç–—å…¶ä»–æ•Œäºº</p>
                        </div>
                    </div>
                </div>
                
                <div class="guide-section">
                    <h2>ğŸ† Bossæˆ˜</h2>
                    <p>æ¯3åˆ†é’Ÿä¼šå‡ºç°å¼ºå¤§çš„Bossï¼Œå‡»è´¥åè·å¾—æŠ€èƒ½å‡çº§æœºä¼šï¼</p>
                    <p>Bossä¼šè¢«å›°åœ¨çº¢è‰²ç«æŠ€åœºå†…ï¼Œä½¿ç”¨å„ç§ç‰¹æ®ŠæŠ€èƒ½æ”»å‡»ã€‚</p>
                </div>
                
                <div class="guide-section">
                    <h2>ğŸ’ é“å…·ç³»ç»Ÿ</h2>
                    <p>ğŸ”µ è“è‰²ç»éªŒçƒï¼šæ™®é€šç»éªŒå€¼</p>
                    <p>ğŸŸ¡ é»„è‰²ç»éªŒçƒï¼šå¤§é‡ç»éªŒå€¼</p>
                    <p>ğŸ§² ç£é“ï¼šå¢åŠ æ‹¾å–èŒƒå›´10ç§’</p>
                    <p>â¤ï¸ è¡€åŒ…ï¼šæ¢å¤30ç‚¹ç”Ÿå‘½å€¼</p>
                </div>
                
                <div class="guide-section">
                    <h2>âš¡ æŠ€èƒ½ç³»ç»Ÿ</h2>
                    <p>å‡çº§æ—¶å¯é€‰æ‹©3ä¸ªæŠ€èƒ½ä¹‹ä¸€è¿›è¡Œå¼ºåŒ–ï¼Œæ¯ä¸ªæŠ€èƒ½æœ€é«˜5çº§ã€‚</p>
                    <p>æ‰€æœ‰æŠ€èƒ½è¾¾åˆ°æ»¡çº§æ—¶è§¦å‘å®Œç¾ç»“å±€ï¼</p>
                </div>
                
                <button id="startGameBtn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
            </div>
        </div>
        
        <button id="pauseBtn" onclick="togglePause()" style="display: none;">æš‚åœ</button>
        
        <div id="ui" style="display: none;">
            <div>ç­‰çº§: <span id="level">1</span></div>
            <div>ç”Ÿå‘½å€¼: <span id="health">100</span></div>
            <div>å‡»æ€æ•°: <span id="kills">0</span></div>
            <div>æ³¢æ¬¡: <span id="wave">1</span></div>
            <div>å­˜æ´»æ—¶é—´: <span id="survivalTime">0:00</span></div>
            <div>ä¸‹ä¸ªBoss: <span id="nextBoss">3:00</span></div>
            <div id="expBar">
                <div id="expFill"></div>
            </div>
            <div>ç»éªŒ: <span id="exp">0</span>/<span id="maxExp">100</span></div>
        </div>
        
        <div id="bossWarning">
            <h2>âš ï¸ BOSSæ¥è¢­ï¼ âš ï¸</h2>
            <p>å‡†å¤‡æˆ˜æ–—ï¼</p>
        </div>
        
        <div id="bossUI">
            <h3 id="bossName">Bossåç§°</h3>
            <div id="bossHealthBar">
                <div id="bossHealthFill"></div>
            </div>
            <div>Bossè¡€é‡: <span id="bossHealth">1000</span>/<span id="bossMaxHealth">1000</span></div>
        </div>
        
        <div id="skillsDisplay" style="display: none;">
            <h4>å½“å‰æŠ€èƒ½</h4>
            <div id="activeSkillsList"></div>
        </div>
        
        <div id="buffs" style="display: none;">
            <h4>å¢ç›Šæ•ˆæœ</h4>
            <div id="buffsList"></div>
        </div>
        
        <div id="gameOverScreen">
            <div id="gameOverContent">
                <h1>æ¸¸æˆç»“æŸ</h1>
                <p>å‡»æ€æ•°: <span id="finalKills">0</span></p>
                <p>å­˜æ´»æ—¶é—´: <span id="finalTime">0:00</span></p>
                <p>è¾¾åˆ°æ³¢æ¬¡: <span id="finalWave">1</span></p>
                <p>æœ€é«˜ç­‰çº§: <span id="finalLevel">1</span></p>
                <p>å‡»è´¥Bossæ•°: <span id="finalBosses">0</span></p>
                <button id="restartBtn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
            </div>
        </div>
        
        <div id="perfectEnding" class="perfect-ending">
            <h1>ğŸ† åå…¨åç¾ ğŸ†</h1>
            <p>æ­å–œä½ ï¼æ‰€æœ‰æŠ€èƒ½éƒ½å·²å‡çº§åˆ°æ»¡çº§ï¼</p>
            <p>ä½ å·²ç»è¾¾åˆ°äº†å®Œç¾çš„å¢ƒç•Œï¼</p>
            <button onclick="restartGame()" style="background: #4CAF50; color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; margin-top: 20px;">é‡æ–°æŒ‘æˆ˜</button>
        </div>
        
        <div id="skillModal">
            <h3>é€‰æ‹©æŠ€èƒ½å‡çº§ï¼</h3>
            <div id="skillGrid"></div>
        </div>
        
        <div id="controls" style="display: none;">
            <div>WASD æˆ– æ–¹å‘é”®ç§»åŠ¨</div>
            <div>è‡ªåŠ¨å°„å‡»æœ€è¿‘çš„æ•Œäºº</div>
            <div>é è¿‘ç»éªŒçƒè‡ªåŠ¨è·å–</div>
            <div>ç©ºæ ¼é”®æš‚åœ</div>
        </div>

        <!-- Mobile joystick (shown only on touch devices) -->
        <div id="joystick">
            <div id="joystick-base"></div>
            <div id="joystick-thumb"></div>
        </div>
    </div>

    <script>
        // æ¸¸æˆå˜é‡
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const world = { x: 0, y: 0 };

        // è§¦å±æ£€æµ‹ä¸æ‘‡æ†çŠ¶æ€
        const isTouchDevice = () => ('ontouchstart' in window) || (navigator.maxTouchPoints || 0) > 0 || (navigator.msMaxTouchPoints || 0) > 0;
        const joystick = {
            active: false,
            dx: 0,
            dy: 0,
            magnitude: 0,
            pointerId: null,
            el: null,
            thumbEl: null,
            rect: null
        };

        function setupJoystick() {
            if (joystick.el && joystick.thumbEl) return; // already set
            joystick.el = document.getElementById('joystick');
            joystick.thumbEl = document.getElementById('joystick-thumb');
            if (!joystick.el || !joystick.thumbEl) return;

            const onPointerDown = (e) => {
                (e.preventDefault && e.preventDefault());
                joystick.active = true;
                joystick.pointerId = (e.pointerId !== undefined) ? e.pointerId : 'touch';
                joystick.rect = joystick.el.getBoundingClientRect();
                updateJoystickFromEvent(e);
            };

            const onPointerMove = (e) => {
                if (!joystick.active) return;
                if (e.pointerId !== undefined && joystick.pointerId !== null && e.pointerId !== joystick.pointerId) return;
                (e.preventDefault && e.preventDefault());
                updateJoystickFromEvent(e);
            };

            const onPointerUp = (e) => {
                if (e && e.pointerId !== undefined && joystick.pointerId !== null && e.pointerId !== joystick.pointerId) return;
                resetJoystick();
            };

            if (window.PointerEvent) {
                joystick.el.addEventListener('pointerdown', onPointerDown, { passive: false });
                window.addEventListener('pointermove', onPointerMove, { passive: false });
                window.addEventListener('pointerup', onPointerUp, { passive: true });
                window.addEventListener('pointercancel', onPointerUp, { passive: true });
            } else {
                joystick.el.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]), { passive: false });
                window.addEventListener('touchmove', (e) => onPointerMove(e.touches[0]), { passive: false });
                window.addEventListener('touchend', onPointerUp, { passive: true });
                window.addEventListener('touchcancel', onPointerUp, { passive: true });
            }
        }

        function updateJoystickFromEvent(e) {
            if (!joystick.el) return;
            if (!joystick.rect) joystick.rect = joystick.el.getBoundingClientRect();
            const cx = joystick.rect.left + joystick.rect.width / 2;
            const cy = joystick.rect.top + joystick.rect.height / 2;
            const clientX = e.clientX !== undefined ? e.clientX : 0;
            const clientY = e.clientY !== undefined ? e.clientY : 0;
            const x = clientX - cx;
            const y = clientY - cy;
            const r = joystick.rect.width / 2;
            const len = Math.sqrt(x * x + y * y);
            const clampedLen = Math.min(len, r);
            const nx = len > 0 ? (x / len) : 0;
            const ny = len > 0 ? (y / len) : 0;

            joystick.dx = nx;
            joystick.dy = ny;
            joystick.magnitude = clampedLen / r;

            const offsetX = nx * clampedLen * 0.9;
            const offsetY = ny * clampedLen * 0.9;
            joystick.thumbEl.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px)`;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.pointerId = null;
            joystick.dx = 0;
            joystick.dy = 0;
            joystick.magnitude = 0;
            if (joystick.thumbEl) {
                joystick.thumbEl.style.transform = 'translate(-50%, -50%)';
            }
        }
        
        // æ¸¸æˆçŠ¶æ€æ ‡è®°
        let gameStarted = false;
        let isRestart = false;
        
        // æ•Œäººç±»å‹å®šä¹‰
        const enemyTypes = {
            basic: {
                name: "åŸºç¡€æ•Œäºº",
                health: 30,
                speed: 1.5,
                size: 18,
                color: "#F44336",
                damage: 1,
                shootInterval: 0,
                expReward: 15
            },
            tank: {
                name: "é‡è£…å…µ",
                health: 120,
                speed: 0.8,
                size: 28,
                color: "#795548",
                damage: 3,
                shootInterval: 0,
                expReward: 40
            },
            gunner: {
                name: "æªæ‰‹",
                health: 50,
                speed: 1.2,
                size: 20,
                color: "#9C27B0",
                damage: 2,
                shootInterval: 2500,
                expReward: 25
            },
            fast: {
                name: "å¿«é€Ÿå…µ",
                health: 20,
                speed: 2.5,
                size: 15,
                color: "#FF9800",
                damage: 1,
                shootInterval: 0,
                expReward: 12
            },
            sniper: {
                name: "ç‹™å‡»æ‰‹",
                health: 40,
                speed: 0.6,
                size: 16,
                color: "#607D8B",
                damage: 4,
                shootInterval: 3000,
                expReward: 35
            },
            bomber: {
                name: "çˆ†ç ´å…µ",
                health: 60,
                speed: 1.0,
                size: 22,
                color: "#E91E63",
                damage: 5,
                shootInterval: 0,
                expReward: 30,
                explodeOnDeath: true
            },
            shield: {
                name: "æŠ¤ç›¾å…µ",
                health: 80,
                speed: 1.3,
                size: 20,
                color: "#3F51B5",
                damage: 2,
                shootInterval: 0,
                expReward: 28,
                hasShield: true
            },
            healer: {
                name: "æ²»ç–—å…µ",
                health: 35,
                speed: 1.1,
                size: 17,
                color: "#4CAF50",
                damage: 1,
                shootInterval: 0,
                expReward: 32,
                healOthers: true
            }
        };
        
        // Bosså®šä¹‰ - ä¿®æ­£è¡€é‡é€’å¢
        const bossTypes = {
            destroyer: {
                name: "æ¯ç­è€…",
                health: 1000,
                speed: 1.0,
                size: 50,
                color: "#8E24AA",
                damage: 5,
                shootInterval: 1000,
                expReward: 500,
                abilities: ['shoot', 'summon']
            },
            colossus: {
                name: "å·¨åƒ",
                health: 2000, // ä»1800æå‡åˆ°2000
                speed: 0.8,
                size: 60,
                color: "#FF5722",
                damage: 8,
                shootInterval: 800,
                expReward: 750,
                abilities: ['shoot', 'charge', 'summon']
            },
            overlord: {
                name: "éœ¸ä¸»",
                health: 3200, // ä»2800æå‡åˆ°3200
                speed: 1.2,
                size: 55,
                color: "#3F51B5",
                damage: 10,
                shootInterval: 600,
                expReward: 1000,
                abilities: ['multishot', 'summon', 'teleport']
            },
            nightmare: {
                name: "æ¢¦é­‡",
                health: 4600, // ä»4000æå‡åˆ°4600
                speed: 1.4,
                size: 65,
                color: "#000000",
                damage: 12,
                shootInterval: 500,
                expReward: 1500,
                abilities: ['multishot', 'summon', 'teleport', 'charge']
            },
            apocalypse: {
                name: "æœ«æ—¥ä½¿è€…",
                health: 6200, // ä»6000æå‡åˆ°6200
                speed: 1.6,
                size: 70,
                color: "#B71C1C",
                damage: 15,
                shootInterval: 400,
                expReward: 2000,
                abilities: ['multishot', 'summon', 'teleport', 'charge', 'heal']
            }
        };
        
        // æŠ€èƒ½å®šä¹‰
        const skillDefinitions = {
            damage: {
                name: "å¢å¼ºæ”»å‡»",
                icon: "âš”ï¸",
                color: "#F44336",
                maxLevel: 5,
                description: (level) => level === 5 ? `å­å¼¹ä¼¤å®³ +100 (è¶…çº§å¼ºåŒ–!)` : `å­å¼¹ä¼¤å®³ +${15 + level * 8}`,
                effect: (level) => ({ damage: level === 5 ? 100 : 15 + level * 8 })
            },
            speed: {
                name: "å¿«é€Ÿå°„å‡»",
                icon: "ğŸ¹",
                color: "#FF9800",
                maxLevel: 5,
                description: (level) => level === 5 ? `å°„å‡»é—´éš” -400ms (æé€Ÿå°„å‡»!)` : `å°„å‡»é—´éš” -${40 + level * 15}ms`,
                effect: (level) => ({ shootInterval: level === 5 ? -400 : -(40 + level * 15) })
            },
            health: {
                name: "ç”Ÿå‘½å¼ºåŒ–",
                icon: "â¤ï¸",
                color: "#E91E63",
                maxLevel: 5,
                description: (level) => level === 5 ? `æœ€å¤§ç”Ÿå‘½å€¼ +200ï¼Œå›å¤æ»¡è¡€ (é’¢é“ä¹‹èº¯!)` : `æœ€å¤§ç”Ÿå‘½å€¼ +${25 + level * 15}ï¼Œå›å¤æ»¡è¡€`,
                effect: (level) => ({ maxHealth: level === 5 ? 200 : 25 + level * 15, healFull: true })
            },
            moveSpeed: {
                name: "ç–¾é£æ­¥ä¼",
                icon: "ğŸ’¨",
                color: "#00BCD4",
                maxLevel: 5,
                description: (level) => level === 5 ? `ç§»åŠ¨é€Ÿåº¦ +4 (é—ªç”µé€Ÿåº¦!)` : `ç§»åŠ¨é€Ÿåº¦ +${Math.round((0.4 + level * 0.4) * 10) / 10}`,
                effect: (level) => ({ speed: level === 5 ? 4 : Math.round((0.4 + level * 0.4) * 10) / 10 })
            },
            penetration: {
                name: "ç©¿é€å°„å‡»",
                icon: "ğŸ¯",
                color: "#9C27B0",
                maxLevel: 5,
                description: (level) => level === 5 ? `å­å¼¹ç©¿é€ 15 ä¸ªæ•Œäºº (æ— é™ç©¿é€!)` : `å­å¼¹ç©¿é€ ${level * 2} ä¸ªæ•Œäºº`,
                effect: (level) => ({ penetration: level === 5 ? 15 : level * 2 })
            },
            lightning: {
                name: "é›·ç”µé“¾",
                icon: "âš¡",
                color: "#FFEB3B",
                maxLevel: 5,
                description: (level) => level === 5 ? `å‡»ä¸­æ•Œäººæ—¶ç”µå‡»å‘¨å›´æ•Œäººï¼Œä¼¤å®³80 (é›·ç¥ä¹‹æ€’!)` : `å‡»ä¸­æ•Œäººæ—¶ç”µå‡»å‘¨å›´æ•Œäººï¼Œä¼¤å®³${8 + level * 6}`,
                effect: (level) => ({ lightning: level === 5 ? 80 : 8 + level * 6 })
            },
            poison: {
                name: "æ¯’æ€§æ”»å‡»",
                icon: "â˜ ï¸",
                color: "#4CAF50",
                maxLevel: 5,
                description: (level) => {
                    if (level === 5) return `å‡»ä¸­æ•Œäººä¸­æ¯’10ç§’ï¼Œæ¯ç§’ä¼¤å®³25ï¼Œå¼ºåŠ›ä¼ æŸ“ (å‰§æ¯’é¢†åŸŸ!)`;
                    return `å‡»ä¸­æ•Œäººä¸­æ¯’${2 + level}ç§’ï¼Œæ¯ç§’ä¼¤å®³${4 + level * 3}${level >= 3 ? 'ï¼Œå¯ä¼ æŸ“' : ''}`;
                },
                effect: (level) => ({ 
                    poison: { 
                        duration: level === 5 ? 10 : 2 + level, 
                        damage: level === 5 ? 25 : 4 + level * 3,
                        contagious: level >= 3,
                        range: level >= 3 ? (level === 5 ? 100 : 40 + level * 12) : 0
                    } 
                })
            },
            multishot: {
                name: "å¤šé‡å°„å‡»",
                icon: "ğŸŒŸ",
                color: "#3F51B5",
                maxLevel: 5,
                description: (level) => level === 5 ? `åŒæ—¶å‘å°„ 6 å‘å­å¼¹ (å¼¹å¹•é£æš´!)` : `åŒæ—¶å‘å°„ ${level + 1} å‘å­å¼¹`,
                effect: (level) => ({ multishot: level === 5 ? 6 : level + 1 })
            },
            explosion: {
                name: "çˆ†ç‚¸å¼¹å¤´",
                icon: "ğŸ’¥",
                color: "#FF5722",
                maxLevel: 5,
                description: (level) => level === 5 ? `å­å¼¹çˆ†ç‚¸ï¼ŒèŒƒå›´ä¼¤å®³100 (æ ¸å¼¹çº§å¨åŠ›!)` : `å­å¼¹çˆ†ç‚¸ï¼ŒèŒƒå›´ä¼¤å®³${12 + level * 6}`,
                effect: (level) => ({ explosion: level === 5 ? 100 : 12 + level * 6 })
            },
            vampire: {
                name: "ç”Ÿå‘½æ±²å–",
                icon: "ğŸ©¸",
                color: "#8E24AA",
                maxLevel: 5,
                description: (level) => level === 5 ? `å‡»æ€æ•Œäººå›å¤20ç”Ÿå‘½å€¼ (å®Œç¾å†ç”Ÿ!)` : `å‡»æ€æ•Œäººå›å¤${1 + level}ç”Ÿå‘½å€¼`,
                effect: (level) => ({ vampire: level === 5 ? 20 : 1 + level })
            },
            lightsaber: {
                name: "å…‰å‰‘æŠ¤ç›¾",
                icon: "ğŸ—¡ï¸",
                color: "#00E5FF",
                maxLevel: 5,
                description: (level) => level === 5 ? `8æŠŠå…‰å‰‘ç¯ç»•èº«ä½“ï¼Œå¯¹æ¥è§¦æ•Œäººé€ æˆ50/ç§’ä¼¤å®³ (å‰‘åœ£é¢†åŸŸ!)` : `${level}æŠŠå…‰å‰‘ç¯ç»•èº«ä½“ï¼Œå¯¹æ¥è§¦æ•Œäººé€ æˆ${6 + level * 3}/ç§’ä¼¤å®³`,
                effect: (level) => ({ 
                    lightsaber: {
                        count: level === 5 ? 8 : level,
                        damage: level === 5 ? 50 : 6 + level * 3
                    }
                })
            },
            freeze: {
                name: "å†°éœœå‡é€Ÿ",
                icon: "â„ï¸",
                color: "#00BCD4",
                maxLevel: 5,
                description: (level) => level === 5 ? `å‡»ä¸­æ•Œäººå†°å†»8ç§’ï¼Œå‡é€Ÿ90% (ç»å¯¹é›¶åº¦!)` : `å‡»ä¸­æ•Œäººå†°å†»${2 + level}ç§’ï¼Œå‡é€Ÿ${20 + level * 10}%`,
                effect: (level) => ({ 
                    freeze: {
                        duration: level === 5 ? 8 : 2 + level,
                        slowPercent: level === 5 ? 90 : 20 + level * 10
                    }
                })
            }
        };
        
        // æ¸¸æˆçŠ¶æ€
        const game = {
            player: {
                x: 0, y: 0, size: 18, speed: 5, health: 100, maxHealth: 100,
                level: 1, exp: 0, maxExp: 100, kills: 0, damage: 20,
                shootInterval: 600, lastShot: 0, direction: 0, facingLeft: false,
                walkCycle: 0, isMoving: false, skills: {}, penetration: 0,
                lightning: 0, poison: null, multishot: 1, explosion: 0, vampire: 0,
                pickupRange: 30, lightsaber: null, freeze: null
            },
            bullets: [], enemies: [], expOrbs: [], effects: [], enemyBullets: [],
            keys: {}, lastEnemySpawn: 0, enemySpawnInterval: 1500, paused: false,
            wave: 1, waveKills: 0, waveTarget: 8, buffs: [], particles: [],
            gameOver: false, startTime: Date.now(), survivalTime: 0, pickups: [],
            boss: null, bossActive: false, lastBossTime: 0, bossKills: 0,
            arena: null, bossPhase: 'none'
        };
        
        let animationTime = 0;
        
        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameStarted = true;
            document.getElementById('gameGuide').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('skillsDisplay').style.display = 'block';
            document.getElementById('buffs').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            if (isTouchDevice()) {
                const j = document.getElementById('joystick');
                if (j) j.style.display = 'block';
                setupJoystick();
            }
            
            updateUI();
            updateSkillsDisplay();
            updateBuffsDisplay();
        }
        
        // é”®ç›˜äº‹ä»¶
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Escape') {
                e.preventDefault();
                if (gameStarted && document.getElementById('skillModal').style.display !== 'block') {
                    togglePause();
                }
                return;
            }
            if (!game.paused && !game.gameOver && gameStarted) game.keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        // æš‚åœåŠŸèƒ½ - ä¿®å¤æŠ€èƒ½ç•Œé¢å†²çª
        function togglePause() {
            if (game.gameOver || !gameStarted) return;
            if (document.getElementById('skillModal').style.display === 'block') return; // æŠ€èƒ½ç•Œé¢æ—¶ä¸å…è®¸æš‚åœ
            
            game.paused = !game.paused;
            document.getElementById('pauseBtn').textContent = game.paused ? 'ç»§ç»­' : 'æš‚åœ';
        }
        
        // é‡æ–°å¼€å§‹æ¸¸æˆ
        function restartGame() {
            isRestart = true;
            
            // é‡ç½®æ‰€æœ‰æ¸¸æˆçŠ¶æ€
            game.player = {
                x: 0, y: 0, size: 18, speed: 5, health: 100, maxHealth: 100,
                level: 1, exp: 0, maxExp: 100, kills: 0, damage: 20,
                shootInterval: 600, lastShot: 0, direction: 0, facingLeft: false,
                walkCycle: 0, isMoving: false, skills: {}, penetration: 0,
                lightning: 0, poison: null, multishot: 1, explosion: 0, vampire: 0,
                pickupRange: 30, lightsaber: null, freeze: null
            };
            
            game.bullets = [];
            game.enemies = [];
            game.expOrbs = [];
            game.effects = [];
            game.enemyBullets = [];
            game.pickups = [];
            game.lastEnemySpawn = 0;
            game.enemySpawnInterval = 1500;
            game.wave = 1;
            game.waveKills = 0;
            game.waveTarget = 8;
            game.buffs = [];
            game.particles = [];
            game.gameOver = false;
            game.paused = false;
            game.startTime = Date.now();
            game.survivalTime = 0;
            game.boss = null;
            game.bossActive = false;
            game.lastBossTime = 0;
            game.bossKills = 0;
            game.arena = null;
            game.bossPhase = 'none';
            
            world.x = 0;
            world.y = 0;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('perfectEnding').style.display = 'none';
            document.getElementById('bossWarning').style.display = 'none';
            document.getElementById('bossUI').style.display = 'none';
            document.getElementById('pauseBtn').textContent = 'æš‚åœ';
            
            updateUI();
            updateSkillsDisplay();
            updateBuffsDisplay();
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            game.gameOver = true;
            
            document.getElementById('finalKills').textContent = game.player.kills;
            document.getElementById('finalTime').textContent = formatTime(game.survivalTime);
            document.getElementById('finalWave').textContent = game.wave;
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('finalBosses').textContent = game.bossKills;
            
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æŠ€èƒ½éƒ½æ»¡çº§
        function checkPerfectEnding() {
            const allSkills = Object.keys(skillDefinitions);
            const maxedSkills = allSkills.filter(skill => 
                (game.player.skills[skill] || 0) >= skillDefinitions[skill].maxLevel
            );
            
            if (maxedSkills.length === allSkills.length) {
                document.getElementById('perfectEnding').style.display = 'block';
                game.paused = true;
            }
        }
        
        // æ ¼å¼åŒ–æ—¶é—´
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }
        
        // æ£€æŸ¥Bossç”Ÿæˆ
        function checkBossSpawn() {
            const timeSinceLastBoss = game.survivalTime - game.lastBossTime;
            if (timeSinceLastBoss >= 180 && !game.bossActive && game.bossPhase === 'none') {
                initiateBossPhase();
            }
        }
        
        // å¼€å§‹Bossé˜¶æ®µ
        function initiateBossPhase() {
            game.bossPhase = 'warning';
            
            // æ˜¾ç¤ºBossè­¦å‘Š
            document.getElementById('bossWarning').style.display = 'block';
            
            // 3ç§’åè¿›å…¥å‡†å¤‡é˜¶æ®µ
            setTimeout(() => {
                if (game.bossPhase === 'warning') {
                    prepareBossArena();
                }
            }, 3000);
        }
        
        // å‡†å¤‡Bossç«æŠ€åœº
        function prepareBossArena() {
            game.bossPhase = 'preparing';
            document.getElementById('bossWarning').style.display = 'none';
            
            // æ¸…é™¤æ‰€æœ‰æ•Œäººã€ç»éªŒçƒå’Œæ‹¾å–ç‰©
            game.enemies = [];
            game.expOrbs = [];
            game.pickups = [];
            game.enemyBullets = [];
            
            // åˆ›å»ºå›ºå®šçš„ç«æŠ€åœº
            const baseSize = Math.min(canvas.width, canvas.height) * 0.7;
            const arenaWidth = baseSize * 2;
            const arenaHeight = baseSize * 1.5;
            
            // ç«æŠ€åœºä½ç½®å›ºå®šåœ¨å½“å‰ç©å®¶ä½ç½®
            game.arena = {
                x: game.player.x - arenaWidth / 2,
                y: game.player.y - arenaHeight / 2,
                width: arenaWidth,
                height: arenaHeight
            };
            
            // å°†ç©å®¶ç§»åŠ¨åˆ°ç«æŠ€åœºä¸­å¿ƒ
            game.player.x = game.arena.x + game.arena.width / 2;
            game.player.y = game.arena.y + game.arena.height / 2;
            
            // 1ç§’åç”ŸæˆBoss
            setTimeout(() => {
                if (game.bossPhase === 'preparing') {
                    spawnBoss();
                }
            }, 1000);
        }
        
        // ç”ŸæˆBoss
        function spawnBoss() {
            game.bossPhase = 'active';
            
            // æ ¹æ®å‡»è´¥çš„Bossæ•°é‡é€‰æ‹©Bossç±»å‹
            const bossTypeKeys = Object.keys(bossTypes);
            const bossIndex = Math.min(game.bossKills, bossTypeKeys.length - 1);
            const bossTypeKey = bossTypeKeys[bossIndex];
            const bossType = bossTypes[bossTypeKey];
            
            // Bosséšç€æ—¶é—´å˜å¼º
            const timeMultiplier = 1 + Math.floor(game.survivalTime / 600);
            
            // åœ¨ç«æŠ€åœºè¾¹ç¼˜ç”ŸæˆBossï¼Œè¿œç¦»ç©å®¶
            const spawnAngle = Math.random() * Math.PI * 2;
            const spawnDistance = Math.min(game.arena.width, game.arena.height) * 0.3;
            
            const arenaCenter = {
                x: game.arena.x + game.arena.width / 2,
                y: game.arena.y + game.arena.height / 2
            };
            
            // åˆ›å»ºBossï¼Œæ‰€æœ‰å±æ€§åœ¨åˆ›å»ºæ—¶ç¡®å®šï¼Œä¸å†å˜åŒ–
            const finalHealth = Math.floor(bossType.health * timeMultiplier);
            const finalSpeed = Math.round((bossType.speed * Math.min(timeMultiplier, 2)) * 10) / 10;
            const finalDamage = Math.floor(bossType.damage * Math.min(timeMultiplier, 2));
            
            game.boss = {
                x: arenaCenter.x + Math.cos(spawnAngle) * spawnDistance,
                y: arenaCenter.y + Math.sin(spawnAngle) * spawnDistance,
                type: bossTypeKey,
                size: bossType.size,
                speed: finalSpeed,
                health: finalHealth,
                maxHealth: finalHealth,
                damage: finalDamage,
                shootInterval: Math.max(200, Math.floor(bossType.shootInterval / timeMultiplier)),
                lastShot: 0,
                lastAbility: 0,
                abilityInterval: 3000,
                expReward: Math.floor(bossType.expReward * timeMultiplier),
                abilities: [...bossType.abilities],
                frozen: false,
                freezeDuration: 0,
                originalSpeed: finalSpeed,
                lastDamageTime: 0,
                targetX: game.player.x,
                targetY: game.player.y,
                moveTimer: 0
            };
            
            // ç¡®ä¿Bossåœ¨ç«æŠ€åœºå†…
            constrainToArena(game.boss);
            
            game.bossActive = true;
            document.getElementById('bossUI').style.display = 'block';
            updateBossUI();
        }
        
        // é™åˆ¶åœ¨ç«æŠ€åœºå†…
        function constrainToArena(entity) {
            if (!game.arena) return;
            
            const margin = entity.size + 5;
            entity.x = Math.max(game.arena.x + margin, 
                       Math.min(game.arena.x + game.arena.width - margin, entity.x));
            entity.y = Math.max(game.arena.y + margin, 
                       Math.min(game.arena.y + game.arena.height - margin, entity.y));
        }
        
        // å‡»è´¥Boss
        function defeatBoss() {
            game.bossActive = false;
            game.boss = null;
            game.lastBossTime = game.survivalTime;
            game.bossKills++;
            game.arena = null;
            game.bossPhase = 'none';
            
            document.getElementById('bossUI').style.display = 'none';
            
            // è·å¾—å¤§é‡ç»éªŒ
            game.player.exp += 500;
            
            // æš‚åœæ¸¸æˆå¹¶ç›´æ¥è·å¾—æŠ€èƒ½å‡çº§
            game.paused = true;
            showSkillModal();
            
            updateUI();
        }
        
        // æ›´æ–°Boss UI
        function updateBossUI() {
            if (!game.boss) return;
            
            const bossType = bossTypes[game.boss.type];
            document.getElementById('bossName').textContent = bossType.name;
            document.getElementById('bossHealth').textContent = Math.max(0, Math.floor(game.boss.health));
            document.getElementById('bossMaxHealth').textContent = game.boss.maxHealth;
            
            const healthPercent = Math.max(0, game.boss.health / game.boss.maxHealth) * 100;
            document.getElementById('bossHealthFill').style.width = healthPercent + '%';
        }
        
        // åˆ›å»ºç²’å­æ•ˆæœ
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        // ç»˜åˆ¶ç²¾ç¾ç©å®¶è§’è‰²
        function drawPlayer(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            if (game.player.facingLeft) ctx.scale(-1, 1);
            
            const walkOffset = game.player.isMoving ? Math.sin(game.player.walkCycle) * 2 : 0;
            const legOffset = game.player.isMoving ? Math.sin(game.player.walkCycle * 2) * 3 : 0;
            const armOffset = game.player.isMoving ? Math.sin(game.player.walkCycle * 1.5) * 1 : 0;
            
            // é˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 28, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸»ä½“è£…ç”² - æ¸å˜æ•ˆæœ
            const bodyGradient = ctx.createLinearGradient(-9, -16, 9, 10);
            bodyGradient.addColorStop(0, '#42A5F5');
            bodyGradient.addColorStop(0.5, '#2196F3');
            bodyGradient.addColorStop(1, '#1976D2');
            ctx.fillStyle = bodyGradient;
            ctx.fillRect(-9, -16, 18, 26);
            
            // è£…ç”²ç»†èŠ‚å’Œåå…‰
            ctx.fillStyle = '#1E88E5';
            ctx.fillRect(-7, -14, 14, 3);
            ctx.fillRect(-5, -9, 10, 2);
            ctx.fillRect(-6, -2, 12, 2);
            
            // è£…ç”²è¾¹ç¼˜é«˜å…‰
            ctx.strokeStyle = '#64B5F6';
            ctx.lineWidth = 1;
            ctx.strokeRect(-9, -16, 18, 26);
            
            // èƒ¸å‰èƒ½é‡æ ¸å¿ƒ
            const coreGradient = ctx.createRadialGradient(0, -8, 0, 0, -8, 5);
            coreGradient.addColorStop(0, '#FFD700');
            coreGradient.addColorStop(0.7, '#FFA000');
            coreGradient.addColorStop(1, '#FF8F00');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, -8, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒ½é‡æ ¸å¿ƒå‘å…‰æ•ˆæœ
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(0, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // å¤´éƒ¨ - è‚¤è‰²æ¸å˜
            const headGradient = ctx.createRadialGradient(-3, -27, 0, 0, -25, 10);
            headGradient.addColorStop(0, '#FFCC80');
            headGradient.addColorStop(1, '#FFB74D');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(0, -25, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // é«˜ç§‘æŠ€å¤´ç›”
            const helmetGradient = ctx.createLinearGradient(-11, -35, 11, -20);
            helmetGradient.addColorStop(0, '#455A64');
            helmetGradient.addColorStop(0.5, '#37474F');
            helmetGradient.addColorStop(1, '#263238');
            ctx.fillStyle = helmetGradient;
            ctx.beginPath();
            ctx.arc(0, -27, 11, Math.PI, 0);
            ctx.fill();
            
            // å¤´ç›”è£…é¥°å’Œé€šé£å£
            ctx.fillStyle = '#607D8B';
            ctx.fillRect(-8, -30, 16, 2);
            ctx.fillRect(-6, -32, 3, 1);
            ctx.fillRect(3, -32, 3, 1);
            
            // å¤´ç›”ä¾§é¢è£…é¥°
            ctx.fillStyle = '#78909C';
            ctx.fillRect(-10, -28, 2, 4);
            ctx.fillRect(8, -28, 2, 4);
            
            // æŠ¤ç›®é•œ/é¢ç½©
            ctx.fillStyle = '#1A237E';
            ctx.fillRect(-8, -28, 16, 4);
            
            // çœ¼ç›å‘å…‰æ•ˆæœ
            ctx.fillStyle = '#00E5FF';
            ctx.shadowColor = '#00E5FF';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(-3, -26, 2, 0, Math.PI * 2);
            ctx.arc(3, -26, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // å˜´éƒ¨å‘¼å¸å™¨
            ctx.fillStyle = '#37474F';
            ctx.fillRect(-3, -23, 6, 3);
            ctx.fillStyle = '#546E7A';
            ctx.fillRect(-2, -22, 4, 1);
            
            // å·¦æ‰‹è‡‚è£…ç”²
            ctx.strokeStyle = '#FFCC80';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-9, -10);
            ctx.lineTo(-16, -6 + armOffset);
            ctx.lineTo(-20, -1 + armOffset);
            ctx.stroke();
            
            // å·¦è‡‚æŠ¤ç”²
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.arc(-13, -8 + armOffset, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // å³æ‰‹è‡‚ï¼ˆæŒæªï¼‰è£…ç”²
            ctx.beginPath();
            ctx.moveTo(9, -10);
            ctx.lineTo(16, -6 - armOffset);
            ctx.lineTo(23, -3 - armOffset);
            ctx.stroke();
            
            // å³è‡‚æŠ¤ç”²
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.arc(13, -8 - armOffset, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // ç²¾ç¾é«˜ç§‘æŠ€æªæ¢°
            const gunGradient = ctx.createLinearGradient(23, -6 - armOffset, 41, -1 - armOffset);
            gunGradient.addColorStop(0, '#546E7A');
            gunGradient.addColorStop(0.5, '#424242');
            gunGradient.addColorStop(1, '#212121');
            ctx.fillStyle = gunGradient;
            ctx.fillRect(23, -6 - armOffset, 18, 5);
            
            // æªç®¡
            ctx.fillStyle = '#263238';
            ctx.fillRect(41, -5 - armOffset, 8, 3);
            
            // æªç®¡æœ«ç«¯
            ctx.fillStyle = '#37474F';
            ctx.fillRect(49, -4.5 - armOffset, 2, 2);
            
            // æªæ‰˜
            const stockGradient = ctx.createLinearGradient(18, -5 - armOffset, 25, -2 - armOffset);
            stockGradient.addColorStop(0, '#8D6E63');
            stockGradient.addColorStop(1, '#5D4037');
            ctx.fillStyle = stockGradient;
            ctx.fillRect(18, -5 - armOffset, 7, 3);
            
            // æ‰³æœºæŠ¤åœˆ
            ctx.strokeStyle = '#546E7A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(26, -2 - armOffset, 2, 0, Math.PI);
            ctx.stroke();
            
            // ç„å‡†é•œ
            ctx.fillStyle = '#37474F';
            ctx.fillRect(30, -8 - armOffset, 8, 4);
            ctx.fillStyle = '#1A237E';
            ctx.fillRect(31, -7 - armOffset, 6, 2);
            
            // æªæ¢°è£…é¥°
            ctx.fillStyle = '#FF5722';
            ctx.fillRect(35, -5.5 - armOffset, 3, 1);
            
            // è…¿éƒ¨è£…ç”²
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-5, 10);
            ctx.lineTo(-7, 24 + legOffset);
            ctx.moveTo(5, 10);
            ctx.lineTo(7, 24 - legOffset);
            ctx.stroke();
            
            // è†ç›–æŠ¤ç”²
            ctx.fillStyle = '#1565C0';
            ctx.beginPath();
            ctx.arc(-6, 17 + legOffset/2, 3, 0, Math.PI * 2);
            ctx.arc(6, 17 - legOffset/2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // æˆ˜æœ¯é´
            const bootGradient = ctx.createLinearGradient(-11, 22, -2, 27);
            bootGradient.addColorStop(0, '#546E7A');
            bootGradient.addColorStop(1, '#263238');
            ctx.fillStyle = bootGradient;
            ctx.fillRect(-11, 22 + legOffset, 9, 6);
            ctx.fillRect(2, 22 - legOffset, 9, 6);
            
            // é´å­ç»†èŠ‚
            ctx.fillStyle = '#78909C';
            ctx.fillRect(-10, 23 + legOffset, 7, 2);
            ctx.fillRect(3, 23 - legOffset, 7, 2);
            
            // é´å­é‹åº•
            ctx.fillStyle = '#212121';
            ctx.fillRect(-11, 27 + legOffset, 9, 2);
            ctx.fillRect(2, 27 - legOffset, 9, 2);
            
            ctx.restore();
            
            // ç»˜åˆ¶å…‰å‰‘æŠ¤ç›¾
            if (game.player.lightsaber) {
                drawLightsabers(x, y);
            }
        }
        
        // ç»˜åˆ¶å…‰å‰‘æŠ¤ç›¾
        function drawLightsabers(x, y) {
            const saber = game.player.lightsaber;
            const radius = 45;
            
            for (let i = 0; i < saber.count; i++) {
                const angle = (animationTime * 0.02) + (i * (Math.PI * 2) / saber.count);
                const saberX = x + Math.cos(angle) * radius;
                const saberY = y + Math.sin(angle) * radius;
                
                ctx.save();
                ctx.translate(saberX, saberY);
                ctx.rotate(angle + Math.PI / 2);
                
                // å…‰å‰‘å‰‘æŸ„
                const hiltGradient = ctx.createLinearGradient(-2, -7, 2, 7);
                hiltGradient.addColorStop(0, '#546E7A');
                hiltGradient.addColorStop(0.5, '#37474F');
                hiltGradient.addColorStop(1, '#263238');
                ctx.fillStyle = hiltGradient;
                ctx.fillRect(-2, -7, 4, 14);
                
                // å‰‘æŸ„ç»†èŠ‚
                ctx.fillStyle = '#78909C';
                ctx.fillRect(-2, -2, 4, 2);
                ctx.fillRect(-2, 2, 4, 2);
                
                // å…‰å‰‘åˆ€èº«
                const bladeGradient = ctx.createLinearGradient(0, -22, 0, -7);
                bladeGradient.addColorStop(0, 'rgba(0, 229, 255, 0.8)');
                bladeGradient.addColorStop(0.5, '#00E5FF');
                bladeGradient.addColorStop(1, 'rgba(0, 229, 255, 0.8)');
                
                ctx.fillStyle = bladeGradient;
                ctx.fillRect(-1, -22, 2, 15);
                
                // å…‰å‰‘å‘å…‰æ•ˆæœ
                ctx.shadowColor = '#00E5FF';
                ctx.shadowBlur = 8;
                ctx.fillRect(-1, -22, 2, 15);
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
        }
        
        // ç»˜åˆ¶ç²¾ç¾Boss
        function drawBoss(boss, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const dx = game.player.x - boss.x;
            const facingLeft = dx < 0;
            if (facingLeft) ctx.scale(-1, 1);
            
            const bossType = bossTypes[boss.type];
            const scale = boss.size / 30;
            const time = animationTime * 0.01;
            
            // Bossé˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 35 * scale, 30 * scale, 8 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Bossä¸»ä½“è£…ç”² - æ¸å˜æ•ˆæœ
            const bodyGradient = ctx.createLinearGradient(-25 * scale, -25 * scale, 25 * scale, 20 * scale);
            if (boss.frozen) {
                bodyGradient.addColorStop(0, '#B3E5FC');
                bodyGradient.addColorStop(0.5, '#81D4FA');
                bodyGradient.addColorStop(1, '#4FC3F7');
            } else {
                bodyGradient.addColorStop(0, bossType.color);
                bodyGradient.addColorStop(0.5, '#666');
                bodyGradient.addColorStop(1, '#333');
            }
            ctx.fillStyle = bodyGradient;
            ctx.fillRect(-25 * scale, -25 * scale, 50 * scale, 45 * scale);
            
            // Bossè£…ç”²ç»†èŠ‚
            ctx.fillStyle = boss.frozen ? '#546E7A' : '#424242';
            ctx.fillRect(-20 * scale, -20 * scale, 40 * scale, 8 * scale);
            ctx.fillRect(-15 * scale, -10 * scale, 30 * scale, 6 * scale);
            ctx.fillRect(-18 * scale, 0, 36 * scale, 4 * scale);
            
            // è£…ç”²æ¿è¿æ¥
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = '#616161';
                ctx.beginPath();
                ctx.arc(-15 * scale + i * 15 * scale, -15 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Bosså¤´éƒ¨ - æ›´ç²¾ç»†
            const headGradient = ctx.createRadialGradient(0, -35 * scale, 0, 0, -35 * scale, 15 * scale);
            if (boss.frozen) {
                headGradient.addColorStop(0, '#E1F5FE');
                headGradient.addColorStop(1, '#B3E5FC');
            } else {
                headGradient.addColorStop(0, '#FF7043');
                headGradient.addColorStop(1, '#D84315');
            }
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(0, -35 * scale, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // å¤´éƒ¨è£…ç”²ç»†èŠ‚
            ctx.fillStyle = boss.frozen ? '#37474F' : '#BF360C';
            ctx.fillRect(-12 * scale, -42 * scale, 24 * scale, 6 * scale);
            
            // Bossçœ¼ç› - å‘å…‰æ•ˆæœ
            ctx.fillStyle = boss.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowColor = boss.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowBlur = 8 * scale;
            ctx.beginPath();
            ctx.arc(-6 * scale, -38 * scale, 4 * scale, 0, Math.PI * 2);
            ctx.arc(6 * scale, -38 * scale, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // çœ¼ç›å†…éƒ¨ç»†èŠ‚
            ctx.fillStyle = boss.frozen ? '#B3E5FC' : '#FFCDD2';
            ctx.beginPath();
            ctx.arc(-6 * scale, -39 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.arc(6 * scale, -39 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Bossæ­¦å™¨ç³»ç»Ÿ
            const weaponGradient = ctx.createLinearGradient(25 * scale, -15 * scale, 45 * scale, -7 * scale);
            weaponGradient.addColorStop(0, '#757575');
            weaponGradient.addColorStop(1, '#424242');
            ctx.fillStyle = weaponGradient;
            ctx.fillRect(25 * scale, -15 * scale, 20 * scale, 8 * scale);
            ctx.fillRect(-45 * scale, -15 * scale, 20 * scale, 8 * scale);
            
            // æ­¦å™¨ç»†èŠ‚
            ctx.fillStyle = '#FF5722';
            ctx.fillRect(30 * scale, -13 * scale, 10 * scale, 4 * scale);
            ctx.fillRect(-40 * scale, -13 * scale, 10 * scale, 4 * scale);
            
            // èƒ½é‡ç®¡é“
            ctx.strokeStyle = boss.frozen ? '#00BCD4' : '#FF9800';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.moveTo(-20 * scale, -5 * scale);
            ctx.quadraticCurveTo(0, -10 * scale, 20 * scale, -5 * scale);
            ctx.stroke();
            
            // èƒ¸éƒ¨èƒ½é‡æ ¸å¿ƒ
            const coreGradient = ctx.createRadialGradient(0, -5 * scale, 0, 0, -5 * scale, 8 * scale);
            if (boss.frozen) {
                coreGradient.addColorStop(0, '#00E5FF');
                coreGradient.addColorStop(1, '#0277BD');
            } else {
                coreGradient.addColorStop(0, '#FF6F00');
                coreGradient.addColorStop(1, '#E65100');
            }
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, -5 * scale, 6 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // èƒ½é‡æ ¸å¿ƒè„‰åŠ¨æ•ˆæœ
            const pulseSize = 4 * scale + Math.sin(time * 4) * 2 * scale;
            ctx.fillStyle = boss.frozen ? 'rgba(0, 229, 255, 0.5)' : 'rgba(255, 111, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(0, -5 * scale, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // å†°å†»ç‰¹æ•ˆ
            if (boss.frozen) {
                drawFreezeEffect(0, 0, boss.size);
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶å†°å†»ç‰¹æ•ˆ
        function drawFreezeEffect(x, y, size) {
            const time = animationTime * 0.01;
            
            // å†°æ™¶ç¯ç»•
            for (let i = 0; i < 12; i++) {
                const angle = time + (i * Math.PI / 6);
                const radius = size * 0.8 + Math.sin(time * 3 + i) * 8;
                const crystalX = Math.cos(angle) * radius;
                const crystalY = Math.sin(angle) * radius;
                
                ctx.save();
                ctx.translate(crystalX, crystalY);
                ctx.rotate(angle);
                
                // å†°æ™¶
                ctx.fillStyle = `rgba(135, 206, 235, ${0.6 + Math.sin(time * 4 + i) * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(4, 0);
                ctx.lineTo(0, 8);
                ctx.lineTo(-4, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // å†°é›¾æ•ˆæœ
            for (let i = 0; i < 8; i++) {
                const angle = time * 0.5 + (i * Math.PI / 4);
                const radius = size * 0.6 + Math.sin(time * 2 + i) * 10;
                const mistX = Math.cos(angle) * radius;
                const mistY = Math.sin(angle) * radius;
                
                const gradient = ctx.createRadialGradient(mistX, mistY, 0, mistX, mistY, 12);
                gradient.addColorStop(0, 'rgba(173, 216, 230, 0.4)');
                gradient.addColorStop(1, 'rgba(173, 216, 230, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(mistX, mistY, 10 + Math.sin(time * 3 + i) * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ç»˜åˆ¶ç²¾ç¾æ•Œäººè§’è‰²
        function drawEnemy(enemy, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const dx = game.player.x - enemy.x;
            const facingLeft = dx < 0;
            if (facingLeft) ctx.scale(-1, 1);
            
            const type = enemyTypes[enemy.type];
            const scale = enemy.size / 15;
            const time = animationTime * 0.01;
            
            // æ•Œäººé˜´å½±
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 18 * scale, 12 * scale, 4 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // æ ¹æ®æ•Œäººç±»å‹ç»˜åˆ¶ä¸åŒå¤–è§‚
            if (enemy.type === 'tank') {
                // é‡è£…å…µ - æ›´åšé‡çš„è£…ç”²
                const tankGradient = ctx.createLinearGradient(-14 * scale, -16 * scale, 14 * scale, 12 * scale);
                tankGradient.addColorStop(0, enemy.frozen ? '#B3E5FC' : '#8D6E63');
                tankGradient.addColorStop(0.5, enemy.frozen ? '#81D4FA' : '#6D4C41');
                tankGradient.addColorStop(1, enemy.frozen ? '#4FC3F7' : '#5D4037');
                ctx.fillStyle = tankGradient;
                ctx.fillRect(-14 * scale, -16 * scale, 28 * scale, 28 * scale);
                
                // åšé‡è£…ç”²å±‚
                ctx.fillStyle = enemy.frozen ? '#546E7A' : '#4E342E';
                ctx.fillRect(-12 * scale, -14 * scale, 24 * scale, 5 * scale);
                ctx.fillRect(-10 * scale, -8 * scale, 20 * scale, 4 * scale);
                
                // è£…ç”²é“†é’‰
                for (let i = 0; i < 4; i++) {
                    ctx.fillStyle = '#616161';
                    ctx.beginPath();
                    ctx.arc(-8 * scale + i * 5 * scale, -12 * scale, 1 * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // è£…ç”²å¤´ç›”
                const helmetGradient = ctx.createRadialGradient(0, -24 * scale, 0, 0, -24 * scale, 14 * scale);
                helmetGradient.addColorStop(0, '#616161');
                helmetGradient.addColorStop(1, '#424242');
                ctx.fillStyle = helmetGradient;
                ctx.beginPath();
                ctx.arc(0, -24 * scale, 14 * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´ç›”æŠ¤ç›®é•œ
                ctx.fillStyle = enemy.frozen ? '#00E5FF' : '#F44336';
                ctx.shadowColor = enemy.frozen ? '#00E5FF' : '#F44336';
                ctx.shadowBlur = 5;
                ctx.fillRect(-10 * scale, -27 * scale, 20 * scale, 5 * scale);
                ctx.shadowBlur = 0;
                
            } else if (enemy.type === 'gunner') {
                // æªæ‰‹ - ç²¾ç¡®å°„æ‰‹å¤–è§‚
                const gunnerGradient = ctx.createLinearGradient(-10, -14, 10, 10);
                gunnerGradient.addColorStop(0, enemy.frozen ? '#B39DDB' : '#AB47BC');
                gunnerGradient.addColorStop(1, enemy.frozen ? '#9575CD' : '#8E24AA');
                ctx.fillStyle = gunnerGradient;
                ctx.fillRect(-10, -14, 20, 24);
                
                // æˆ˜æœ¯èƒŒå¿ƒ
                ctx.fillStyle = enemy.frozen ? '#5C6BC0' : '#7B1FA2';
                ctx.fillRect(-8, -12, 16, 10);
                
                // èƒŒå¿ƒè£…å¤‡
                ctx.fillStyle = '#4A148C';
                ctx.fillRect(-6, -10, 3, 6);
                ctx.fillRect(3, -10, 3, 6);
                
                // å¤´éƒ¨
                const headGradient = ctx.createRadialGradient(0, -22, 0, 0, -22, 9);
                headGradient.addColorStop(0, '#FFCDD2');
                headGradient.addColorStop(1, '#F8BBD9');
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(0, -22, 9, 0, Math.PI * 2);
                ctx.fill();
                
                // æˆ˜æœ¯å¤´ç›”
                ctx.fillStyle = '#4A148C';
                ctx.beginPath();
                ctx.arc(0, -24, 10, Math.PI, 0);
                ctx.fill();
                
                // ç²¾ç¡®æ­¥æª
                const rifleGradient = ctx.createLinearGradient(14, -10, 34, -5);
                rifleGradient.addColorStop(0, '#546E7A');
                rifleGradient.addColorStop(1, '#263238');
                ctx.fillStyle = rifleGradient;
                ctx.fillRect(14, -10, 20, 5);
                
                // ç„å‡†é•œ
                ctx.fillStyle = '#37474F';
                ctx.fillRect(22, -12, 10, 4);
                
            } else if (enemy.type === 'fast') {
                // å¿«é€Ÿå…µ - è½»è£…æ•æ·
                const fastGradient = ctx.createLinearGradient(-7, -12, 7, 8);
                fastGradient.addColorStop(0, enemy.frozen ? '#FFE082' : '#FFB74D');
                fastGradient.addColorStop(1, enemy.frozen ? '#FFCC02' : '#FF9800');
                ctx.fillStyle = fastGradient;
                ctx.fillRect(-7, -12, 14, 20);
                
                // è½»å‹æŠ¤ç”²
                ctx.fillStyle = enemy.frozen ? '#FFA726' : '#F57C00';
                ctx.fillRect(-6, -10, 12, 4);
                
                // é€Ÿåº¦çº¿æ¡è£…é¥°
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-5, -8 + i * 3);
                    ctx.lineTo(5, -8 + i * 3);
                    ctx.stroke();
                }
                
            } else if (enemy.type === 'sniper') {
                // ç‹™å‡»æ‰‹
                const sniperGradient = ctx.createLinearGradient(-8, -13, 8, 9);
                sniperGradient.addColorStop(0, enemy.frozen ? '#90A4AE' : '#78909C');
                sniperGradient.addColorStop(1, enemy.frozen ? '#78909C' : '#607D8B');
                ctx.fillStyle = sniperGradient;
                ctx.fillRect(-8, -13, 16, 22);
                
                // ç‹™å‡»é•œ
                ctx.fillStyle = '#263238';
                ctx.beginPath();
                ctx.arc(0, -22, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // é•œç‰‡åå…‰
                ctx.fillStyle = '#B0BEC5';
                ctx.beginPath();
                ctx.arc(-2, -24, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // é•¿ç‹™å‡»æª
                const sniperRifleGradient = ctx.createLinearGradient(14, -8, 39, -5);
                sniperRifleGradient.addColorStop(0, '#424242');
                sniperRifleGradient.addColorStop(1, '#212121');
                ctx.fillStyle = sniperRifleGradient;
                ctx.fillRect(14, -8, 25, 3);
                
            } else if (enemy.type === 'bomber') {
                // çˆ†ç ´å…µ
                const bomberGradient = ctx.createLinearGradient(-11, -15, 11, 11);
                bomberGradient.addColorStop(0, enemy.frozen ? '#F8BBD9' : '#EC407A');
                bomberGradient.addColorStop(1, enemy.frozen ? '#F06292' : '#E91E63');
                ctx.fillStyle = bomberGradient;
                ctx.fillRect(-11, -15, 22, 26);
                
                // ç‚¸å¼¹èƒŒåŒ… - è„‰åŠ¨æ•ˆæœ
                const bombSize = 6 + Math.sin(time * 6) * 1;
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(-8, -8, bombSize, 0, Math.PI * 2);
                ctx.arc(8, -8, bombSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ç‚¸å¼¹å¼•çº¿
                ctx.strokeStyle = '#795548';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8, -14);
                ctx.lineTo(-8, -18);
                ctx.moveTo(8, -14);
                ctx.lineTo(8, -18);
                ctx.stroke();
                
            } else if (enemy.type === 'shield') {
                // æŠ¤ç›¾å…µ
                const shieldGradient = ctx.createLinearGradient(-10, -14, 10, 10);
                shieldGradient.addColorStop(0, enemy.frozen ? '#9FA8DA' : '#5C6BC0');
                shieldGradient.addColorStop(1, enemy.frozen ? '#7986CB' : '#3F51B5');
                ctx.fillStyle = shieldGradient;
                ctx.fillRect(-10, -14, 20, 24);
                
                // æŠ¤ç›¾
                if (enemy.hasShield) {
                    const shieldGradient = ctx.createRadialGradient(-15, 0, 0, -15, 0, 12);
                    shieldGradient.addColorStop(0, '#42A5F5');
                    shieldGradient.addColorStop(1, '#1976D2');
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 12, -Math.PI/2, Math.PI/2);
                    ctx.fill();
                    
                    // æŠ¤ç›¾è£…é¥°
                    ctx.fillStyle = '#1565C0';
                    ctx.fillRect(-20, -8, 8, 16);
                }
                
            } else if (enemy.type === 'healer') {
                // æ²»ç–—å…µ
                const healerGradient = ctx.createLinearGradient(-8, -13, 8, 9);
                healerGradient.addColorStop(0, enemy.frozen ? '#A5D6A7' : '#81C784');
                healerGradient.addColorStop(1, enemy.frozen ? '#81C784' : '#4CAF50');
                ctx.fillStyle = healerGradient;
                ctx.fillRect(-8, -13, 16, 22);
                
                // æ²»ç–—åå­—
                ctx.fillStyle = '#F44336';
                ctx.fillRect(-1, -18, 2, 8);
                ctx.fillRect(-4, -16, 8, 2);
                
                // æ²»ç–—å…‰ç¯
                if (enemy.healOthers) {
                    const healRadius = 30 + Math.sin(time * 2) * 5;
                    ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, healRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // æ²»ç–—ç²’å­
                    for (let i = 0; i < 6; i++) {
                        const angle = time + i * Math.PI / 3;
                        const x = Math.cos(angle) * 20;
                        const y = Math.sin(angle) * 20;
                        ctx.fillStyle = `rgba(76, 175, 80, ${0.5 + Math.sin(time * 4 + i) * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
            } else {
                // åŸºç¡€æ•Œäºº - æ ‡å‡†å£«å…µ
                const basicGradient = ctx.createLinearGradient(-9, -14, 9, 10);
                if (enemy.poisoned) {
                    basicGradient.addColorStop(0, '#A5D6A7');
                    basicGradient.addColorStop(1, '#4CAF50');
                } else if (enemy.frozen) {
                    basicGradient.addColorStop(0, '#FFCDD2');
                    basicGradient.addColorStop(1, '#F8BBD9');
                } else {
                    basicGradient.addColorStop(0, '#EF5350');
                    basicGradient.addColorStop(1, '#F44336');
                }
                ctx.fillStyle = basicGradient;
                ctx.fillRect(-9, -14, 18, 24);
                
                // æ ‡å‡†æŠ¤ç”²
                ctx.fillStyle = enemy.frozen ? '#5C6BC0' : '#C62828';
                ctx.fillRect(-7, -12, 14, 5);
                
                // æŠ¤ç”²ç»†èŠ‚
                ctx.fillStyle = '#B71C1C';
                ctx.fillRect(-6, -10, 3, 8);
                ctx.fillRect(3, -10, 3, 8);
                
                // æ ‡å‡†æ­¦å™¨
                const weaponGradient = ctx.createLinearGradient(14, -8, 28, -4);
                weaponGradient.addColorStop(0, '#546E7A');
                weaponGradient.addColorStop(1, '#263238');
                ctx.fillStyle = weaponGradient;
                ctx.fillRect(14, -8, 14, 4);
            }
            
            // é€šç”¨å¤´éƒ¨ï¼ˆå¦‚æœæ²¡æœ‰ç‰¹æ®Šå¤´ç›”ï¼‰
            if (!['tank', 'gunner', 'sniper'].includes(enemy.type)) {
                const headGradient = ctx.createRadialGradient(0, -22, 0, 0, -22, 9);
                headGradient.addColorStop(0, '#FFCDD2');
                headGradient.addColorStop(1, '#F8BBD9');
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(0, -22, 9, 0, Math.PI * 2);
                ctx.fill();
                
                // å¤´ç›”
                ctx.fillStyle = enemy.frozen ? '#37474F' : '#424242';
                ctx.beginPath();
                ctx.arc(0, -24, 10, Math.PI, 0);
                ctx.fill();
            }
            
            // é‚ªæ¶çš„çœ¼ç›
            ctx.fillStyle = enemy.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowColor = enemy.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowBlur = 3;
            ctx.beginPath();
            ctx.arc(-3, -24, 2, 0, Math.PI * 2);
            ctx.arc(3, -24, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // ç²¾ç¾ä¸­æ¯’æ•ˆæœ
            if (enemy.poisoned) {
                drawPoisonEffect(enemy, 0, 0);
            }
            
            // å†°å†»æ•ˆæœ
            if (enemy.frozen) {
                drawFreezeEffect(0, 0, enemy.size);
            }
            
            ctx.restore();
        }
        
        // ç»˜åˆ¶ç²¾ç¾ä¸­æ¯’æ•ˆæœ
        function drawPoisonEffect(enemy, x, y) {
            const time = animationTime * 0.01;
            
            // ç»¿è‰²æ¯’é›¾ç¯ç»•
            for (let i = 0; i < 8; i++) {
                const angle = time + (i * Math.PI / 4);
                const radius = 25 + Math.sin(time * 2 + i) * 5;
                const cloudX = Math.cos(angle) * radius;
                const cloudY = Math.sin(angle) * radius - 10;
                
                // æ¯’é›¾äº‘
                const gradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, 8);
                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');
                gradient.addColorStop(0.5, 'rgba(76, 175, 80, 0.3)');
                gradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 6 + Math.sin(time * 3 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ä¸Šå‡çš„æ¯’æ³¡æ³¡
            for (let i = 0; i < 5; i++) {
                const bubbleTime = (time * 2 + i) % 4;
                const bubbleX = (Math.sin(time + i) * 15);
                const bubbleY = -10 - bubbleTime * 15;
                const bubbleSize = 2 + Math.sin(time * 4 + i) * 1;
                const alpha = Math.max(0, 1 - bubbleTime / 4);
                
                ctx.fillStyle = `rgba(76, 175, 80, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
                
                // æ³¡æ³¡é«˜å…‰
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
                ctx.beginPath();
                ctx.arc(bubbleX - 1, bubbleY - 1, bubbleSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // åœ°é¢æ¯’æ¶²æ± 
            const poolGradient = ctx.createRadialGradient(0, 15, 0, 0, 15, 20);
            poolGradient.addColorStop(0, 'rgba(76, 175, 80, 0.4)');
            poolGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
            
            ctx.fillStyle = poolGradient;
            ctx.beginPath();
            ctx.ellipse(0, 15, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç»˜åˆ¶å­å¼¹
        function drawBullet(bullet, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const angle = Math.atan2(bullet.vy, bullet.vx);
            ctx.rotate(angle);
            
            // å­å¼¹ä¸»ä½“æ¸å˜
            const bulletGradient = ctx.createLinearGradient(-8, -2, 8, 2);
            bulletGradient.addColorStop(0, '#FFD700');
            bulletGradient.addColorStop(0.5, '#FFA000');
            bulletGradient.addColorStop(1, '#FF8F00');
            ctx.fillStyle = bulletGradient;
            ctx.fillRect(-8, -2, 16, 4);
            
            // å­å¼¹å¤´éƒ¨
            ctx.fillStyle = '#FF6F00';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(12, -2);
            ctx.lineTo(12, 2);
            ctx.closePath();
            ctx.fill();
            
            // å­å¼¹å°¾è¿¹
            ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.fillRect(-12, -1, 4, 2);
            
            ctx.restore();
            
            // å­å¼¹å‘å…‰æ•ˆæœ
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // ç»˜åˆ¶ç»éªŒçƒ - ä¿®å¤å¤§ç»éªŒçƒç‰¹æ•ˆé¢œè‰²
        function drawExpOrb(orb, screenX, screenY) {
            const pulseSize = orb.size + Math.sin(animationTime * 0.01) * 2;
            
            // å¤–å±‚å…‰ç¯
            if (orb.type === 'big') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            } else {
                ctx.fillStyle = 'rgba(0, 188, 212, 0.3)';
            }
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseSize + 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¸»ä½“
            const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, pulseSize);
            if (orb.type === 'big') {
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA000');
                gradient.addColorStop(1, '#FF8F00');
            } else {
                gradient.addColorStop(0, '#4DD0E1');
                gradient.addColorStop(0.7, '#00BCD4');
                gradient.addColorStop(1, '#0097A7');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // å†…éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(screenX - 2, screenY - 2, pulseSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // ç»˜åˆ¶æ‹¾å–ç‰©å“
        function drawPickup(pickup, screenX, screenY) {
            const pulseSize = pickup.size + Math.sin(animationTime * 0.01) * 2;
            
            if (pickup.type === 'magnet') {
                // ç£é“
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize + 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ğŸ§²', screenX, screenY + 6);
                
            } else if (pickup.type === 'health') {
                // è¡€åŒ…
                ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize + 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#F44336';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('â¤ï¸', screenX, screenY + 6);
            }
        }
        
        // ç»˜åˆ¶ç«æŠ€åœºè¾¹ç•Œ
        function drawArenaBorder() {
            if (!game.arena) return;
            
            const borderX = game.arena.x - world.x;
            const borderY = game.arena.y - world.y;
            const borderWidth = game.arena.width;
            const borderHeight = game.arena.height;
            
            // åªåœ¨è¾¹ç•Œåœ¨å±å¹•èŒƒå›´å†…æ—¶ç»˜åˆ¶
            if (borderX < canvas.width && borderY < canvas.height && 
                borderX + borderWidth > 0 && borderY + borderHeight > 0) {
                
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 10;
                ctx.strokeRect(borderX, borderY, borderWidth, borderHeight);
                ctx.shadowBlur = 0;
            }
        }
        
        // ç©å®¶ç§»åŠ¨
        function movePlayer() {
            const player = game.player;
            let moved = false;
            let moveX = 0, moveY = 0;

            // ä¼˜å…ˆä½¿ç”¨ç§»åŠ¨é¥æ†ï¼ˆè§¦å±è®¾å¤‡ï¼‰
            if (isTouchDevice() && joystick.active && joystick.magnitude > 0.05) {
                const speedScale = joystick.magnitude; // æ¨¡æ‹Ÿæ¨¡æ‹Ÿé‡é€Ÿåº¦
                moveX = joystick.dx * player.speed * speedScale;
                moveY = joystick.dy * player.speed * speedScale;
                moved = true;
                if (moveX < -0.01) player.facingLeft = true;
                else if (moveX > 0.01) player.facingLeft = false;
            } else {
                if (game.keys['w'] || game.keys['arrowup']) {
                    moveY = -player.speed;
                    moved = true;
                }
                if (game.keys['s'] || game.keys['arrowdown']) {
                    moveY = player.speed;
                    moved = true;
                }
                if (game.keys['a'] || game.keys['arrowleft']) {
                    moveX = -player.speed;
                    moved = true;
                    player.facingLeft = true;
                }
                if (game.keys['d'] || game.keys['arrowright']) {
                    moveX = player.speed;
                    moved = true;
                    player.facingLeft = false;
                }
            }

            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.707;
                moveY *= 0.707;
            }

            player.x += moveX;
            player.y += moveY;
            player.isMoving = moved;

            if (moved) {
                player.walkCycle += 0.3;
            }

            // é™åˆ¶åœ¨ç«æŠ€åœºå†…
            if (game.bossActive) {
                constrainToArena(player);
            }

            // æ›´æ–°æ‘„åƒæœº
            world.x = player.x - canvas.width / 2;
            world.y = player.y - canvas.height / 2;
        }
        
        // ç”Ÿæˆæ•Œäºº - å¢å¼ºéšæ—¶é—´çš„æå‡
        function spawnEnemy() {
            if (game.bossActive) return; // Bossæˆ˜æœŸé—´ä¸ç”Ÿæˆæ™®é€šæ•Œäºº
            
            const now = Date.now();
            if (now - game.lastEnemySpawn > game.enemySpawnInterval) {
                const minutes = Math.floor(game.survivalTime / 60);
                // æ•Œäººæ•°é‡éšæ—¶é—´æ˜¾è‘—å¢åŠ 
                const spawnCount = Math.min(1 + Math.floor(minutes / 1.5), 5);
                
                for (let i = 0; i < spawnCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 400 + Math.random() * 200;
                    
                    const x = game.player.x + Math.cos(angle) * distance;
                    const y = game.player.y + Math.sin(angle) * distance;
                    
                    // å¢åŠ æ•Œäººç§ç±»çš„ç”Ÿæˆæ¦‚ç‡
                    let enemyType = 'basic';
                    const rand = Math.random();
                    
                    if (game.wave >= 2) {
                        if (rand < 0.08) enemyType = 'tank';
                        else if (rand < 0.18) enemyType = 'gunner';
                        else if (rand < 0.35) enemyType = 'fast';
                        else if (rand < 0.45) enemyType = 'sniper';
                        else if (rand < 0.55) enemyType = 'bomber';
                        else if (rand < 0.65) enemyType = 'shield';
                        else if (rand < 0.75) enemyType = 'healer';
                    }
                    
                    const baseStats = enemyTypes[enemyType];
                    // å¤§å¹…å¢å¼ºéšæ—¶é—´çš„æå‡
                    const timeMultiplier = 1 + Math.floor(game.survivalTime / 180); // æ¯3åˆ†é’Ÿç¿»å€
                    
                    game.enemies.push({
                        x: x, y: y,
                        type: enemyType,
                        size: baseStats.size,
                        speed: Math.round((baseStats.speed * (0.8 + timeMultiplier * 0.3)) * 10) / 10,
                        health: Math.floor(baseStats.health * timeMultiplier),
                        maxHealth: Math.floor(baseStats.health * timeMultiplier),
                        damage: Math.floor(baseStats.damage * timeMultiplier),
                        shootInterval: baseStats.shootInterval,
                        lastShot: 0,
                        expReward: Math.floor(baseStats.expReward * timeMultiplier),
                        poisoned: false,
                        poisonDamage: 0,
                        poisonDuration: 0,
                        lastPoisonTick: 0,
                        frozen: false,
                        freezeDuration: 0,
                        originalSpeed: Math.round((baseStats.speed * (0.8 + timeMultiplier * 0.3)) * 10) / 10,
                        explodeOnDeath: baseStats.explodeOnDeath || false,
                        hasShield: baseStats.hasShield || false,
                        healOthers: baseStats.healOthers || false,
                        lastHeal: 0
                    });
                }
                
                game.lastEnemySpawn = now;
                // ç”Ÿæˆé—´éš”ä¹Ÿéšæ—¶é—´å‡å°‘
                game.enemySpawnInterval = Math.max(300, 1500 - minutes * 50);
            }
        }
        
        // Boss AI - ç®€åŒ–ç§»åŠ¨é€»è¾‘
        function updateBoss() {
            if (!game.boss || game.bossPhase !== 'active') return;
            
            const now = Date.now();
            const boss = game.boss;
            
            // æ›´æ–°å†°å†»çŠ¶æ€
            if (boss.frozen) {
                boss.freezeDuration--;
                if (boss.freezeDuration <= 0) {
                    boss.frozen = false;
                    boss.speed = boss.originalSpeed;
                }
            }
            
            // ç®€å•çš„è¿½è¸ªç§»åŠ¨
            const dx = game.player.x - boss.x;
            const dy = game.player.y - boss.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // ä¿æŒä¸€å®šè·ç¦»
            if (distance > 120) {
                boss.x += (dx / distance) * boss.speed;
                boss.y += (dy / distance) * boss.speed;
            } else if (distance < 80) {
                boss.x -= (dx / distance) * boss.speed * 0.5;
                boss.y -= (dy / distance) * boss.speed * 0.5;
            }
            
            // é™åˆ¶åœ¨ç«æŠ€åœºå†…
            constrainToArena(boss);
            
            // å°„å‡»
            if (now - boss.lastShot > boss.shootInterval) {
                if (boss.abilities.includes('multishot')) {
                    // å¤šé‡å°„å‡»
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(dy, dx) + (i - 2) * 0.3;
                        game.enemyBullets.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            damage: boss.damage,
                            size: 5
                        });
                    }
                } else {
                    // æ™®é€šå°„å‡»
                    const bulletSpeed = 4;
                    game.enemyBullets.push({
                        x: boss.x,
                        y: boss.y,
                        vx: (dx / distance) * bulletSpeed,
                        vy: (dy / distance) * bulletSpeed,
                        damage: boss.damage,
                        size: 5
                    });
                }
                boss.lastShot = now;
            }
            
            // ç‰¹æ®Šèƒ½åŠ›
            if (now - boss.lastAbility > boss.abilityInterval) {
                const ability = boss.abilities[Math.floor(Math.random() * boss.abilities.length)];
                
                if (ability === 'summon') {
                    // å¬å”¤å°æ€ª
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDistance = 100;
                        
                        const spawnX = boss.x + Math.cos(angle) * spawnDistance;
                        const spawnY = boss.y + Math.sin(angle) * spawnDistance;
                        
                        game.enemies.push({
                            x: spawnX,
                            y: spawnY,
                            type: 'basic',
                            size: 15,
                            speed: 2,
                            health: 20,
                            maxHealth: 20,
                            damage: 1,
                            shootInterval: 0,
                            lastShot: 0,
                            expReward: 10,
                            poisoned: false,
                            poisonDamage: 0,
                            poisonDuration: 0,
                            lastPoisonTick: 0,
                            frozen: false,
                            freezeDuration: 0,
                            originalSpeed: 2,
                            explodeOnDeath: false,
                            hasShield: false,
                            healOthers: false,
                            lastHeal: 0
                        });
                    }
                } else if (ability === 'charge') {
                    // å†²é”‹æ”»å‡» - çŸ­æš‚æé€Ÿ
                    const originalSpeed = boss.speed;
                    boss.speed *= 2;
                    setTimeout(() => {
                        if (boss) boss.speed = originalSpeed;
                    }, 1500);
                } else if (ability === 'teleport') {
                    // ä¼ é€åˆ°ç©å®¶é™„è¿‘çš„å®‰å…¨ä½ç½®
                    const teleportAngle = Math.random() * Math.PI * 2;
                    const teleportDistance = 120;
                    boss.x = game.player.x + Math.cos(teleportAngle) * teleportDistance;
                    boss.y = game.player.y + Math.sin(teleportAngle) * teleportDistance;
                    constrainToArena(boss);
                } else if (ability === 'heal') {
                    // æ²»ç–—
                    boss.health = Math.min(boss.maxHealth, boss.health + Math.floor(boss.maxHealth * 0.1));
                }
                
                boss.lastAbility = now;
            }
            
            updateBossUI();
        }
        
        // å…‰å‰‘ä¼¤å®³æ£€æµ‹
        function checkLightsaberDamage() {
            if (!game.player.lightsaber) return;
            
            const now = Date.now();
            const damageInterval = 200;
            
            // å¯¹æ™®é€šæ•Œäºº
            game.enemies.forEach(enemy => {
                const dx = enemy.x - game.player.x;
                const dy = enemy.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 55) {
                    if (!enemy.lastLightsaberDamage || now - enemy.lastLightsaberDamage > damageInterval) {
                        enemy.health -= Math.floor(game.player.lightsaber.damage / 5);
                        enemy.lastLightsaberDamage = now;
                        
                        createParticles(enemy.x, enemy.y, '#00E5FF', 2);
                    }
                }
            });
            
            // å¯¹Boss
            if (game.boss) {
                const dx = game.boss.x - game.player.x;
                const dy = game.boss.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 70) {
                    if (!game.boss.lastLightsaberDamage || now - game.boss.lastLightsaberDamage > damageInterval) {
                        game.boss.health -= Math.floor(game.player.lightsaber.damage / 5);
                        game.boss.lastLightsaberDamage = now;
                        
                        createParticles(game.boss.x, game.boss.y, '#00E5FF', 3);
                    }
                }
            }
        }
        
        // ç§»åŠ¨æ•Œäºº
        function moveEnemies() {
            game.enemies.forEach(enemy => {
                // æ›´æ–°å†°å†»çŠ¶æ€
                if (enemy.frozen) {
                    enemy.freezeDuration--;
                    if (enemy.freezeDuration <= 0) {
                        enemy.frozen = false;
                        enemy.speed = enemy.originalSpeed;
                    }
                }
                
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                // é™åˆ¶åœ¨ç«æŠ€åœºå†…
                if (game.bossActive) {
                    constrainToArena(enemy);
                }
                
                // ç‰¹æ®Šæ•Œäººè¡Œä¸º
                const now = Date.now();
                
                // æªæ‰‹å’Œç‹™å‡»æ‰‹å°„å‡»
                if ((enemy.type === 'gunner' || enemy.type === 'sniper') && enemy.shootInterval > 0) {
                    if (now - enemy.lastShot > enemy.shootInterval && distance < 300) {
                        const bulletSpeed = enemy.type === 'sniper' ? 6 : 5;
                        game.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (dx / distance) * bulletSpeed,
                            vy: (dy / distance) * bulletSpeed,
                            damage: enemy.damage,
                            size: enemy.type === 'sniper' ? 4 : 3
                        });
                        enemy.lastShot = now;
                    }
                }
                
                // æ²»ç–—å…µæ²»ç–—å…¶ä»–æ•Œäºº
                if (enemy.healOthers && now - enemy.lastHeal > 3000) {
                    game.enemies.forEach(otherEnemy => {
                        if (otherEnemy !== enemy) {
                            const healDist = Math.sqrt(
                                Math.pow(enemy.x - otherEnemy.x, 2) + 
                                Math.pow(enemy.y - otherEnemy.y, 2)
                            );
                            if (healDist < 80 && otherEnemy.health < otherEnemy.maxHealth) {
                                otherEnemy.health = Math.min(otherEnemy.maxHealth, otherEnemy.health + 10);
                                createParticles(otherEnemy.x, otherEnemy.y, '#4CAF50', 3);
                            }
                        }
                    });
                    enemy.lastHeal = now;
                }
                
                // å¤„ç†ä¸­æ¯’æ•ˆæœ
                if (enemy.poisoned) {
                    if (now - enemy.lastPoisonTick > 1000) {
                        enemy.health -= enemy.poisonDamage;
                        enemy.lastPoisonTick = now;
                        enemy.poisonDuration--;
                        
                        // ä¸­æ¯’ä¼ æŸ“
                        if (game.player.poison && game.player.poison.contagious) {
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && !otherEnemy.poisoned) {
                                    const dist = Math.sqrt(
                                        Math.pow(enemy.x - otherEnemy.x, 2) + 
                                        Math.pow(enemy.y - otherEnemy.y, 2)
                                    );
                                    if (dist < game.player.poison.range) {
                                        otherEnemy.poisoned = true;
                                        otherEnemy.poisonDamage = game.player.poison.damage;
                                        otherEnemy.poisonDuration = game.player.poison.duration;
                                        otherEnemy.lastPoisonTick = now;
                                    }
                                }
                            });
                        }
                        
                        if (enemy.poisonDuration <= 0) {
                            enemy.poisoned = false;
                        }
                    }
                }
            });
        }
        
        // ç§»åŠ¨æ•Œäººå­å¼¹
        function moveEnemyBullets() {
            game.enemyBullets = game.enemyBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                const dx = bullet.x - game.player.x;
                const dy = bullet.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < bullet.size + game.player.size) {
                    // é˜²æ­¢è¿ç»­ä¼¤å®³
                    const now = Date.now();
                    if (!game.player.lastDamageTime || now - game.player.lastDamageTime > 500) {
                        game.player.health -= bullet.damage;
                        game.player.lastDamageTime = now;
                        updateUI();
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                    }
                    return false;
                }
                
                const playerDist = Math.sqrt(
                    Math.pow(bullet.x - game.player.x, 2) + 
                    Math.pow(bullet.y - game.player.y, 2)
                );
                return playerDist < 800;
            });
        }
        
        // è‡ªåŠ¨å°„å‡»
        function autoShoot() {
            const now = Date.now();
            if (now - game.player.lastShot > game.player.shootInterval) {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                // ä¼˜å…ˆæ”»å‡»Boss
                if (game.boss) {
                    const dx = game.boss.x - game.player.x;
                    const dy = game.boss.y - game.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    nearestEnemy = game.boss;
                    nearestDistance = distance;
                }
                
                // å¦‚æœæ²¡æœ‰Bossæˆ–Bossè·ç¦»å¤ªè¿œï¼Œæ”»å‡»æ™®é€šæ•Œäºº
                if (!nearestEnemy || nearestDistance > 400) {
                    game.enemies.forEach(enemy => {
                        const dx = enemy.x - game.player.x;
                        const dy = enemy.y - game.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });
                }
                
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - game.player.x;
                    const dy = nearestEnemy.y - game.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const baseAngle = Math.atan2(dy, dx);
                    
                    // å¹³è¡Œå¤šé‡å°„å‡»
                    for (let i = 0; i < game.player.multishot; i++) {
                        const offset = (i - (game.player.multishot - 1) / 2) * 12;
                        const perpAngle = baseAngle + Math.PI / 2;
                        
                        const startX = game.player.x + Math.cos(perpAngle) * offset;
                        const startY = game.player.y + Math.sin(perpAngle) * offset;
                        
                        game.bullets.push({
                            x: startX,
                            y: startY,
                            vx: Math.cos(baseAngle) * 10,
                            vy: Math.sin(baseAngle) * 10,
                            size: 5,
                            damage: game.player.damage,
                            penetration: game.player.penetration,
                            hitEnemies: []
                        });
                    }
                    
                    game.player.lastShot = now;
                }
            }
        }
        
        // ç§»åŠ¨å­å¼¹
        function moveBullets() {
            game.bullets = game.bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                const dx = bullet.x - game.player.x;
                const dy = bullet.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < 800;
            });
        }
        
        // åˆ›å»ºæ‰è½ç‰©
        function createDrop(x, y, enemy) {
            const rand = Math.random();
            
            if (rand < 0.05) {
                game.expOrbs.push({
                    x: x, y: y, size: 15, exp: enemy.expReward * 3,
                    type: 'big', collected: false
                });
            } else if (rand < 0.08) {
                // ç£é“æ‰è½ç‰©
                game.pickups.push({
                    x: x, y: y, size: 12, type: 'magnet'
                });
            } else if (rand < 0.11) {
                // è¡€åŒ…æ‰è½ç‰©
                game.pickups.push({
                    x: x, y: y, size: 12, type: 'health'
                });
            } else {
                game.expOrbs.push({
                    x: x, y: y, size: 8, exp: enemy.expReward,
                    type: 'normal', collected: false
                });
            }
        }
        
        // é›·ç”µé“¾æ•ˆæœ
        function createLightningEffect(x, y, damage) {
            const targets = [...game.enemies];
            if (game.boss) targets.push(game.boss);
            
            targets.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && distance > 0) {
                    enemy.health -= damage;
                    
                    game.effects.push({
                        type: 'lightning',
                        x1: x, y1: y,
                        x2: enemy.x, y2: enemy.y,
                        duration: 200,
                        startTime: Date.now()
                    });
                }
            });
        }
        
        // çˆ†ç‚¸æ•ˆæœ
        function createExplosion(x, y, damage) {
            const targets = [...game.enemies];
            if (game.boss) targets.push(game.boss);
            
            targets.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    enemy.health -= damage;
                }
            });
            
            game.effects.push({
                type: 'explosion',
                x: x, y: y, radius: 0, maxRadius: 80,
                duration: 300, startTime: Date.now()
            });
        }
        
        // ç¢°æ’æ£€æµ‹
        function checkCollisions() {
            game.bullets.forEach((bullet, bulletIndex) => {
                const targets = [...game.enemies];
                if (game.boss) targets.push(game.boss);
                
                targets.forEach((enemy, enemyIndex) => {
                    if (bullet.hitEnemies.includes(enemy)) return;
                    
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.size + enemy.size) {
                        enemy.health -= bullet.damage;
                        bullet.hitEnemies.push(enemy);
                        
                        createParticles(enemy.x, enemy.y, '#FFD700', 3);
                        
                        if (game.player.lightning > 0) {
                            createLightningEffect(enemy.x, enemy.y, game.player.lightning);
                        }
                        
                        if (game.player.poison) {
                            enemy.poisoned = true;
                            enemy.poisonDamage = game.player.poison.damage;
                            enemy.poisonDuration = game.player.poison.duration;
                            enemy.lastPoisonTick = Date.now();
                        }
                        
                        if (game.player.freeze) {
                            enemy.frozen = true;
                            enemy.freezeDuration = game.player.freeze.duration * 60; // è½¬æ¢ä¸ºå¸§æ•°
                            enemy.speed = Math.round((enemy.originalSpeed * (1 - game.player.freeze.slowPercent / 100)) * 10) / 10;
                        }
                        
                        if (game.player.explosion > 0) {
                            createExplosion(enemy.x, enemy.y, game.player.explosion);
                        }
                        
                        if (bullet.penetration <= 0) {
                            game.bullets.splice(bulletIndex, 1);
                        } else {
                            bullet.penetration--;
                        }
                        
                        if (enemy.health <= 0) {
                            if (game.player.vampire > 0) {
                                game.player.health = Math.min(game.player.maxHealth, 
                                    game.player.health + game.player.vampire);
                            }
                            
                            // çˆ†ç ´å…µæ­»äº¡çˆ†ç‚¸
                            if (enemy.explodeOnDeath) {
                                createExplosion(enemy.x, enemy.y, 30);
                            }
                            
                            if (enemy === game.boss) {
                                defeatBoss();
                            } else {
                                createDrop(enemy.x, enemy.y, enemy);
                                game.enemies.splice(enemyIndex, 1);
                                game.player.kills++;
                                game.waveKills++;
                                
                                if (game.waveKills >= game.waveTarget) {
                                    game.wave++;
                                    game.waveKills = 0;
                                    game.waveTarget = Math.floor(game.waveTarget * 1.3);
                                    game.enemySpawnInterval = Math.max(400, game.enemySpawnInterval - 50);
                                }
                            }
                            
                            updateUI();
                        }
                    }
                });
            });
            
            // ç©å®¶ä¸æ•Œäººç¢°æ’ - æ·»åŠ ä¼¤å®³é—´éš”
            const allEnemies = [...game.enemies];
            if (game.boss) allEnemies.push(game.boss);
            
            allEnemies.forEach(enemy => {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + enemy.size) {
                    const now = Date.now();
                    if (!game.player.lastContactDamage || now - game.player.lastContactDamage > 1000) {
                        game.player.health -= enemy.damage;
                        game.player.lastContactDamage = now;
                        updateUI();
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
            
            // æ‰©å¤§ç£é“å¸é™„èŒƒå›´
            const magnetMultiplier = game.buffs.find(b => b.type === 'magnet')?.multiplier || 1;
            const pickupRange = game.player.pickupRange * magnetMultiplier * 2; // æ‰©å¤§2å€
            
            // ç»éªŒçƒç¢°æ’
            game.expOrbs.forEach((orb, index) => {
                const dx = game.player.x - orb.x;
                const dy = game.player.y - orb.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + orb.size + pickupRange) {
                    game.player.exp += orb.exp;
                    game.expOrbs.splice(index, 1);
                    
                    // ä¿®å¤å¤§ç»éªŒçƒç‰¹æ•ˆé¢œè‰²
                    if (orb.type === 'big') {
                        createParticles(orb.x, orb.y, '#FFD700', 8);
                    } else {
                        createParticles(orb.x, orb.y, '#00BCD4', 5);
                    }
                    
                    if (game.player.exp >= game.player.maxExp) {
                        levelUp();
                    }
                    
                    updateUI();
                }
            });
            
            // æ‹¾å–ç‰©å“ç¢°æ’
            game.pickups.forEach((pickup, index) => {
                const dx = game.player.x - pickup.x;
                const dy = game.player.y - pickup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + pickup.size + pickupRange) {
                    if (pickup.type === 'magnet') {
                        // ç£é“æ•ˆæœ
                        const existingMagnet = game.buffs.find(b => b.type === 'magnet');
                        if (existingMagnet) {
                            // é‡ç½®æ—¶é—´
                            existingMagnet.startTime = Date.now();
                        } else {
                            // æ–°å¢ç£é“æ•ˆæœ
                            game.buffs.push({
                                type: 'magnet',
                                duration: 10000,
                                startTime: Date.now(),
                                multiplier: 5 // å¢åŠ ç£é“æ•ˆæœå€æ•°
                            });
                        }
                        
                        createParticles(pickup.x, pickup.y, '#FFD700', 8);
                        
                    } else if (pickup.type === 'health') {
                        // è¡€åŒ…æ•ˆæœ
                        const healAmount = 30;
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                        
                        createParticles(pickup.x, pickup.y, '#F44336', 8);
                        
                        // æ˜¾ç¤ºæ²»ç–—æ•ˆæœ
                        game.effects.push({
                            type: 'heal_text',
                            x: pickup.x, y: pickup.y,
                            duration: 1000,
                            startTime: Date.now(),
                            amount: healAmount
                        });
                    }
                    
                    game.pickups.splice(index, 1);
                    updateBuffsDisplay();
                    updateUI();
                }
            });
        }
        
        // æ›´æ–°å¢ç›Šæ•ˆæœ
        function updateBuffs() {
            const now = Date.now();
            game.buffs = game.buffs.filter(buff => {
                return (now - buff.startTime) < buff.duration;
            });
        }
        
        // æ›´æ–°ç²’å­æ•ˆæœ
        function updateParticles() {
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                return particle.life > 0;
            });
        }
        
        // å‡çº§
        function levelUp() {
            game.player.level++;
            game.player.exp -= game.player.maxExp;
            game.player.maxExp = Math.floor(100 * Math.pow(1.4, game.player.level - 1));
            
            game.paused = true;
            showSkillModal();
        }
        
        // æ˜¾ç¤ºæŠ€èƒ½é€‰æ‹©ç•Œé¢
        function showSkillModal() {
            const modal = document.getElementById('skillModal');
            const grid = document.getElementById('skillGrid');
            
            grid.innerHTML = '';
            
            // è·å–å¯å‡çº§çš„æŠ€èƒ½
            const availableSkills = Object.keys(skillDefinitions).filter(skill => {
                const currentLevel = game.player.skills[skill] || 0;
                return currentLevel < skillDefinitions[skill].maxLevel;
            });
            
            // å¦‚æœæ‰€æœ‰æŠ€èƒ½éƒ½æ»¡çº§ï¼Œè§¦å‘å®Œç¾ç»“å±€
            if (availableSkills.length === 0) {
                modal.style.display = 'none';
                game.paused = false;
                checkPerfectEnding();
                return;
            }
            
            const selectedSkills = [];
            const maxOptions = Math.min(3, availableSkills.length);
            
            while (selectedSkills.length < maxOptions && availableSkills.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableSkills.length);
                const skill = availableSkills[randomIndex];
                selectedSkills.push(skill);
                availableSkills.splice(randomIndex, 1);
            }
            
            selectedSkills.forEach(skillKey => {
                const skill = skillDefinitions[skillKey];
                const currentLevel = game.player.skills[skillKey] || 0;
                const nextLevel = currentLevel + 1;
                
                const option = document.createElement('div');
                option.className = `skill-option ${nextLevel === 5 ? 'max-level' : ''}`;
                option.onclick = () => selectSkill(skillKey);
                
                option.innerHTML = `
                    <div class="skill-icon" style="background: ${skill.color}">
                        ${nextLevel === 5 ? 'ğŸ‘‘' : skill.icon}
                    </div>
                    <div class="skill-info">
                        <strong>${skill.name}</strong><br>
                        ${skill.description(nextLevel)}
                        ${nextLevel === 5 ? '<br><span style="color: gold;">â˜… æ»¡çº§å¼ºåŒ– â˜…</span>' : ''}
                    </div>
                    <div class="skill-level">Lv.${nextLevel}</div>
                `;
                
                grid.appendChild(option);
            });
            
            modal.style.display = 'block';
        }
        
        // é€‰æ‹©æŠ€èƒ½
        function selectSkill(skillKey) {
            const skill = skillDefinitions[skillKey];
            const currentLevel = game.player.skills[skillKey] || 0;
            const newLevel = currentLevel + 1;
            
            game.player.skills[skillKey] = newLevel;
            
            const effect = skill.effect(newLevel);
            
            Object.keys(effect).forEach(key => {
                if (key === 'healFull') {
                    game.player.health = game.player.maxHealth;
                } else if (key === 'shootInterval') {
                    game.player.shootInterval = Math.max(100, game.player.shootInterval + effect[key]);
                } else if (key === 'poison') {
                    game.player.poison = effect[key];
                } else if (key === 'lightsaber') {
                    game.player.lightsaber = effect[key];
                } else if (key === 'freeze') {
                    game.player.freeze = effect[key];
                } else if (key === 'multishot') {
                    game.player.multishot = effect[key];
                } else {
                    if (typeof effect[key] === 'number') {
                        game.player[key] = Math.round(((game.player[key] || 0) + effect[key]) * 10) / 10;
                    } else {
                        game.player[key] = (game.player[key] || 0) + effect[key];
                    }
                }
            });
            
            document.getElementById('skillModal').style.display = 'none';
            game.paused = false;
            updateUI();
            updateSkillsDisplay();
        }
        
        // æ›´æ–°æŠ€èƒ½æ˜¾ç¤º
        function updateSkillsDisplay() {
            const list = document.getElementById('activeSkillsList');
            list.innerHTML = '';
            
            Object.keys(game.player.skills).forEach(skillKey => {
                const skill = skillDefinitions[skillKey];
                const level = game.player.skills[skillKey];
                
                const div = document.createElement('div');
                div.className = 'active-skill';
                div.innerHTML = `
                    <div class="skill-icon" style="background: ${skill.color}">
                        ${level === 5 ? 'ğŸ‘‘' : skill.icon}
                    </div>
                    ${skill.name} Lv.${level}
                `;
                list.appendChild(div);
            });
        }
        
        // æ›´æ–°å¢ç›Šæ˜¾ç¤º
        function updateBuffsDisplay() {
            const list = document.getElementById('buffsList');
            list.innerHTML = '';
            
            game.buffs.forEach(buff => {
                const remaining = Math.ceil((buff.duration - (Date.now() - buff.startTime)) / 1000);
                
                const div = document.createElement('div');
                div.className = 'buff-item';
                
                if (buff.type === 'magnet') {
                    div.innerHTML = `ğŸ§² ç£é“æ•ˆæœ ${remaining}s`;
                }
                
                list.appendChild(div);
            });
        }
        
        // æ›´æ–°UI
        function updateUI() {
            if (!game.gameOver) {
                game.survivalTime = Math.floor((Date.now() - game.startTime) / 1000);
            }
            
            document.getElementById('level').textContent = game.player.level;
            document.getElementById('health').textContent = Math.max(0, Math.floor(game.player.health));
            document.getElementById('kills').textContent = game.player.kills;
            document.getElementById('wave').textContent = game.wave;
            document.getElementById('survivalTime').textContent = formatTime(game.survivalTime);
            document.getElementById('exp').textContent = game.player.exp;
            document.getElementById('maxExp').textContent = game.player.maxExp;
            
            // ä¸‹ä¸ªBosså€’è®¡æ—¶
            const timeSinceLastBoss = game.survivalTime - game.lastBossTime;
            const timeToNextBoss = Math.max(0, 180 - timeSinceLastBoss);
            document.getElementById('nextBoss').textContent = formatTime(timeToNextBoss);
            
            const expPercent = (game.player.exp / game.player.maxExp) * 100;
            document.getElementById('expFill').style.width = expPercent + '%';
        }
        
        // ç»˜åˆ¶ç‰¹æ•ˆ
        function drawEffects() {
            const now = Date.now();
            
            game.effects = game.effects.filter(effect => {
                const elapsed = now - effect.startTime;
                const progress = elapsed / effect.duration;
                
                if (progress >= 1) return false;
                
                if (effect.type === 'lightning') {
                    const screenX1 = effect.x1 - world.x;
                    const screenY1 = effect.y1 - world.y;
                    const screenX2 = effect.x2 - world.x;
                    const screenY2 = effect.y2 - world.y;
                    
                    ctx.strokeStyle = `rgba(255, 255, 0, ${1 - progress})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX1, screenY1);
                    ctx.lineTo(screenX2, screenY2);
                    ctx.stroke();
                } else if (effect.type === 'explosion') {
                    const screenX = effect.x - world.x;
                    const screenY = effect.y - world.y;
                    
                    effect.radius = effect.maxRadius * progress;
                    
                    ctx.strokeStyle = `rgba(255, 100, 0, ${1 - progress})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (effect.type === 'heal_text') {
                    const screenX = effect.x - world.x;
                    const screenY = effect.y - world.y;
                    
                    ctx.fillStyle = `rgba(76, 175, 80, ${1 - progress})`;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`+${effect.amount}`, screenX, screenY - progress * 40);
                }
                
                return true;
            });
        }
        
        // ç»˜åˆ¶ç²’å­
        function drawParticles() {
            game.particles.forEach(particle => {
                const r = parseInt(particle.color.slice(1, 3), 16);
                const g = parseInt(particle.color.slice(3, 5), 16);
                const b = parseInt(particle.color.slice(5, 7), 16);
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.life})`;
                ctx.beginPath();
                ctx.arc(particle.x - world.x, particle.y - world.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // ç»˜åˆ¶å‡½æ•° - è°ƒæ•´ç»˜åˆ¶é¡ºåº
        function draw() {
            animationTime += 16;
            
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼èƒŒæ™¯
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = (-world.x % gridSize);
            const startY = (-world.y % gridSize);
            
            for (let x = startX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // ç»˜åˆ¶ç«æŠ€åœºè¾¹ç•Œ
            drawArenaBorder();
            
            // å…ˆç»˜åˆ¶ç»éªŒçƒï¼ˆåœ¨æ•Œäººä¸‹æ–¹ï¼‰
            game.expOrbs.forEach(orb => {
                const screenX = orb.x - world.x;
                const screenY = orb.y - world.y;
                
                if (screenX > -30 && screenX < canvas.width + 30 && 
                    screenY > -30 && screenY < canvas.height + 30) {
                    drawExpOrb(orb, screenX, screenY);
                }
            });
            
            // ç»˜åˆ¶æ‹¾å–ç‰©å“ï¼ˆåœ¨æ•Œäººä¸‹æ–¹ï¼‰
            game.pickups.forEach(pickup => {
                const screenX = pickup.x - world.x;
                const screenY = pickup.y - world.y;
                
                if (screenX > -30 && screenX < canvas.width + 30 && 
                    screenY > -30 && screenY < canvas.height + 30) {
                    drawPickup(pickup, screenX, screenY);
                }
            });
            
            // ç»˜åˆ¶æ•Œäºº
            game.enemies.forEach(enemy => {
                const screenX = enemy.x - world.x;
                const screenY = enemy.y - world.y;
                
                if (screenX > -60 && screenX < canvas.width + 60 && 
                    screenY > -60 && screenY < canvas.height + 60) {
                    
                    drawEnemy(enemy, screenX, screenY);
                    
                    // æ•Œäººç”Ÿå‘½å€¼æ¡ - å›ºå®šé•¿åº¦
                    const enemyHealthPercent = Math.max(0, enemy.health / enemy.maxHealth);
                    const enemyBarWidth = 50; // å›ºå®šå®½åº¦
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX - enemyBarWidth/2, screenY - enemy.size - 30, enemyBarWidth, 5);
                    ctx.fillStyle = enemy.poisoned ? '#4CAF50' : (enemy.frozen ? '#00BFFF' : enemyTypes[enemy.type].color);
                    ctx.fillRect(screenX - enemyBarWidth/2, screenY - enemy.size - 30, enemyBarWidth * enemyHealthPercent, 5);
                }
            });
            
            // ç»˜åˆ¶Boss
            if (game.boss) {
                const bossScreenX = game.boss.x - world.x;
                const bossScreenY = game.boss.y - world.y;
                
                if (bossScreenX > -100 && bossScreenX < canvas.width + 100 && 
                    bossScreenY > -100 && bossScreenY < canvas.height + 100) {
                    
                    drawBoss(game.boss, bossScreenX, bossScreenY);
                    
                    // Bossç”Ÿå‘½å€¼æ¡ - å›ºå®šé•¿åº¦
                    const bossHealthPercent = Math.max(0, game.boss.health / game.boss.maxHealth);
                    const bossBarWidth = 80; // å›ºå®šå®½åº¦
                    ctx.fillStyle = '#333';
                    ctx.fillRect(bossScreenX - bossBarWidth/2, bossScreenY - game.boss.size - 40, bossBarWidth, 8);
                    ctx.fillStyle = game.boss.frozen ? '#00BFFF' : '#F44336';
                    ctx.fillRect(bossScreenX - bossBarWidth/2, bossScreenY - game.boss.size - 40, bossBarWidth * bossHealthPercent, 8);
                }
            }
            
            // ç»˜åˆ¶ç©å®¶
            const playerScreenX = game.player.x - world.x;
            const playerScreenY = game.player.y - world.y;
            
            drawPlayer(playerScreenX, playerScreenY);
            
            // ç»˜åˆ¶ç©å®¶ç”Ÿå‘½å€¼æ¡
            const barWidth = 60;
            const barHeight = 8;
            const healthPercent = Math.max(0, game.player.health / game.player.maxHealth);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(playerScreenX - barWidth/2, playerScreenY - game.player.size - 30, barWidth, barHeight);
            ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FFC107' : '#F44336';
            ctx.fillRect(playerScreenX - barWidth/2, playerScreenY - game.player.size - 30, barWidth * healthPercent, barHeight);
            
            // ç»˜åˆ¶å­å¼¹
            game.bullets.forEach(bullet => {
                const screenX = bullet.x - world.x;
                const screenY = bullet.y - world.y;
                
                if (screenX > -20 && screenX < canvas.width + 20 && 
                    screenY > -20 && screenY < canvas.height + 20) {
                    drawBullet(bullet, screenX, screenY);
                }
            });
            
            // ç»˜åˆ¶æ•Œäººå­å¼¹
            game.enemyBullets.forEach(bullet => {
                const screenX = bullet.x - world.x;
                const screenY = bullet.y - world.y;
                
                if (screenX > -10 && screenX < canvas.width + 10 && 
                    screenY > -10 && screenY < canvas.height + 10) {
                    ctx.fillStyle = '#FF4444';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // ç»˜åˆ¶ç‰¹æ•ˆå’Œç²’å­
            drawEffects();
            drawParticles();
        }
        
        // æ¸¸æˆä¸»å¾ªç¯
        function gameLoop() {
            if (!game.paused && !game.gameOver && gameStarted) {
                movePlayer();
                checkBossSpawn();
                if (game.bossActive) {
                    updateBoss();
                } else {
                    spawnEnemy();
                }
                moveEnemies();
                moveEnemyBullets();
                autoShoot();
                moveBullets();
                checkCollisions();
                checkLightsaberDamage();
                updateBuffs();
                updateParticles();
                updateBuffsDisplay();
                updateUI();
            }
            
            if (gameStarted) {
                draw();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // çª—å£å¤§å°æ”¹å˜æ—¶è°ƒæ•´ç”»å¸ƒ
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (joystick.el) {
                joystick.rect = joystick.el.getBoundingClientRect();
            }
        });
        
        // åˆå§‹åŒ–
        gameLoop();
    </script>
</body>
</html>
