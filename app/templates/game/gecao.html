<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自动射击打怪游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #16213e, #0f3460);
            display: block;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
        }
        
        #expBar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            margin-top: 5px;
        }
        
        #expFill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        
        #pauseBtn {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #4CAF50;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            z-index: 100;
        }
        
        #pauseBtn:hover {
            background: #4CAF50;
        }
        
        #gameGuide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 500;
        }
        
        #guideContent {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 20px;
            border: 3px solid #4CAF50;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
        }
        
        .guide-section {
            margin: 20px 0;
            text-align: left;
        }
        
        .enemy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .enemy-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .enemy-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: bold;
        }
        
        #startGameBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #bossWarning {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            z-index: 250;
            display: none;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        
        #bossUI {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        #bossHealthBar {
            width: 400px;
            height: 20px;
            background: #333;
            border: 2px solid #fff;
            margin: 10px 0;
        }
        
        #bossHealthFill {
            height: 100%;
            background: linear-gradient(90deg, #F44336, #FF5722);
            width: 100%;
            transition: width 0.3s;
        }
        
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        
        #gameOverContent {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #F44336;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        #gameOverContent h1 {
            color: #F44336;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        #gameOverContent.perfect h1 {
            color: #FFD700;
            background: linear-gradient(45deg, #FFD700, #FFA000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        #gameOverContent p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }
        
        #restartBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        #skillModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #4CAF50;
            display: none;
            z-index: 200;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #skillGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .skill-option {
            display: flex;
            align-items: center;
            padding: 15px;
            background: #333;
            border: 2px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s;
            position: relative;
        }
        
        .skill-option:hover {
            background: #4CAF50;
            border-color: #4CAF50;
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }
        
        .skill-option.max-level {
            background: linear-gradient(45deg, #FFD700, #FFA000);
            border-color: #FFD700;
            color: #000;
        }
        
        .skill-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
        }
        
        .skill-info {
            flex: 1;
        }
        
        .skill-level {
            position: absolute;
            top: 5px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 14px;
            opacity: 0.8;
        }
        
        #skillsDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            max-width: 200px;
        }
        
        .active-skill {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .active-skill .skill-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            font-size: 12px;
        }
        
        #buffs {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
        }
        
        .buff-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .perfect-ending {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #FFD700, #FFA000);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
            z-index: 400;
            display: none;
        }

        /* Mobile joystick */
        #joystick {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 140px;
            height: 140px;
            z-index: 200;
            touch-action: none;
            display: none;
        }
        #joystick-base {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.06);
            border: 2px solid rgba(255, 255, 255, 0.15);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.4);
        }
        #joystick-thumb {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid #4CAF50;
            box-shadow: 0 0 12px rgba(76, 175, 80, 0.7);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameGuide">
            <div id="guideContent">
                <h1>🎮 自动射击打怪游戏 🎮</h1>
                
                <div class="guide-section">
                    <h2>🎯 游戏目标</h2>
                    <p>控制角色自动射击敌人，收集经验升级技能，击败Boss，尽可能存活更长时间！</p>
                </div>
                
                <div class="guide-section">
                    <h2>🎮 操作方式</h2>
                    <p>• WASD 或 方向键：移动角色</p>
                    <p>• 自动射击最近的敌人</p>
                    <p>• 靠近经验球和道具自动拾取</p>
                    <p>• 空格键：暂停/继续游戏</p>
                </div>
                
                <div class="guide-section">
                    <h2>👾 敌人图鉴</h2>
                    <div class="enemy-grid">
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #F44336;">🔴</div>
                            <h4>基础敌人</h4>
                            <p>最常见的敌人，血量适中，近战攻击</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #795548;">🛡️</div>
                            <h4>重装兵</h4>
                            <p>血量很高，移动缓慢，高伤害</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #9C27B0;">🔫</div>
                            <h4>枪手</h4>
                            <p>远程射击，中等血量和速度</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #FF9800;">⚡</div>
                            <h4>快速兵</h4>
                            <p>移动很快，血量较低</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #607D8B;">🎯</div>
                            <h4>狙击手</h4>
                            <p>超远程高伤害射击</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #E91E63;">💥</div>
                            <h4>爆破兵</h4>
                            <p>死亡时爆炸，伤害周围敌人</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #3F51B5;">🛡️</div>
                            <h4>护盾兵</h4>
                            <p>拥有护盾，更难击杀</p>
                        </div>
                        <div class="enemy-card">
                            <div class="enemy-icon" style="background: #4CAF50;">❤️</div>
                            <h4>治疗兵</h4>
                            <p>可以治疗其他敌人</p>
                        </div>
                    </div>
                </div>
                
                <div class="guide-section">
                    <h2>🏆 Boss战</h2>
                    <p>每3分钟会出现强大的Boss，击败后获得技能升级机会！</p>
                    <p>Boss会被困在红色竞技场内，使用各种特殊技能攻击。</p>
                </div>
                
                <div class="guide-section">
                    <h2>💎 道具系统</h2>
                    <p>🔵 蓝色经验球：普通经验值</p>
                    <p>🟡 黄色经验球：大量经验值</p>
                    <p>🧲 磁铁：增加拾取范围10秒</p>
                    <p>❤️ 血包：恢复30点生命值</p>
                </div>
                
                <div class="guide-section">
                    <h2>⚡ 技能系统</h2>
                    <p>升级时可选择3个技能之一进行强化，每个技能最高5级。</p>
                    <p>所有技能达到满级时触发完美结局！</p>
                </div>
                
                <button id="startGameBtn" onclick="startGame()">开始游戏</button>
            </div>
        </div>
        
        <button id="pauseBtn" onclick="togglePause()" style="display: none;">暂停</button>
        
        <div id="ui" style="display: none;">
            <div>等级: <span id="level">1</span></div>
            <div>生命值: <span id="health">100</span></div>
            <div>击杀数: <span id="kills">0</span></div>
            <div>波次: <span id="wave">1</span></div>
            <div>存活时间: <span id="survivalTime">0:00</span></div>
            <div>下个Boss: <span id="nextBoss">3:00</span></div>
            <div id="expBar">
                <div id="expFill"></div>
            </div>
            <div>经验: <span id="exp">0</span>/<span id="maxExp">100</span></div>
        </div>
        
        <div id="bossWarning">
            <h2>⚠️ BOSS来袭！ ⚠️</h2>
            <p>准备战斗！</p>
        </div>
        
        <div id="bossUI">
            <h3 id="bossName">Boss名称</h3>
            <div id="bossHealthBar">
                <div id="bossHealthFill"></div>
            </div>
            <div>Boss血量: <span id="bossHealth">1000</span>/<span id="bossMaxHealth">1000</span></div>
        </div>
        
        <div id="skillsDisplay" style="display: none;">
            <h4>当前技能</h4>
            <div id="activeSkillsList"></div>
        </div>
        
        <div id="buffs" style="display: none;">
            <h4>增益效果</h4>
            <div id="buffsList"></div>
        </div>
        
        <div id="gameOverScreen">
            <div id="gameOverContent">
                <h1>游戏结束</h1>
                <p>击杀数: <span id="finalKills">0</span></p>
                <p>存活时间: <span id="finalTime">0:00</span></p>
                <p>达到波次: <span id="finalWave">1</span></p>
                <p>最高等级: <span id="finalLevel">1</span></p>
                <p>击败Boss数: <span id="finalBosses">0</span></p>
                <button id="restartBtn" onclick="restartGame()">重新开始</button>
            </div>
        </div>
        
        <div id="perfectEnding" class="perfect-ending">
            <h1>🏆 十全十美 🏆</h1>
            <p>恭喜你！所有技能都已升级到满级！</p>
            <p>你已经达到了完美的境界！</p>
            <button onclick="restartGame()" style="background: #4CAF50; color: white; border: none; padding: 15px 30px; border-radius: 10px; cursor: pointer; margin-top: 20px;">重新挑战</button>
        </div>
        
        <div id="skillModal">
            <h3>选择技能升级！</h3>
            <div id="skillGrid"></div>
        </div>
        
        <div id="controls" style="display: none;">
            <div>WASD 或 方向键移动</div>
            <div>自动射击最近的敌人</div>
            <div>靠近经验球自动获取</div>
            <div>空格键暂停</div>
        </div>

        <!-- Mobile joystick (shown only on touch devices) -->
        <div id="joystick">
            <div id="joystick-base"></div>
            <div id="joystick-thumb"></div>
        </div>
    </div>

    <script>
        // 游戏变量
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const world = { x: 0, y: 0 };

        // 触屏检测与摇杆状态
        const isTouchDevice = () => ('ontouchstart' in window) || (navigator.maxTouchPoints || 0) > 0 || (navigator.msMaxTouchPoints || 0) > 0;
        const joystick = {
            active: false,
            dx: 0,
            dy: 0,
            magnitude: 0,
            pointerId: null,
            el: null,
            thumbEl: null,
            rect: null
        };

        function setupJoystick() {
            if (joystick.el && joystick.thumbEl) return; // already set
            joystick.el = document.getElementById('joystick');
            joystick.thumbEl = document.getElementById('joystick-thumb');
            if (!joystick.el || !joystick.thumbEl) return;

            const onPointerDown = (e) => {
                (e.preventDefault && e.preventDefault());
                joystick.active = true;
                joystick.pointerId = (e.pointerId !== undefined) ? e.pointerId : 'touch';
                joystick.rect = joystick.el.getBoundingClientRect();
                updateJoystickFromEvent(e);
            };

            const onPointerMove = (e) => {
                if (!joystick.active) return;
                if (e.pointerId !== undefined && joystick.pointerId !== null && e.pointerId !== joystick.pointerId) return;
                (e.preventDefault && e.preventDefault());
                updateJoystickFromEvent(e);
            };

            const onPointerUp = (e) => {
                if (e && e.pointerId !== undefined && joystick.pointerId !== null && e.pointerId !== joystick.pointerId) return;
                resetJoystick();
            };

            if (window.PointerEvent) {
                joystick.el.addEventListener('pointerdown', onPointerDown, { passive: false });
                window.addEventListener('pointermove', onPointerMove, { passive: false });
                window.addEventListener('pointerup', onPointerUp, { passive: true });
                window.addEventListener('pointercancel', onPointerUp, { passive: true });
            } else {
                joystick.el.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]), { passive: false });
                window.addEventListener('touchmove', (e) => onPointerMove(e.touches[0]), { passive: false });
                window.addEventListener('touchend', onPointerUp, { passive: true });
                window.addEventListener('touchcancel', onPointerUp, { passive: true });
            }
        }

        function updateJoystickFromEvent(e) {
            if (!joystick.el) return;
            if (!joystick.rect) joystick.rect = joystick.el.getBoundingClientRect();
            const cx = joystick.rect.left + joystick.rect.width / 2;
            const cy = joystick.rect.top + joystick.rect.height / 2;
            const clientX = e.clientX !== undefined ? e.clientX : 0;
            const clientY = e.clientY !== undefined ? e.clientY : 0;
            const x = clientX - cx;
            const y = clientY - cy;
            const r = joystick.rect.width / 2;
            const len = Math.sqrt(x * x + y * y);
            const clampedLen = Math.min(len, r);
            const nx = len > 0 ? (x / len) : 0;
            const ny = len > 0 ? (y / len) : 0;

            joystick.dx = nx;
            joystick.dy = ny;
            joystick.magnitude = clampedLen / r;

            const offsetX = nx * clampedLen * 0.9;
            const offsetY = ny * clampedLen * 0.9;
            joystick.thumbEl.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px)`;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.pointerId = null;
            joystick.dx = 0;
            joystick.dy = 0;
            joystick.magnitude = 0;
            if (joystick.thumbEl) {
                joystick.thumbEl.style.transform = 'translate(-50%, -50%)';
            }
        }
        
        // 游戏状态标记
        let gameStarted = false;
        let isRestart = false;
        
        // 敌人类型定义
        const enemyTypes = {
            basic: {
                name: "基础敌人",
                health: 30,
                speed: 1.5,
                size: 18,
                color: "#F44336",
                damage: 1,
                shootInterval: 0,
                expReward: 15
            },
            tank: {
                name: "重装兵",
                health: 120,
                speed: 0.8,
                size: 28,
                color: "#795548",
                damage: 3,
                shootInterval: 0,
                expReward: 40
            },
            gunner: {
                name: "枪手",
                health: 50,
                speed: 1.2,
                size: 20,
                color: "#9C27B0",
                damage: 2,
                shootInterval: 2500,
                expReward: 25
            },
            fast: {
                name: "快速兵",
                health: 20,
                speed: 2.5,
                size: 15,
                color: "#FF9800",
                damage: 1,
                shootInterval: 0,
                expReward: 12
            },
            sniper: {
                name: "狙击手",
                health: 40,
                speed: 0.6,
                size: 16,
                color: "#607D8B",
                damage: 4,
                shootInterval: 3000,
                expReward: 35
            },
            bomber: {
                name: "爆破兵",
                health: 60,
                speed: 1.0,
                size: 22,
                color: "#E91E63",
                damage: 5,
                shootInterval: 0,
                expReward: 30,
                explodeOnDeath: true
            },
            shield: {
                name: "护盾兵",
                health: 80,
                speed: 1.3,
                size: 20,
                color: "#3F51B5",
                damage: 2,
                shootInterval: 0,
                expReward: 28,
                hasShield: true
            },
            healer: {
                name: "治疗兵",
                health: 35,
                speed: 1.1,
                size: 17,
                color: "#4CAF50",
                damage: 1,
                shootInterval: 0,
                expReward: 32,
                healOthers: true
            }
        };
        
        // Boss定义 - 修正血量递增
        const bossTypes = {
            destroyer: {
                name: "毁灭者",
                health: 1000,
                speed: 1.0,
                size: 50,
                color: "#8E24AA",
                damage: 5,
                shootInterval: 1000,
                expReward: 500,
                abilities: ['shoot', 'summon']
            },
            colossus: {
                name: "巨像",
                health: 2000, // 从1800提升到2000
                speed: 0.8,
                size: 60,
                color: "#FF5722",
                damage: 8,
                shootInterval: 800,
                expReward: 750,
                abilities: ['shoot', 'charge', 'summon']
            },
            overlord: {
                name: "霸主",
                health: 3200, // 从2800提升到3200
                speed: 1.2,
                size: 55,
                color: "#3F51B5",
                damage: 10,
                shootInterval: 600,
                expReward: 1000,
                abilities: ['multishot', 'summon', 'teleport']
            },
            nightmare: {
                name: "梦魇",
                health: 4600, // 从4000提升到4600
                speed: 1.4,
                size: 65,
                color: "#000000",
                damage: 12,
                shootInterval: 500,
                expReward: 1500,
                abilities: ['multishot', 'summon', 'teleport', 'charge']
            },
            apocalypse: {
                name: "末日使者",
                health: 6200, // 从6000提升到6200
                speed: 1.6,
                size: 70,
                color: "#B71C1C",
                damage: 15,
                shootInterval: 400,
                expReward: 2000,
                abilities: ['multishot', 'summon', 'teleport', 'charge', 'heal']
            }
        };
        
        // 技能定义
        const skillDefinitions = {
            damage: {
                name: "增强攻击",
                icon: "⚔️",
                color: "#F44336",
                maxLevel: 5,
                description: (level) => level === 5 ? `子弹伤害 +100 (超级强化!)` : `子弹伤害 +${15 + level * 8}`,
                effect: (level) => ({ damage: level === 5 ? 100 : 15 + level * 8 })
            },
            speed: {
                name: "快速射击",
                icon: "🏹",
                color: "#FF9800",
                maxLevel: 5,
                description: (level) => level === 5 ? `射击间隔 -400ms (极速射击!)` : `射击间隔 -${40 + level * 15}ms`,
                effect: (level) => ({ shootInterval: level === 5 ? -400 : -(40 + level * 15) })
            },
            health: {
                name: "生命强化",
                icon: "❤️",
                color: "#E91E63",
                maxLevel: 5,
                description: (level) => level === 5 ? `最大生命值 +200，回复满血 (钢铁之躯!)` : `最大生命值 +${25 + level * 15}，回复满血`,
                effect: (level) => ({ maxHealth: level === 5 ? 200 : 25 + level * 15, healFull: true })
            },
            moveSpeed: {
                name: "疾风步伐",
                icon: "💨",
                color: "#00BCD4",
                maxLevel: 5,
                description: (level) => level === 5 ? `移动速度 +4 (闪电速度!)` : `移动速度 +${Math.round((0.4 + level * 0.4) * 10) / 10}`,
                effect: (level) => ({ speed: level === 5 ? 4 : Math.round((0.4 + level * 0.4) * 10) / 10 })
            },
            penetration: {
                name: "穿透射击",
                icon: "🎯",
                color: "#9C27B0",
                maxLevel: 5,
                description: (level) => level === 5 ? `子弹穿透 15 个敌人 (无限穿透!)` : `子弹穿透 ${level * 2} 个敌人`,
                effect: (level) => ({ penetration: level === 5 ? 15 : level * 2 })
            },
            lightning: {
                name: "雷电链",
                icon: "⚡",
                color: "#FFEB3B",
                maxLevel: 5,
                description: (level) => level === 5 ? `击中敌人时电击周围敌人，伤害80 (雷神之怒!)` : `击中敌人时电击周围敌人，伤害${8 + level * 6}`,
                effect: (level) => ({ lightning: level === 5 ? 80 : 8 + level * 6 })
            },
            poison: {
                name: "毒性攻击",
                icon: "☠️",
                color: "#4CAF50",
                maxLevel: 5,
                description: (level) => {
                    if (level === 5) return `击中敌人中毒10秒，每秒伤害25，强力传染 (剧毒领域!)`;
                    return `击中敌人中毒${2 + level}秒，每秒伤害${4 + level * 3}${level >= 3 ? '，可传染' : ''}`;
                },
                effect: (level) => ({ 
                    poison: { 
                        duration: level === 5 ? 10 : 2 + level, 
                        damage: level === 5 ? 25 : 4 + level * 3,
                        contagious: level >= 3,
                        range: level >= 3 ? (level === 5 ? 100 : 40 + level * 12) : 0
                    } 
                })
            },
            multishot: {
                name: "多重射击",
                icon: "🌟",
                color: "#3F51B5",
                maxLevel: 5,
                description: (level) => level === 5 ? `同时发射 6 发子弹 (弹幕风暴!)` : `同时发射 ${level + 1} 发子弹`,
                effect: (level) => ({ multishot: level === 5 ? 6 : level + 1 })
            },
            explosion: {
                name: "爆炸弹头",
                icon: "💥",
                color: "#FF5722",
                maxLevel: 5,
                description: (level) => level === 5 ? `子弹爆炸，范围伤害100 (核弹级威力!)` : `子弹爆炸，范围伤害${12 + level * 6}`,
                effect: (level) => ({ explosion: level === 5 ? 100 : 12 + level * 6 })
            },
            vampire: {
                name: "生命汲取",
                icon: "🩸",
                color: "#8E24AA",
                maxLevel: 5,
                description: (level) => level === 5 ? `击杀敌人回复20生命值 (完美再生!)` : `击杀敌人回复${1 + level}生命值`,
                effect: (level) => ({ vampire: level === 5 ? 20 : 1 + level })
            },
            lightsaber: {
                name: "光剑护盾",
                icon: "🗡️",
                color: "#00E5FF",
                maxLevel: 5,
                description: (level) => level === 5 ? `8把光剑环绕身体，对接触敌人造成50/秒伤害 (剑圣领域!)` : `${level}把光剑环绕身体，对接触敌人造成${6 + level * 3}/秒伤害`,
                effect: (level) => ({ 
                    lightsaber: {
                        count: level === 5 ? 8 : level,
                        damage: level === 5 ? 50 : 6 + level * 3
                    }
                })
            },
            freeze: {
                name: "冰霜减速",
                icon: "❄️",
                color: "#00BCD4",
                maxLevel: 5,
                description: (level) => level === 5 ? `击中敌人冰冻8秒，减速90% (绝对零度!)` : `击中敌人冰冻${2 + level}秒，减速${20 + level * 10}%`,
                effect: (level) => ({ 
                    freeze: {
                        duration: level === 5 ? 8 : 2 + level,
                        slowPercent: level === 5 ? 90 : 20 + level * 10
                    }
                })
            }
        };
        
        // 游戏状态
        const game = {
            player: {
                x: 0, y: 0, size: 18, speed: 5, health: 100, maxHealth: 100,
                level: 1, exp: 0, maxExp: 100, kills: 0, damage: 20,
                shootInterval: 600, lastShot: 0, direction: 0, facingLeft: false,
                walkCycle: 0, isMoving: false, skills: {}, penetration: 0,
                lightning: 0, poison: null, multishot: 1, explosion: 0, vampire: 0,
                pickupRange: 30, lightsaber: null, freeze: null
            },
            bullets: [], enemies: [], expOrbs: [], effects: [], enemyBullets: [],
            keys: {}, lastEnemySpawn: 0, enemySpawnInterval: 1500, paused: false,
            wave: 1, waveKills: 0, waveTarget: 8, buffs: [], particles: [],
            gameOver: false, startTime: Date.now(), survivalTime: 0, pickups: [],
            boss: null, bossActive: false, lastBossTime: 0, bossKills: 0,
            arena: null, bossPhase: 'none'
        };
        
        let animationTime = 0;
        
        // 开始游戏
        function startGame() {
            gameStarted = true;
            document.getElementById('gameGuide').style.display = 'none';
            document.getElementById('pauseBtn').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('skillsDisplay').style.display = 'block';
            document.getElementById('buffs').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            if (isTouchDevice()) {
                const j = document.getElementById('joystick');
                if (j) j.style.display = 'block';
                setupJoystick();
            }
            
            updateUI();
            updateSkillsDisplay();
            updateBuffsDisplay();
        }
        
        // 键盘事件
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Escape') {
                e.preventDefault();
                if (gameStarted && document.getElementById('skillModal').style.display !== 'block') {
                    togglePause();
                }
                return;
            }
            if (!game.paused && !game.gameOver && gameStarted) game.keys[e.key.toLowerCase()] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            game.keys[e.key.toLowerCase()] = false;
        });
        
        // 暂停功能 - 修复技能界面冲突
        function togglePause() {
            if (game.gameOver || !gameStarted) return;
            if (document.getElementById('skillModal').style.display === 'block') return; // 技能界面时不允许暂停
            
            game.paused = !game.paused;
            document.getElementById('pauseBtn').textContent = game.paused ? '继续' : '暂停';
        }
        
        // 重新开始游戏
        function restartGame() {
            isRestart = true;
            
            // 重置所有游戏状态
            game.player = {
                x: 0, y: 0, size: 18, speed: 5, health: 100, maxHealth: 100,
                level: 1, exp: 0, maxExp: 100, kills: 0, damage: 20,
                shootInterval: 600, lastShot: 0, direction: 0, facingLeft: false,
                walkCycle: 0, isMoving: false, skills: {}, penetration: 0,
                lightning: 0, poison: null, multishot: 1, explosion: 0, vampire: 0,
                pickupRange: 30, lightsaber: null, freeze: null
            };
            
            game.bullets = [];
            game.enemies = [];
            game.expOrbs = [];
            game.effects = [];
            game.enemyBullets = [];
            game.pickups = [];
            game.lastEnemySpawn = 0;
            game.enemySpawnInterval = 1500;
            game.wave = 1;
            game.waveKills = 0;
            game.waveTarget = 8;
            game.buffs = [];
            game.particles = [];
            game.gameOver = false;
            game.paused = false;
            game.startTime = Date.now();
            game.survivalTime = 0;
            game.boss = null;
            game.bossActive = false;
            game.lastBossTime = 0;
            game.bossKills = 0;
            game.arena = null;
            game.bossPhase = 'none';
            
            world.x = 0;
            world.y = 0;
            
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('perfectEnding').style.display = 'none';
            document.getElementById('bossWarning').style.display = 'none';
            document.getElementById('bossUI').style.display = 'none';
            document.getElementById('pauseBtn').textContent = '暂停';
            
            updateUI();
            updateSkillsDisplay();
            updateBuffsDisplay();
        }
        
        // 游戏结束
        function gameOver() {
            game.gameOver = true;
            
            document.getElementById('finalKills').textContent = game.player.kills;
            document.getElementById('finalTime').textContent = formatTime(game.survivalTime);
            document.getElementById('finalWave').textContent = game.wave;
            document.getElementById('finalLevel').textContent = game.player.level;
            document.getElementById('finalBosses').textContent = game.bossKills;
            
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        // 检查是否所有技能都满级
        function checkPerfectEnding() {
            const allSkills = Object.keys(skillDefinitions);
            const maxedSkills = allSkills.filter(skill => 
                (game.player.skills[skill] || 0) >= skillDefinitions[skill].maxLevel
            );
            
            if (maxedSkills.length === allSkills.length) {
                document.getElementById('perfectEnding').style.display = 'block';
                game.paused = true;
            }
        }
        
        // 格式化时间
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }
        
        // 检查Boss生成
        function checkBossSpawn() {
            const timeSinceLastBoss = game.survivalTime - game.lastBossTime;
            if (timeSinceLastBoss >= 180 && !game.bossActive && game.bossPhase === 'none') {
                initiateBossPhase();
            }
        }
        
        // 开始Boss阶段
        function initiateBossPhase() {
            game.bossPhase = 'warning';
            
            // 显示Boss警告
            document.getElementById('bossWarning').style.display = 'block';
            
            // 3秒后进入准备阶段
            setTimeout(() => {
                if (game.bossPhase === 'warning') {
                    prepareBossArena();
                }
            }, 3000);
        }
        
        // 准备Boss竞技场
        function prepareBossArena() {
            game.bossPhase = 'preparing';
            document.getElementById('bossWarning').style.display = 'none';
            
            // 清除所有敌人、经验球和拾取物
            game.enemies = [];
            game.expOrbs = [];
            game.pickups = [];
            game.enemyBullets = [];
            
            // 创建固定的竞技场
            const baseSize = Math.min(canvas.width, canvas.height) * 0.7;
            const arenaWidth = baseSize * 2;
            const arenaHeight = baseSize * 1.5;
            
            // 竞技场位置固定在当前玩家位置
            game.arena = {
                x: game.player.x - arenaWidth / 2,
                y: game.player.y - arenaHeight / 2,
                width: arenaWidth,
                height: arenaHeight
            };
            
            // 将玩家移动到竞技场中心
            game.player.x = game.arena.x + game.arena.width / 2;
            game.player.y = game.arena.y + game.arena.height / 2;
            
            // 1秒后生成Boss
            setTimeout(() => {
                if (game.bossPhase === 'preparing') {
                    spawnBoss();
                }
            }, 1000);
        }
        
        // 生成Boss
        function spawnBoss() {
            game.bossPhase = 'active';
            
            // 根据击败的Boss数量选择Boss类型
            const bossTypeKeys = Object.keys(bossTypes);
            const bossIndex = Math.min(game.bossKills, bossTypeKeys.length - 1);
            const bossTypeKey = bossTypeKeys[bossIndex];
            const bossType = bossTypes[bossTypeKey];
            
            // Boss随着时间变强
            const timeMultiplier = 1 + Math.floor(game.survivalTime / 600);
            
            // 在竞技场边缘生成Boss，远离玩家
            const spawnAngle = Math.random() * Math.PI * 2;
            const spawnDistance = Math.min(game.arena.width, game.arena.height) * 0.3;
            
            const arenaCenter = {
                x: game.arena.x + game.arena.width / 2,
                y: game.arena.y + game.arena.height / 2
            };
            
            // 创建Boss，所有属性在创建时确定，不再变化
            const finalHealth = Math.floor(bossType.health * timeMultiplier);
            const finalSpeed = Math.round((bossType.speed * Math.min(timeMultiplier, 2)) * 10) / 10;
            const finalDamage = Math.floor(bossType.damage * Math.min(timeMultiplier, 2));
            
            game.boss = {
                x: arenaCenter.x + Math.cos(spawnAngle) * spawnDistance,
                y: arenaCenter.y + Math.sin(spawnAngle) * spawnDistance,
                type: bossTypeKey,
                size: bossType.size,
                speed: finalSpeed,
                health: finalHealth,
                maxHealth: finalHealth,
                damage: finalDamage,
                shootInterval: Math.max(200, Math.floor(bossType.shootInterval / timeMultiplier)),
                lastShot: 0,
                lastAbility: 0,
                abilityInterval: 3000,
                expReward: Math.floor(bossType.expReward * timeMultiplier),
                abilities: [...bossType.abilities],
                frozen: false,
                freezeDuration: 0,
                originalSpeed: finalSpeed,
                lastDamageTime: 0,
                targetX: game.player.x,
                targetY: game.player.y,
                moveTimer: 0
            };
            
            // 确保Boss在竞技场内
            constrainToArena(game.boss);
            
            game.bossActive = true;
            document.getElementById('bossUI').style.display = 'block';
            updateBossUI();
        }
        
        // 限制在竞技场内
        function constrainToArena(entity) {
            if (!game.arena) return;
            
            const margin = entity.size + 5;
            entity.x = Math.max(game.arena.x + margin, 
                       Math.min(game.arena.x + game.arena.width - margin, entity.x));
            entity.y = Math.max(game.arena.y + margin, 
                       Math.min(game.arena.y + game.arena.height - margin, entity.y));
        }
        
        // 击败Boss
        function defeatBoss() {
            game.bossActive = false;
            game.boss = null;
            game.lastBossTime = game.survivalTime;
            game.bossKills++;
            game.arena = null;
            game.bossPhase = 'none';
            
            document.getElementById('bossUI').style.display = 'none';
            
            // 获得大量经验
            game.player.exp += 500;
            
            // 暂停游戏并直接获得技能升级
            game.paused = true;
            showSkillModal();
            
            updateUI();
        }
        
        // 更新Boss UI
        function updateBossUI() {
            if (!game.boss) return;
            
            const bossType = bossTypes[game.boss.type];
            document.getElementById('bossName').textContent = bossType.name;
            document.getElementById('bossHealth').textContent = Math.max(0, Math.floor(game.boss.health));
            document.getElementById('bossMaxHealth').textContent = game.boss.maxHealth;
            
            const healthPercent = Math.max(0, game.boss.health / game.boss.maxHealth) * 100;
            document.getElementById('bossHealthFill').style.width = healthPercent + '%';
        }
        
        // 创建粒子效果
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x: x + (Math.random() - 0.5) * 20,
                    y: y + (Math.random() - 0.5) * 20,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 2 + Math.random() * 3
                });
            }
        }
        
        // 绘制精美玩家角色
        function drawPlayer(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            if (game.player.facingLeft) ctx.scale(-1, 1);
            
            const walkOffset = game.player.isMoving ? Math.sin(game.player.walkCycle) * 2 : 0;
            const legOffset = game.player.isMoving ? Math.sin(game.player.walkCycle * 2) * 3 : 0;
            const armOffset = game.player.isMoving ? Math.sin(game.player.walkCycle * 1.5) * 1 : 0;
            
            // 阴影
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 28, 15, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 主体装甲 - 渐变效果
            const bodyGradient = ctx.createLinearGradient(-9, -16, 9, 10);
            bodyGradient.addColorStop(0, '#42A5F5');
            bodyGradient.addColorStop(0.5, '#2196F3');
            bodyGradient.addColorStop(1, '#1976D2');
            ctx.fillStyle = bodyGradient;
            ctx.fillRect(-9, -16, 18, 26);
            
            // 装甲细节和反光
            ctx.fillStyle = '#1E88E5';
            ctx.fillRect(-7, -14, 14, 3);
            ctx.fillRect(-5, -9, 10, 2);
            ctx.fillRect(-6, -2, 12, 2);
            
            // 装甲边缘高光
            ctx.strokeStyle = '#64B5F6';
            ctx.lineWidth = 1;
            ctx.strokeRect(-9, -16, 18, 26);
            
            // 胸前能量核心
            const coreGradient = ctx.createRadialGradient(0, -8, 0, 0, -8, 5);
            coreGradient.addColorStop(0, '#FFD700');
            coreGradient.addColorStop(0.7, '#FFA000');
            coreGradient.addColorStop(1, '#FF8F00');
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, -8, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // 能量核心发光效果
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#FFEB3B';
            ctx.beginPath();
            ctx.arc(0, -8, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 头部 - 肤色渐变
            const headGradient = ctx.createRadialGradient(-3, -27, 0, 0, -25, 10);
            headGradient.addColorStop(0, '#FFCC80');
            headGradient.addColorStop(1, '#FFB74D');
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(0, -25, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // 高科技头盔
            const helmetGradient = ctx.createLinearGradient(-11, -35, 11, -20);
            helmetGradient.addColorStop(0, '#455A64');
            helmetGradient.addColorStop(0.5, '#37474F');
            helmetGradient.addColorStop(1, '#263238');
            ctx.fillStyle = helmetGradient;
            ctx.beginPath();
            ctx.arc(0, -27, 11, Math.PI, 0);
            ctx.fill();
            
            // 头盔装饰和通风口
            ctx.fillStyle = '#607D8B';
            ctx.fillRect(-8, -30, 16, 2);
            ctx.fillRect(-6, -32, 3, 1);
            ctx.fillRect(3, -32, 3, 1);
            
            // 头盔侧面装饰
            ctx.fillStyle = '#78909C';
            ctx.fillRect(-10, -28, 2, 4);
            ctx.fillRect(8, -28, 2, 4);
            
            // 护目镜/面罩
            ctx.fillStyle = '#1A237E';
            ctx.fillRect(-8, -28, 16, 4);
            
            // 眼睛发光效果
            ctx.fillStyle = '#00E5FF';
            ctx.shadowColor = '#00E5FF';
            ctx.shadowBlur = 5;
            ctx.beginPath();
            ctx.arc(-3, -26, 2, 0, Math.PI * 2);
            ctx.arc(3, -26, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 嘴部呼吸器
            ctx.fillStyle = '#37474F';
            ctx.fillRect(-3, -23, 6, 3);
            ctx.fillStyle = '#546E7A';
            ctx.fillRect(-2, -22, 4, 1);
            
            // 左手臂装甲
            ctx.strokeStyle = '#FFCC80';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-9, -10);
            ctx.lineTo(-16, -6 + armOffset);
            ctx.lineTo(-20, -1 + armOffset);
            ctx.stroke();
            
            // 左臂护甲
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.arc(-13, -8 + armOffset, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // 右手臂（持枪）装甲
            ctx.beginPath();
            ctx.moveTo(9, -10);
            ctx.lineTo(16, -6 - armOffset);
            ctx.lineTo(23, -3 - armOffset);
            ctx.stroke();
            
            // 右臂护甲
            ctx.fillStyle = '#1976D2';
            ctx.beginPath();
            ctx.arc(13, -8 - armOffset, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // 精美高科技枪械
            const gunGradient = ctx.createLinearGradient(23, -6 - armOffset, 41, -1 - armOffset);
            gunGradient.addColorStop(0, '#546E7A');
            gunGradient.addColorStop(0.5, '#424242');
            gunGradient.addColorStop(1, '#212121');
            ctx.fillStyle = gunGradient;
            ctx.fillRect(23, -6 - armOffset, 18, 5);
            
            // 枪管
            ctx.fillStyle = '#263238';
            ctx.fillRect(41, -5 - armOffset, 8, 3);
            
            // 枪管末端
            ctx.fillStyle = '#37474F';
            ctx.fillRect(49, -4.5 - armOffset, 2, 2);
            
            // 枪托
            const stockGradient = ctx.createLinearGradient(18, -5 - armOffset, 25, -2 - armOffset);
            stockGradient.addColorStop(0, '#8D6E63');
            stockGradient.addColorStop(1, '#5D4037');
            ctx.fillStyle = stockGradient;
            ctx.fillRect(18, -5 - armOffset, 7, 3);
            
            // 扳机护圈
            ctx.strokeStyle = '#546E7A';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(26, -2 - armOffset, 2, 0, Math.PI);
            ctx.stroke();
            
            // 瞄准镜
            ctx.fillStyle = '#37474F';
            ctx.fillRect(30, -8 - armOffset, 8, 4);
            ctx.fillStyle = '#1A237E';
            ctx.fillRect(31, -7 - armOffset, 6, 2);
            
            // 枪械装饰
            ctx.fillStyle = '#FF5722';
            ctx.fillRect(35, -5.5 - armOffset, 3, 1);
            
            // 腿部装甲
            ctx.strokeStyle = '#1976D2';
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-5, 10);
            ctx.lineTo(-7, 24 + legOffset);
            ctx.moveTo(5, 10);
            ctx.lineTo(7, 24 - legOffset);
            ctx.stroke();
            
            // 膝盖护甲
            ctx.fillStyle = '#1565C0';
            ctx.beginPath();
            ctx.arc(-6, 17 + legOffset/2, 3, 0, Math.PI * 2);
            ctx.arc(6, 17 - legOffset/2, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // 战术靴
            const bootGradient = ctx.createLinearGradient(-11, 22, -2, 27);
            bootGradient.addColorStop(0, '#546E7A');
            bootGradient.addColorStop(1, '#263238');
            ctx.fillStyle = bootGradient;
            ctx.fillRect(-11, 22 + legOffset, 9, 6);
            ctx.fillRect(2, 22 - legOffset, 9, 6);
            
            // 靴子细节
            ctx.fillStyle = '#78909C';
            ctx.fillRect(-10, 23 + legOffset, 7, 2);
            ctx.fillRect(3, 23 - legOffset, 7, 2);
            
            // 靴子鞋底
            ctx.fillStyle = '#212121';
            ctx.fillRect(-11, 27 + legOffset, 9, 2);
            ctx.fillRect(2, 27 - legOffset, 9, 2);
            
            ctx.restore();
            
            // 绘制光剑护盾
            if (game.player.lightsaber) {
                drawLightsabers(x, y);
            }
        }
        
        // 绘制光剑护盾
        function drawLightsabers(x, y) {
            const saber = game.player.lightsaber;
            const radius = 45;
            
            for (let i = 0; i < saber.count; i++) {
                const angle = (animationTime * 0.02) + (i * (Math.PI * 2) / saber.count);
                const saberX = x + Math.cos(angle) * radius;
                const saberY = y + Math.sin(angle) * radius;
                
                ctx.save();
                ctx.translate(saberX, saberY);
                ctx.rotate(angle + Math.PI / 2);
                
                // 光剑剑柄
                const hiltGradient = ctx.createLinearGradient(-2, -7, 2, 7);
                hiltGradient.addColorStop(0, '#546E7A');
                hiltGradient.addColorStop(0.5, '#37474F');
                hiltGradient.addColorStop(1, '#263238');
                ctx.fillStyle = hiltGradient;
                ctx.fillRect(-2, -7, 4, 14);
                
                // 剑柄细节
                ctx.fillStyle = '#78909C';
                ctx.fillRect(-2, -2, 4, 2);
                ctx.fillRect(-2, 2, 4, 2);
                
                // 光剑刀身
                const bladeGradient = ctx.createLinearGradient(0, -22, 0, -7);
                bladeGradient.addColorStop(0, 'rgba(0, 229, 255, 0.8)');
                bladeGradient.addColorStop(0.5, '#00E5FF');
                bladeGradient.addColorStop(1, 'rgba(0, 229, 255, 0.8)');
                
                ctx.fillStyle = bladeGradient;
                ctx.fillRect(-1, -22, 2, 15);
                
                // 光剑发光效果
                ctx.shadowColor = '#00E5FF';
                ctx.shadowBlur = 8;
                ctx.fillRect(-1, -22, 2, 15);
                ctx.shadowBlur = 0;
                
                ctx.restore();
            }
        }
        
        // 绘制精美Boss
        function drawBoss(boss, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const dx = game.player.x - boss.x;
            const facingLeft = dx < 0;
            if (facingLeft) ctx.scale(-1, 1);
            
            const bossType = bossTypes[boss.type];
            const scale = boss.size / 30;
            const time = animationTime * 0.01;
            
            // Boss阴影
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 35 * scale, 30 * scale, 8 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss主体装甲 - 渐变效果
            const bodyGradient = ctx.createLinearGradient(-25 * scale, -25 * scale, 25 * scale, 20 * scale);
            if (boss.frozen) {
                bodyGradient.addColorStop(0, '#B3E5FC');
                bodyGradient.addColorStop(0.5, '#81D4FA');
                bodyGradient.addColorStop(1, '#4FC3F7');
            } else {
                bodyGradient.addColorStop(0, bossType.color);
                bodyGradient.addColorStop(0.5, '#666');
                bodyGradient.addColorStop(1, '#333');
            }
            ctx.fillStyle = bodyGradient;
            ctx.fillRect(-25 * scale, -25 * scale, 50 * scale, 45 * scale);
            
            // Boss装甲细节
            ctx.fillStyle = boss.frozen ? '#546E7A' : '#424242';
            ctx.fillRect(-20 * scale, -20 * scale, 40 * scale, 8 * scale);
            ctx.fillRect(-15 * scale, -10 * scale, 30 * scale, 6 * scale);
            ctx.fillRect(-18 * scale, 0, 36 * scale, 4 * scale);
            
            // 装甲板连接
            for (let i = 0; i < 3; i++) {
                ctx.fillStyle = '#616161';
                ctx.beginPath();
                ctx.arc(-15 * scale + i * 15 * scale, -15 * scale, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Boss头部 - 更精细
            const headGradient = ctx.createRadialGradient(0, -35 * scale, 0, 0, -35 * scale, 15 * scale);
            if (boss.frozen) {
                headGradient.addColorStop(0, '#E1F5FE');
                headGradient.addColorStop(1, '#B3E5FC');
            } else {
                headGradient.addColorStop(0, '#FF7043');
                headGradient.addColorStop(1, '#D84315');
            }
            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.arc(0, -35 * scale, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // 头部装甲细节
            ctx.fillStyle = boss.frozen ? '#37474F' : '#BF360C';
            ctx.fillRect(-12 * scale, -42 * scale, 24 * scale, 6 * scale);
            
            // Boss眼睛 - 发光效果
            ctx.fillStyle = boss.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowColor = boss.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowBlur = 8 * scale;
            ctx.beginPath();
            ctx.arc(-6 * scale, -38 * scale, 4 * scale, 0, Math.PI * 2);
            ctx.arc(6 * scale, -38 * scale, 4 * scale, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 眼睛内部细节
            ctx.fillStyle = boss.frozen ? '#B3E5FC' : '#FFCDD2';
            ctx.beginPath();
            ctx.arc(-6 * scale, -39 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.arc(6 * scale, -39 * scale, 2 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss武器系统
            const weaponGradient = ctx.createLinearGradient(25 * scale, -15 * scale, 45 * scale, -7 * scale);
            weaponGradient.addColorStop(0, '#757575');
            weaponGradient.addColorStop(1, '#424242');
            ctx.fillStyle = weaponGradient;
            ctx.fillRect(25 * scale, -15 * scale, 20 * scale, 8 * scale);
            ctx.fillRect(-45 * scale, -15 * scale, 20 * scale, 8 * scale);
            
            // 武器细节
            ctx.fillStyle = '#FF5722';
            ctx.fillRect(30 * scale, -13 * scale, 10 * scale, 4 * scale);
            ctx.fillRect(-40 * scale, -13 * scale, 10 * scale, 4 * scale);
            
            // 能量管道
            ctx.strokeStyle = boss.frozen ? '#00BCD4' : '#FF9800';
            ctx.lineWidth = 3 * scale;
            ctx.beginPath();
            ctx.moveTo(-20 * scale, -5 * scale);
            ctx.quadraticCurveTo(0, -10 * scale, 20 * scale, -5 * scale);
            ctx.stroke();
            
            // 胸部能量核心
            const coreGradient = ctx.createRadialGradient(0, -5 * scale, 0, 0, -5 * scale, 8 * scale);
            if (boss.frozen) {
                coreGradient.addColorStop(0, '#00E5FF');
                coreGradient.addColorStop(1, '#0277BD');
            } else {
                coreGradient.addColorStop(0, '#FF6F00');
                coreGradient.addColorStop(1, '#E65100');
            }
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, -5 * scale, 6 * scale, 0, Math.PI * 2);
            ctx.fill();
            
            // 能量核心脉动效果
            const pulseSize = 4 * scale + Math.sin(time * 4) * 2 * scale;
            ctx.fillStyle = boss.frozen ? 'rgba(0, 229, 255, 0.5)' : 'rgba(255, 111, 0, 0.5)';
            ctx.beginPath();
            ctx.arc(0, -5 * scale, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // 冰冻特效
            if (boss.frozen) {
                drawFreezeEffect(0, 0, boss.size);
            }
            
            ctx.restore();
        }
        
        // 绘制冰冻特效
        function drawFreezeEffect(x, y, size) {
            const time = animationTime * 0.01;
            
            // 冰晶环绕
            for (let i = 0; i < 12; i++) {
                const angle = time + (i * Math.PI / 6);
                const radius = size * 0.8 + Math.sin(time * 3 + i) * 8;
                const crystalX = Math.cos(angle) * radius;
                const crystalY = Math.sin(angle) * radius;
                
                ctx.save();
                ctx.translate(crystalX, crystalY);
                ctx.rotate(angle);
                
                // 冰晶
                ctx.fillStyle = `rgba(135, 206, 235, ${0.6 + Math.sin(time * 4 + i) * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(0, -8);
                ctx.lineTo(4, 0);
                ctx.lineTo(0, 8);
                ctx.lineTo(-4, 0);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // 冰雾效果
            for (let i = 0; i < 8; i++) {
                const angle = time * 0.5 + (i * Math.PI / 4);
                const radius = size * 0.6 + Math.sin(time * 2 + i) * 10;
                const mistX = Math.cos(angle) * radius;
                const mistY = Math.sin(angle) * radius;
                
                const gradient = ctx.createRadialGradient(mistX, mistY, 0, mistX, mistY, 12);
                gradient.addColorStop(0, 'rgba(173, 216, 230, 0.4)');
                gradient.addColorStop(1, 'rgba(173, 216, 230, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(mistX, mistY, 10 + Math.sin(time * 3 + i) * 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 绘制精美敌人角色
        function drawEnemy(enemy, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const dx = game.player.x - enemy.x;
            const facingLeft = dx < 0;
            if (facingLeft) ctx.scale(-1, 1);
            
            const type = enemyTypes[enemy.type];
            const scale = enemy.size / 15;
            const time = animationTime * 0.01;
            
            // 敌人阴影
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, 18 * scale, 12 * scale, 4 * scale, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 根据敌人类型绘制不同外观
            if (enemy.type === 'tank') {
                // 重装兵 - 更厚重的装甲
                const tankGradient = ctx.createLinearGradient(-14 * scale, -16 * scale, 14 * scale, 12 * scale);
                tankGradient.addColorStop(0, enemy.frozen ? '#B3E5FC' : '#8D6E63');
                tankGradient.addColorStop(0.5, enemy.frozen ? '#81D4FA' : '#6D4C41');
                tankGradient.addColorStop(1, enemy.frozen ? '#4FC3F7' : '#5D4037');
                ctx.fillStyle = tankGradient;
                ctx.fillRect(-14 * scale, -16 * scale, 28 * scale, 28 * scale);
                
                // 厚重装甲层
                ctx.fillStyle = enemy.frozen ? '#546E7A' : '#4E342E';
                ctx.fillRect(-12 * scale, -14 * scale, 24 * scale, 5 * scale);
                ctx.fillRect(-10 * scale, -8 * scale, 20 * scale, 4 * scale);
                
                // 装甲铆钉
                for (let i = 0; i < 4; i++) {
                    ctx.fillStyle = '#616161';
                    ctx.beginPath();
                    ctx.arc(-8 * scale + i * 5 * scale, -12 * scale, 1 * scale, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 装甲头盔
                const helmetGradient = ctx.createRadialGradient(0, -24 * scale, 0, 0, -24 * scale, 14 * scale);
                helmetGradient.addColorStop(0, '#616161');
                helmetGradient.addColorStop(1, '#424242');
                ctx.fillStyle = helmetGradient;
                ctx.beginPath();
                ctx.arc(0, -24 * scale, 14 * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // 头盔护目镜
                ctx.fillStyle = enemy.frozen ? '#00E5FF' : '#F44336';
                ctx.shadowColor = enemy.frozen ? '#00E5FF' : '#F44336';
                ctx.shadowBlur = 5;
                ctx.fillRect(-10 * scale, -27 * scale, 20 * scale, 5 * scale);
                ctx.shadowBlur = 0;
                
            } else if (enemy.type === 'gunner') {
                // 枪手 - 精确射手外观
                const gunnerGradient = ctx.createLinearGradient(-10, -14, 10, 10);
                gunnerGradient.addColorStop(0, enemy.frozen ? '#B39DDB' : '#AB47BC');
                gunnerGradient.addColorStop(1, enemy.frozen ? '#9575CD' : '#8E24AA');
                ctx.fillStyle = gunnerGradient;
                ctx.fillRect(-10, -14, 20, 24);
                
                // 战术背心
                ctx.fillStyle = enemy.frozen ? '#5C6BC0' : '#7B1FA2';
                ctx.fillRect(-8, -12, 16, 10);
                
                // 背心装备
                ctx.fillStyle = '#4A148C';
                ctx.fillRect(-6, -10, 3, 6);
                ctx.fillRect(3, -10, 3, 6);
                
                // 头部
                const headGradient = ctx.createRadialGradient(0, -22, 0, 0, -22, 9);
                headGradient.addColorStop(0, '#FFCDD2');
                headGradient.addColorStop(1, '#F8BBD9');
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(0, -22, 9, 0, Math.PI * 2);
                ctx.fill();
                
                // 战术头盔
                ctx.fillStyle = '#4A148C';
                ctx.beginPath();
                ctx.arc(0, -24, 10, Math.PI, 0);
                ctx.fill();
                
                // 精确步枪
                const rifleGradient = ctx.createLinearGradient(14, -10, 34, -5);
                rifleGradient.addColorStop(0, '#546E7A');
                rifleGradient.addColorStop(1, '#263238');
                ctx.fillStyle = rifleGradient;
                ctx.fillRect(14, -10, 20, 5);
                
                // 瞄准镜
                ctx.fillStyle = '#37474F';
                ctx.fillRect(22, -12, 10, 4);
                
            } else if (enemy.type === 'fast') {
                // 快速兵 - 轻装敏捷
                const fastGradient = ctx.createLinearGradient(-7, -12, 7, 8);
                fastGradient.addColorStop(0, enemy.frozen ? '#FFE082' : '#FFB74D');
                fastGradient.addColorStop(1, enemy.frozen ? '#FFCC02' : '#FF9800');
                ctx.fillStyle = fastGradient;
                ctx.fillRect(-7, -12, 14, 20);
                
                // 轻型护甲
                ctx.fillStyle = enemy.frozen ? '#FFA726' : '#F57C00';
                ctx.fillRect(-6, -10, 12, 4);
                
                // 速度线条装饰
                ctx.strokeStyle = '#FF5722';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-5, -8 + i * 3);
                    ctx.lineTo(5, -8 + i * 3);
                    ctx.stroke();
                }
                
            } else if (enemy.type === 'sniper') {
                // 狙击手
                const sniperGradient = ctx.createLinearGradient(-8, -13, 8, 9);
                sniperGradient.addColorStop(0, enemy.frozen ? '#90A4AE' : '#78909C');
                sniperGradient.addColorStop(1, enemy.frozen ? '#78909C' : '#607D8B');
                ctx.fillStyle = sniperGradient;
                ctx.fillRect(-8, -13, 16, 22);
                
                // 狙击镜
                ctx.fillStyle = '#263238';
                ctx.beginPath();
                ctx.arc(0, -22, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // 镜片反光
                ctx.fillStyle = '#B0BEC5';
                ctx.beginPath();
                ctx.arc(-2, -24, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // 长狙击枪
                const sniperRifleGradient = ctx.createLinearGradient(14, -8, 39, -5);
                sniperRifleGradient.addColorStop(0, '#424242');
                sniperRifleGradient.addColorStop(1, '#212121');
                ctx.fillStyle = sniperRifleGradient;
                ctx.fillRect(14, -8, 25, 3);
                
            } else if (enemy.type === 'bomber') {
                // 爆破兵
                const bomberGradient = ctx.createLinearGradient(-11, -15, 11, 11);
                bomberGradient.addColorStop(0, enemy.frozen ? '#F8BBD9' : '#EC407A');
                bomberGradient.addColorStop(1, enemy.frozen ? '#F06292' : '#E91E63');
                ctx.fillStyle = bomberGradient;
                ctx.fillRect(-11, -15, 22, 26);
                
                // 炸弹背包 - 脉动效果
                const bombSize = 6 + Math.sin(time * 6) * 1;
                ctx.fillStyle = '#FF5722';
                ctx.beginPath();
                ctx.arc(-8, -8, bombSize, 0, Math.PI * 2);
                ctx.arc(8, -8, bombSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 炸弹引线
                ctx.strokeStyle = '#795548';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-8, -14);
                ctx.lineTo(-8, -18);
                ctx.moveTo(8, -14);
                ctx.lineTo(8, -18);
                ctx.stroke();
                
            } else if (enemy.type === 'shield') {
                // 护盾兵
                const shieldGradient = ctx.createLinearGradient(-10, -14, 10, 10);
                shieldGradient.addColorStop(0, enemy.frozen ? '#9FA8DA' : '#5C6BC0');
                shieldGradient.addColorStop(1, enemy.frozen ? '#7986CB' : '#3F51B5');
                ctx.fillStyle = shieldGradient;
                ctx.fillRect(-10, -14, 20, 24);
                
                // 护盾
                if (enemy.hasShield) {
                    const shieldGradient = ctx.createRadialGradient(-15, 0, 0, -15, 0, 12);
                    shieldGradient.addColorStop(0, '#42A5F5');
                    shieldGradient.addColorStop(1, '#1976D2');
                    ctx.fillStyle = shieldGradient;
                    ctx.beginPath();
                    ctx.arc(-15, 0, 12, -Math.PI/2, Math.PI/2);
                    ctx.fill();
                    
                    // 护盾装饰
                    ctx.fillStyle = '#1565C0';
                    ctx.fillRect(-20, -8, 8, 16);
                }
                
            } else if (enemy.type === 'healer') {
                // 治疗兵
                const healerGradient = ctx.createLinearGradient(-8, -13, 8, 9);
                healerGradient.addColorStop(0, enemy.frozen ? '#A5D6A7' : '#81C784');
                healerGradient.addColorStop(1, enemy.frozen ? '#81C784' : '#4CAF50');
                ctx.fillStyle = healerGradient;
                ctx.fillRect(-8, -13, 16, 22);
                
                // 治疗十字
                ctx.fillStyle = '#F44336';
                ctx.fillRect(-1, -18, 2, 8);
                ctx.fillRect(-4, -16, 8, 2);
                
                // 治疗光环
                if (enemy.healOthers) {
                    const healRadius = 30 + Math.sin(time * 2) * 5;
                    ctx.strokeStyle = 'rgba(76, 175, 80, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, healRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // 治疗粒子
                    for (let i = 0; i < 6; i++) {
                        const angle = time + i * Math.PI / 3;
                        const x = Math.cos(angle) * 20;
                        const y = Math.sin(angle) * 20;
                        ctx.fillStyle = `rgba(76, 175, 80, ${0.5 + Math.sin(time * 4 + i) * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
            } else {
                // 基础敌人 - 标准士兵
                const basicGradient = ctx.createLinearGradient(-9, -14, 9, 10);
                if (enemy.poisoned) {
                    basicGradient.addColorStop(0, '#A5D6A7');
                    basicGradient.addColorStop(1, '#4CAF50');
                } else if (enemy.frozen) {
                    basicGradient.addColorStop(0, '#FFCDD2');
                    basicGradient.addColorStop(1, '#F8BBD9');
                } else {
                    basicGradient.addColorStop(0, '#EF5350');
                    basicGradient.addColorStop(1, '#F44336');
                }
                ctx.fillStyle = basicGradient;
                ctx.fillRect(-9, -14, 18, 24);
                
                // 标准护甲
                ctx.fillStyle = enemy.frozen ? '#5C6BC0' : '#C62828';
                ctx.fillRect(-7, -12, 14, 5);
                
                // 护甲细节
                ctx.fillStyle = '#B71C1C';
                ctx.fillRect(-6, -10, 3, 8);
                ctx.fillRect(3, -10, 3, 8);
                
                // 标准武器
                const weaponGradient = ctx.createLinearGradient(14, -8, 28, -4);
                weaponGradient.addColorStop(0, '#546E7A');
                weaponGradient.addColorStop(1, '#263238');
                ctx.fillStyle = weaponGradient;
                ctx.fillRect(14, -8, 14, 4);
            }
            
            // 通用头部（如果没有特殊头盔）
            if (!['tank', 'gunner', 'sniper'].includes(enemy.type)) {
                const headGradient = ctx.createRadialGradient(0, -22, 0, 0, -22, 9);
                headGradient.addColorStop(0, '#FFCDD2');
                headGradient.addColorStop(1, '#F8BBD9');
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(0, -22, 9, 0, Math.PI * 2);
                ctx.fill();
                
                // 头盔
                ctx.fillStyle = enemy.frozen ? '#37474F' : '#424242';
                ctx.beginPath();
                ctx.arc(0, -24, 10, Math.PI, 0);
                ctx.fill();
            }
            
            // 邪恶的眼睛
            ctx.fillStyle = enemy.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowColor = enemy.frozen ? '#00E5FF' : '#FF1744';
            ctx.shadowBlur = 3;
            ctx.beginPath();
            ctx.arc(-3, -24, 2, 0, Math.PI * 2);
            ctx.arc(3, -24, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 精美中毒效果
            if (enemy.poisoned) {
                drawPoisonEffect(enemy, 0, 0);
            }
            
            // 冰冻效果
            if (enemy.frozen) {
                drawFreezeEffect(0, 0, enemy.size);
            }
            
            ctx.restore();
        }
        
        // 绘制精美中毒效果
        function drawPoisonEffect(enemy, x, y) {
            const time = animationTime * 0.01;
            
            // 绿色毒雾环绕
            for (let i = 0; i < 8; i++) {
                const angle = time + (i * Math.PI / 4);
                const radius = 25 + Math.sin(time * 2 + i) * 5;
                const cloudX = Math.cos(angle) * radius;
                const cloudY = Math.sin(angle) * radius - 10;
                
                // 毒雾云
                const gradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, 8);
                gradient.addColorStop(0, 'rgba(76, 175, 80, 0.6)');
                gradient.addColorStop(0.5, 'rgba(76, 175, 80, 0.3)');
                gradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cloudX, cloudY, 6 + Math.sin(time * 3 + i) * 2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 上升的毒泡泡
            for (let i = 0; i < 5; i++) {
                const bubbleTime = (time * 2 + i) % 4;
                const bubbleX = (Math.sin(time + i) * 15);
                const bubbleY = -10 - bubbleTime * 15;
                const bubbleSize = 2 + Math.sin(time * 4 + i) * 1;
                const alpha = Math.max(0, 1 - bubbleTime / 4);
                
                ctx.fillStyle = `rgba(76, 175, 80, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                ctx.fill();
                
                // 泡泡高光
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.4})`;
                ctx.beginPath();
                ctx.arc(bubbleX - 1, bubbleY - 1, bubbleSize * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 地面毒液池
            const poolGradient = ctx.createRadialGradient(0, 15, 0, 0, 15, 20);
            poolGradient.addColorStop(0, 'rgba(76, 175, 80, 0.4)');
            poolGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
            
            ctx.fillStyle = poolGradient;
            ctx.beginPath();
            ctx.ellipse(0, 15, 18, 8, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 绘制子弹
        function drawBullet(bullet, screenX, screenY) {
            ctx.save();
            ctx.translate(screenX, screenY);
            
            const angle = Math.atan2(bullet.vy, bullet.vx);
            ctx.rotate(angle);
            
            // 子弹主体渐变
            const bulletGradient = ctx.createLinearGradient(-8, -2, 8, 2);
            bulletGradient.addColorStop(0, '#FFD700');
            bulletGradient.addColorStop(0.5, '#FFA000');
            bulletGradient.addColorStop(1, '#FF8F00');
            ctx.fillStyle = bulletGradient;
            ctx.fillRect(-8, -2, 16, 4);
            
            // 子弹头部
            ctx.fillStyle = '#FF6F00';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(12, -2);
            ctx.lineTo(12, 2);
            ctx.closePath();
            ctx.fill();
            
            // 子弹尾迹
            ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
            ctx.fillRect(-12, -1, 4, 2);
            
            ctx.restore();
            
            // 子弹发光效果
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 8;
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // 绘制经验球 - 修复大经验球特效颜色
        function drawExpOrb(orb, screenX, screenY) {
            const pulseSize = orb.size + Math.sin(animationTime * 0.01) * 2;
            
            // 外层光环
            if (orb.type === 'big') {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
            } else {
                ctx.fillStyle = 'rgba(0, 188, 212, 0.3)';
            }
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseSize + 5, 0, Math.PI * 2);
            ctx.fill();
            
            // 主体
            const gradient = ctx.createRadialGradient(screenX, screenY, 0, screenX, screenY, pulseSize);
            if (orb.type === 'big') {
                gradient.addColorStop(0, '#FFD700');
                gradient.addColorStop(0.7, '#FFA000');
                gradient.addColorStop(1, '#FF8F00');
            } else {
                gradient.addColorStop(0, '#4DD0E1');
                gradient.addColorStop(0.7, '#00BCD4');
                gradient.addColorStop(1, '#0097A7');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // 内部高光
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(screenX - 2, screenY - 2, pulseSize * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 绘制拾取物品
        function drawPickup(pickup, screenX, screenY) {
            const pulseSize = pickup.size + Math.sin(animationTime * 0.01) * 2;
            
            if (pickup.type === 'magnet') {
                // 磁铁
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize + 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('🧲', screenX, screenY + 6);
                
            } else if (pickup.type === 'health') {
                // 血包
                ctx.fillStyle = 'rgba(244, 67, 54, 0.3)';
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseSize + 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#F44336';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('❤️', screenX, screenY + 6);
            }
        }
        
        // 绘制竞技场边界
        function drawArenaBorder() {
            if (!game.arena) return;
            
            const borderX = game.arena.x - world.x;
            const borderY = game.arena.y - world.y;
            const borderWidth = game.arena.width;
            const borderHeight = game.arena.height;
            
            // 只在边界在屏幕范围内时绘制
            if (borderX < canvas.width && borderY < canvas.height && 
                borderX + borderWidth > 0 && borderY + borderHeight > 0) {
                
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FF0000';
                ctx.shadowBlur = 10;
                ctx.strokeRect(borderX, borderY, borderWidth, borderHeight);
                ctx.shadowBlur = 0;
            }
        }
        
        // 玩家移动
        function movePlayer() {
            const player = game.player;
            let moved = false;
            let moveX = 0, moveY = 0;

            // 优先使用移动遥杆（触屏设备）
            if (isTouchDevice() && joystick.active && joystick.magnitude > 0.05) {
                const speedScale = joystick.magnitude; // 模拟模拟量速度
                moveX = joystick.dx * player.speed * speedScale;
                moveY = joystick.dy * player.speed * speedScale;
                moved = true;
                if (moveX < -0.01) player.facingLeft = true;
                else if (moveX > 0.01) player.facingLeft = false;
            } else {
                if (game.keys['w'] || game.keys['arrowup']) {
                    moveY = -player.speed;
                    moved = true;
                }
                if (game.keys['s'] || game.keys['arrowdown']) {
                    moveY = player.speed;
                    moved = true;
                }
                if (game.keys['a'] || game.keys['arrowleft']) {
                    moveX = -player.speed;
                    moved = true;
                    player.facingLeft = true;
                }
                if (game.keys['d'] || game.keys['arrowright']) {
                    moveX = player.speed;
                    moved = true;
                    player.facingLeft = false;
                }
            }

            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.707;
                moveY *= 0.707;
            }

            player.x += moveX;
            player.y += moveY;
            player.isMoving = moved;

            if (moved) {
                player.walkCycle += 0.3;
            }

            // 限制在竞技场内
            if (game.bossActive) {
                constrainToArena(player);
            }

            // 更新摄像机
            world.x = player.x - canvas.width / 2;
            world.y = player.y - canvas.height / 2;
        }
        
        // 生成敌人 - 增强随时间的提升
        function spawnEnemy() {
            if (game.bossActive) return; // Boss战期间不生成普通敌人
            
            const now = Date.now();
            if (now - game.lastEnemySpawn > game.enemySpawnInterval) {
                const minutes = Math.floor(game.survivalTime / 60);
                // 敌人数量随时间显著增加
                const spawnCount = Math.min(1 + Math.floor(minutes / 1.5), 5);
                
                for (let i = 0; i < spawnCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 400 + Math.random() * 200;
                    
                    const x = game.player.x + Math.cos(angle) * distance;
                    const y = game.player.y + Math.sin(angle) * distance;
                    
                    // 增加敌人种类的生成概率
                    let enemyType = 'basic';
                    const rand = Math.random();
                    
                    if (game.wave >= 2) {
                        if (rand < 0.08) enemyType = 'tank';
                        else if (rand < 0.18) enemyType = 'gunner';
                        else if (rand < 0.35) enemyType = 'fast';
                        else if (rand < 0.45) enemyType = 'sniper';
                        else if (rand < 0.55) enemyType = 'bomber';
                        else if (rand < 0.65) enemyType = 'shield';
                        else if (rand < 0.75) enemyType = 'healer';
                    }
                    
                    const baseStats = enemyTypes[enemyType];
                    // 大幅增强随时间的提升
                    const timeMultiplier = 1 + Math.floor(game.survivalTime / 180); // 每3分钟翻倍
                    
                    game.enemies.push({
                        x: x, y: y,
                        type: enemyType,
                        size: baseStats.size,
                        speed: Math.round((baseStats.speed * (0.8 + timeMultiplier * 0.3)) * 10) / 10,
                        health: Math.floor(baseStats.health * timeMultiplier),
                        maxHealth: Math.floor(baseStats.health * timeMultiplier),
                        damage: Math.floor(baseStats.damage * timeMultiplier),
                        shootInterval: baseStats.shootInterval,
                        lastShot: 0,
                        expReward: Math.floor(baseStats.expReward * timeMultiplier),
                        poisoned: false,
                        poisonDamage: 0,
                        poisonDuration: 0,
                        lastPoisonTick: 0,
                        frozen: false,
                        freezeDuration: 0,
                        originalSpeed: Math.round((baseStats.speed * (0.8 + timeMultiplier * 0.3)) * 10) / 10,
                        explodeOnDeath: baseStats.explodeOnDeath || false,
                        hasShield: baseStats.hasShield || false,
                        healOthers: baseStats.healOthers || false,
                        lastHeal: 0
                    });
                }
                
                game.lastEnemySpawn = now;
                // 生成间隔也随时间减少
                game.enemySpawnInterval = Math.max(300, 1500 - minutes * 50);
            }
        }
        
        // Boss AI - 简化移动逻辑
        function updateBoss() {
            if (!game.boss || game.bossPhase !== 'active') return;
            
            const now = Date.now();
            const boss = game.boss;
            
            // 更新冰冻状态
            if (boss.frozen) {
                boss.freezeDuration--;
                if (boss.freezeDuration <= 0) {
                    boss.frozen = false;
                    boss.speed = boss.originalSpeed;
                }
            }
            
            // 简单的追踪移动
            const dx = game.player.x - boss.x;
            const dy = game.player.y - boss.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // 保持一定距离
            if (distance > 120) {
                boss.x += (dx / distance) * boss.speed;
                boss.y += (dy / distance) * boss.speed;
            } else if (distance < 80) {
                boss.x -= (dx / distance) * boss.speed * 0.5;
                boss.y -= (dy / distance) * boss.speed * 0.5;
            }
            
            // 限制在竞技场内
            constrainToArena(boss);
            
            // 射击
            if (now - boss.lastShot > boss.shootInterval) {
                if (boss.abilities.includes('multishot')) {
                    // 多重射击
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.atan2(dy, dx) + (i - 2) * 0.3;
                        game.enemyBullets.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            damage: boss.damage,
                            size: 5
                        });
                    }
                } else {
                    // 普通射击
                    const bulletSpeed = 4;
                    game.enemyBullets.push({
                        x: boss.x,
                        y: boss.y,
                        vx: (dx / distance) * bulletSpeed,
                        vy: (dy / distance) * bulletSpeed,
                        damage: boss.damage,
                        size: 5
                    });
                }
                boss.lastShot = now;
            }
            
            // 特殊能力
            if (now - boss.lastAbility > boss.abilityInterval) {
                const ability = boss.abilities[Math.floor(Math.random() * boss.abilities.length)];
                
                if (ability === 'summon') {
                    // 召唤小怪
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const spawnDistance = 100;
                        
                        const spawnX = boss.x + Math.cos(angle) * spawnDistance;
                        const spawnY = boss.y + Math.sin(angle) * spawnDistance;
                        
                        game.enemies.push({
                            x: spawnX,
                            y: spawnY,
                            type: 'basic',
                            size: 15,
                            speed: 2,
                            health: 20,
                            maxHealth: 20,
                            damage: 1,
                            shootInterval: 0,
                            lastShot: 0,
                            expReward: 10,
                            poisoned: false,
                            poisonDamage: 0,
                            poisonDuration: 0,
                            lastPoisonTick: 0,
                            frozen: false,
                            freezeDuration: 0,
                            originalSpeed: 2,
                            explodeOnDeath: false,
                            hasShield: false,
                            healOthers: false,
                            lastHeal: 0
                        });
                    }
                } else if (ability === 'charge') {
                    // 冲锋攻击 - 短暂提速
                    const originalSpeed = boss.speed;
                    boss.speed *= 2;
                    setTimeout(() => {
                        if (boss) boss.speed = originalSpeed;
                    }, 1500);
                } else if (ability === 'teleport') {
                    // 传送到玩家附近的安全位置
                    const teleportAngle = Math.random() * Math.PI * 2;
                    const teleportDistance = 120;
                    boss.x = game.player.x + Math.cos(teleportAngle) * teleportDistance;
                    boss.y = game.player.y + Math.sin(teleportAngle) * teleportDistance;
                    constrainToArena(boss);
                } else if (ability === 'heal') {
                    // 治疗
                    boss.health = Math.min(boss.maxHealth, boss.health + Math.floor(boss.maxHealth * 0.1));
                }
                
                boss.lastAbility = now;
            }
            
            updateBossUI();
        }
        
        // 光剑伤害检测
        function checkLightsaberDamage() {
            if (!game.player.lightsaber) return;
            
            const now = Date.now();
            const damageInterval = 200;
            
            // 对普通敌人
            game.enemies.forEach(enemy => {
                const dx = enemy.x - game.player.x;
                const dy = enemy.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 55) {
                    if (!enemy.lastLightsaberDamage || now - enemy.lastLightsaberDamage > damageInterval) {
                        enemy.health -= Math.floor(game.player.lightsaber.damage / 5);
                        enemy.lastLightsaberDamage = now;
                        
                        createParticles(enemy.x, enemy.y, '#00E5FF', 2);
                    }
                }
            });
            
            // 对Boss
            if (game.boss) {
                const dx = game.boss.x - game.player.x;
                const dy = game.boss.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 70) {
                    if (!game.boss.lastLightsaberDamage || now - game.boss.lastLightsaberDamage > damageInterval) {
                        game.boss.health -= Math.floor(game.player.lightsaber.damage / 5);
                        game.boss.lastLightsaberDamage = now;
                        
                        createParticles(game.boss.x, game.boss.y, '#00E5FF', 3);
                    }
                }
            }
        }
        
        // 移动敌人
        function moveEnemies() {
            game.enemies.forEach(enemy => {
                // 更新冰冻状态
                if (enemy.frozen) {
                    enemy.freezeDuration--;
                    if (enemy.freezeDuration <= 0) {
                        enemy.frozen = false;
                        enemy.speed = enemy.originalSpeed;
                    }
                }
                
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                // 限制在竞技场内
                if (game.bossActive) {
                    constrainToArena(enemy);
                }
                
                // 特殊敌人行为
                const now = Date.now();
                
                // 枪手和狙击手射击
                if ((enemy.type === 'gunner' || enemy.type === 'sniper') && enemy.shootInterval > 0) {
                    if (now - enemy.lastShot > enemy.shootInterval && distance < 300) {
                        const bulletSpeed = enemy.type === 'sniper' ? 6 : 5;
                        game.enemyBullets.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: (dx / distance) * bulletSpeed,
                            vy: (dy / distance) * bulletSpeed,
                            damage: enemy.damage,
                            size: enemy.type === 'sniper' ? 4 : 3
                        });
                        enemy.lastShot = now;
                    }
                }
                
                // 治疗兵治疗其他敌人
                if (enemy.healOthers && now - enemy.lastHeal > 3000) {
                    game.enemies.forEach(otherEnemy => {
                        if (otherEnemy !== enemy) {
                            const healDist = Math.sqrt(
                                Math.pow(enemy.x - otherEnemy.x, 2) + 
                                Math.pow(enemy.y - otherEnemy.y, 2)
                            );
                            if (healDist < 80 && otherEnemy.health < otherEnemy.maxHealth) {
                                otherEnemy.health = Math.min(otherEnemy.maxHealth, otherEnemy.health + 10);
                                createParticles(otherEnemy.x, otherEnemy.y, '#4CAF50', 3);
                            }
                        }
                    });
                    enemy.lastHeal = now;
                }
                
                // 处理中毒效果
                if (enemy.poisoned) {
                    if (now - enemy.lastPoisonTick > 1000) {
                        enemy.health -= enemy.poisonDamage;
                        enemy.lastPoisonTick = now;
                        enemy.poisonDuration--;
                        
                        // 中毒传染
                        if (game.player.poison && game.player.poison.contagious) {
                            game.enemies.forEach(otherEnemy => {
                                if (otherEnemy !== enemy && !otherEnemy.poisoned) {
                                    const dist = Math.sqrt(
                                        Math.pow(enemy.x - otherEnemy.x, 2) + 
                                        Math.pow(enemy.y - otherEnemy.y, 2)
                                    );
                                    if (dist < game.player.poison.range) {
                                        otherEnemy.poisoned = true;
                                        otherEnemy.poisonDamage = game.player.poison.damage;
                                        otherEnemy.poisonDuration = game.player.poison.duration;
                                        otherEnemy.lastPoisonTick = now;
                                    }
                                }
                            });
                        }
                        
                        if (enemy.poisonDuration <= 0) {
                            enemy.poisoned = false;
                        }
                    }
                }
            });
        }
        
        // 移动敌人子弹
        function moveEnemyBullets() {
            game.enemyBullets = game.enemyBullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                const dx = bullet.x - game.player.x;
                const dy = bullet.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < bullet.size + game.player.size) {
                    // 防止连续伤害
                    const now = Date.now();
                    if (!game.player.lastDamageTime || now - game.player.lastDamageTime > 500) {
                        game.player.health -= bullet.damage;
                        game.player.lastDamageTime = now;
                        updateUI();
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                    }
                    return false;
                }
                
                const playerDist = Math.sqrt(
                    Math.pow(bullet.x - game.player.x, 2) + 
                    Math.pow(bullet.y - game.player.y, 2)
                );
                return playerDist < 800;
            });
        }
        
        // 自动射击
        function autoShoot() {
            const now = Date.now();
            if (now - game.player.lastShot > game.player.shootInterval) {
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                
                // 优先攻击Boss
                if (game.boss) {
                    const dx = game.boss.x - game.player.x;
                    const dy = game.boss.y - game.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    nearestEnemy = game.boss;
                    nearestDistance = distance;
                }
                
                // 如果没有Boss或Boss距离太远，攻击普通敌人
                if (!nearestEnemy || nearestDistance > 400) {
                    game.enemies.forEach(enemy => {
                        const dx = enemy.x - game.player.x;
                        const dy = enemy.y - game.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < nearestDistance) {
                            nearestDistance = distance;
                            nearestEnemy = enemy;
                        }
                    });
                }
                
                if (nearestEnemy) {
                    const dx = nearestEnemy.x - game.player.x;
                    const dy = nearestEnemy.y - game.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const baseAngle = Math.atan2(dy, dx);
                    
                    // 平行多重射击
                    for (let i = 0; i < game.player.multishot; i++) {
                        const offset = (i - (game.player.multishot - 1) / 2) * 12;
                        const perpAngle = baseAngle + Math.PI / 2;
                        
                        const startX = game.player.x + Math.cos(perpAngle) * offset;
                        const startY = game.player.y + Math.sin(perpAngle) * offset;
                        
                        game.bullets.push({
                            x: startX,
                            y: startY,
                            vx: Math.cos(baseAngle) * 10,
                            vy: Math.sin(baseAngle) * 10,
                            size: 5,
                            damage: game.player.damage,
                            penetration: game.player.penetration,
                            hitEnemies: []
                        });
                    }
                    
                    game.player.lastShot = now;
                }
            }
        }
        
        // 移动子弹
        function moveBullets() {
            game.bullets = game.bullets.filter(bullet => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                
                const dx = bullet.x - game.player.x;
                const dy = bullet.y - game.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < 800;
            });
        }
        
        // 创建掉落物
        function createDrop(x, y, enemy) {
            const rand = Math.random();
            
            if (rand < 0.05) {
                game.expOrbs.push({
                    x: x, y: y, size: 15, exp: enemy.expReward * 3,
                    type: 'big', collected: false
                });
            } else if (rand < 0.08) {
                // 磁铁掉落物
                game.pickups.push({
                    x: x, y: y, size: 12, type: 'magnet'
                });
            } else if (rand < 0.11) {
                // 血包掉落物
                game.pickups.push({
                    x: x, y: y, size: 12, type: 'health'
                });
            } else {
                game.expOrbs.push({
                    x: x, y: y, size: 8, exp: enemy.expReward,
                    type: 'normal', collected: false
                });
            }
        }
        
        // 雷电链效果
        function createLightningEffect(x, y, damage) {
            const targets = [...game.enemies];
            if (game.boss) targets.push(game.boss);
            
            targets.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 100 && distance > 0) {
                    enemy.health -= damage;
                    
                    game.effects.push({
                        type: 'lightning',
                        x1: x, y1: y,
                        x2: enemy.x, y2: enemy.y,
                        duration: 200,
                        startTime: Date.now()
                    });
                }
            });
        }
        
        // 爆炸效果
        function createExplosion(x, y, damage) {
            const targets = [...game.enemies];
            if (game.boss) targets.push(game.boss);
            
            targets.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    enemy.health -= damage;
                }
            });
            
            game.effects.push({
                type: 'explosion',
                x: x, y: y, radius: 0, maxRadius: 80,
                duration: 300, startTime: Date.now()
            });
        }
        
        // 碰撞检测
        function checkCollisions() {
            game.bullets.forEach((bullet, bulletIndex) => {
                const targets = [...game.enemies];
                if (game.boss) targets.push(game.boss);
                
                targets.forEach((enemy, enemyIndex) => {
                    if (bullet.hitEnemies.includes(enemy)) return;
                    
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.size + enemy.size) {
                        enemy.health -= bullet.damage;
                        bullet.hitEnemies.push(enemy);
                        
                        createParticles(enemy.x, enemy.y, '#FFD700', 3);
                        
                        if (game.player.lightning > 0) {
                            createLightningEffect(enemy.x, enemy.y, game.player.lightning);
                        }
                        
                        if (game.player.poison) {
                            enemy.poisoned = true;
                            enemy.poisonDamage = game.player.poison.damage;
                            enemy.poisonDuration = game.player.poison.duration;
                            enemy.lastPoisonTick = Date.now();
                        }
                        
                        if (game.player.freeze) {
                            enemy.frozen = true;
                            enemy.freezeDuration = game.player.freeze.duration * 60; // 转换为帧数
                            enemy.speed = Math.round((enemy.originalSpeed * (1 - game.player.freeze.slowPercent / 100)) * 10) / 10;
                        }
                        
                        if (game.player.explosion > 0) {
                            createExplosion(enemy.x, enemy.y, game.player.explosion);
                        }
                        
                        if (bullet.penetration <= 0) {
                            game.bullets.splice(bulletIndex, 1);
                        } else {
                            bullet.penetration--;
                        }
                        
                        if (enemy.health <= 0) {
                            if (game.player.vampire > 0) {
                                game.player.health = Math.min(game.player.maxHealth, 
                                    game.player.health + game.player.vampire);
                            }
                            
                            // 爆破兵死亡爆炸
                            if (enemy.explodeOnDeath) {
                                createExplosion(enemy.x, enemy.y, 30);
                            }
                            
                            if (enemy === game.boss) {
                                defeatBoss();
                            } else {
                                createDrop(enemy.x, enemy.y, enemy);
                                game.enemies.splice(enemyIndex, 1);
                                game.player.kills++;
                                game.waveKills++;
                                
                                if (game.waveKills >= game.waveTarget) {
                                    game.wave++;
                                    game.waveKills = 0;
                                    game.waveTarget = Math.floor(game.waveTarget * 1.3);
                                    game.enemySpawnInterval = Math.max(400, game.enemySpawnInterval - 50);
                                }
                            }
                            
                            updateUI();
                        }
                    }
                });
            });
            
            // 玩家与敌人碰撞 - 添加伤害间隔
            const allEnemies = [...game.enemies];
            if (game.boss) allEnemies.push(game.boss);
            
            allEnemies.forEach(enemy => {
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + enemy.size) {
                    const now = Date.now();
                    if (!game.player.lastContactDamage || now - game.player.lastContactDamage > 1000) {
                        game.player.health -= enemy.damage;
                        game.player.lastContactDamage = now;
                        updateUI();
                        
                        if (game.player.health <= 0) {
                            gameOver();
                        }
                    }
                }
            });
            
            // 扩大磁铁吸附范围
            const magnetMultiplier = game.buffs.find(b => b.type === 'magnet')?.multiplier || 1;
            const pickupRange = game.player.pickupRange * magnetMultiplier * 2; // 扩大2倍
            
            // 经验球碰撞
            game.expOrbs.forEach((orb, index) => {
                const dx = game.player.x - orb.x;
                const dy = game.player.y - orb.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + orb.size + pickupRange) {
                    game.player.exp += orb.exp;
                    game.expOrbs.splice(index, 1);
                    
                    // 修复大经验球特效颜色
                    if (orb.type === 'big') {
                        createParticles(orb.x, orb.y, '#FFD700', 8);
                    } else {
                        createParticles(orb.x, orb.y, '#00BCD4', 5);
                    }
                    
                    if (game.player.exp >= game.player.maxExp) {
                        levelUp();
                    }
                    
                    updateUI();
                }
            });
            
            // 拾取物品碰撞
            game.pickups.forEach((pickup, index) => {
                const dx = game.player.x - pickup.x;
                const dy = game.player.y - pickup.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < game.player.size + pickup.size + pickupRange) {
                    if (pickup.type === 'magnet') {
                        // 磁铁效果
                        const existingMagnet = game.buffs.find(b => b.type === 'magnet');
                        if (existingMagnet) {
                            // 重置时间
                            existingMagnet.startTime = Date.now();
                        } else {
                            // 新增磁铁效果
                            game.buffs.push({
                                type: 'magnet',
                                duration: 10000,
                                startTime: Date.now(),
                                multiplier: 5 // 增加磁铁效果倍数
                            });
                        }
                        
                        createParticles(pickup.x, pickup.y, '#FFD700', 8);
                        
                    } else if (pickup.type === 'health') {
                        // 血包效果
                        const healAmount = 30;
                        game.player.health = Math.min(game.player.maxHealth, game.player.health + healAmount);
                        
                        createParticles(pickup.x, pickup.y, '#F44336', 8);
                        
                        // 显示治疗效果
                        game.effects.push({
                            type: 'heal_text',
                            x: pickup.x, y: pickup.y,
                            duration: 1000,
                            startTime: Date.now(),
                            amount: healAmount
                        });
                    }
                    
                    game.pickups.splice(index, 1);
                    updateBuffsDisplay();
                    updateUI();
                }
            });
        }
        
        // 更新增益效果
        function updateBuffs() {
            const now = Date.now();
            game.buffs = game.buffs.filter(buff => {
                return (now - buff.startTime) < buff.duration;
            });
        }
        
        // 更新粒子效果
        function updateParticles() {
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                return particle.life > 0;
            });
        }
        
        // 升级
        function levelUp() {
            game.player.level++;
            game.player.exp -= game.player.maxExp;
            game.player.maxExp = Math.floor(100 * Math.pow(1.4, game.player.level - 1));
            
            game.paused = true;
            showSkillModal();
        }
        
        // 显示技能选择界面
        function showSkillModal() {
            const modal = document.getElementById('skillModal');
            const grid = document.getElementById('skillGrid');
            
            grid.innerHTML = '';
            
            // 获取可升级的技能
            const availableSkills = Object.keys(skillDefinitions).filter(skill => {
                const currentLevel = game.player.skills[skill] || 0;
                return currentLevel < skillDefinitions[skill].maxLevel;
            });
            
            // 如果所有技能都满级，触发完美结局
            if (availableSkills.length === 0) {
                modal.style.display = 'none';
                game.paused = false;
                checkPerfectEnding();
                return;
            }
            
            const selectedSkills = [];
            const maxOptions = Math.min(3, availableSkills.length);
            
            while (selectedSkills.length < maxOptions && availableSkills.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableSkills.length);
                const skill = availableSkills[randomIndex];
                selectedSkills.push(skill);
                availableSkills.splice(randomIndex, 1);
            }
            
            selectedSkills.forEach(skillKey => {
                const skill = skillDefinitions[skillKey];
                const currentLevel = game.player.skills[skillKey] || 0;
                const nextLevel = currentLevel + 1;
                
                const option = document.createElement('div');
                option.className = `skill-option ${nextLevel === 5 ? 'max-level' : ''}`;
                option.onclick = () => selectSkill(skillKey);
                
                option.innerHTML = `
                    <div class="skill-icon" style="background: ${skill.color}">
                        ${nextLevel === 5 ? '👑' : skill.icon}
                    </div>
                    <div class="skill-info">
                        <strong>${skill.name}</strong><br>
                        ${skill.description(nextLevel)}
                        ${nextLevel === 5 ? '<br><span style="color: gold;">★ 满级强化 ★</span>' : ''}
                    </div>
                    <div class="skill-level">Lv.${nextLevel}</div>
                `;
                
                grid.appendChild(option);
            });
            
            modal.style.display = 'block';
        }
        
        // 选择技能
        function selectSkill(skillKey) {
            const skill = skillDefinitions[skillKey];
            const currentLevel = game.player.skills[skillKey] || 0;
            const newLevel = currentLevel + 1;
            
            game.player.skills[skillKey] = newLevel;
            
            const effect = skill.effect(newLevel);
            
            Object.keys(effect).forEach(key => {
                if (key === 'healFull') {
                    game.player.health = game.player.maxHealth;
                } else if (key === 'shootInterval') {
                    game.player.shootInterval = Math.max(100, game.player.shootInterval + effect[key]);
                } else if (key === 'poison') {
                    game.player.poison = effect[key];
                } else if (key === 'lightsaber') {
                    game.player.lightsaber = effect[key];
                } else if (key === 'freeze') {
                    game.player.freeze = effect[key];
                } else if (key === 'multishot') {
                    game.player.multishot = effect[key];
                } else {
                    if (typeof effect[key] === 'number') {
                        game.player[key] = Math.round(((game.player[key] || 0) + effect[key]) * 10) / 10;
                    } else {
                        game.player[key] = (game.player[key] || 0) + effect[key];
                    }
                }
            });
            
            document.getElementById('skillModal').style.display = 'none';
            game.paused = false;
            updateUI();
            updateSkillsDisplay();
        }
        
        // 更新技能显示
        function updateSkillsDisplay() {
            const list = document.getElementById('activeSkillsList');
            list.innerHTML = '';
            
            Object.keys(game.player.skills).forEach(skillKey => {
                const skill = skillDefinitions[skillKey];
                const level = game.player.skills[skillKey];
                
                const div = document.createElement('div');
                div.className = 'active-skill';
                div.innerHTML = `
                    <div class="skill-icon" style="background: ${skill.color}">
                        ${level === 5 ? '👑' : skill.icon}
                    </div>
                    ${skill.name} Lv.${level}
                `;
                list.appendChild(div);
            });
        }
        
        // 更新增益显示
        function updateBuffsDisplay() {
            const list = document.getElementById('buffsList');
            list.innerHTML = '';
            
            game.buffs.forEach(buff => {
                const remaining = Math.ceil((buff.duration - (Date.now() - buff.startTime)) / 1000);
                
                const div = document.createElement('div');
                div.className = 'buff-item';
                
                if (buff.type === 'magnet') {
                    div.innerHTML = `🧲 磁铁效果 ${remaining}s`;
                }
                
                list.appendChild(div);
            });
        }
        
        // 更新UI
        function updateUI() {
            if (!game.gameOver) {
                game.survivalTime = Math.floor((Date.now() - game.startTime) / 1000);
            }
            
            document.getElementById('level').textContent = game.player.level;
            document.getElementById('health').textContent = Math.max(0, Math.floor(game.player.health));
            document.getElementById('kills').textContent = game.player.kills;
            document.getElementById('wave').textContent = game.wave;
            document.getElementById('survivalTime').textContent = formatTime(game.survivalTime);
            document.getElementById('exp').textContent = game.player.exp;
            document.getElementById('maxExp').textContent = game.player.maxExp;
            
            // 下个Boss倒计时
            const timeSinceLastBoss = game.survivalTime - game.lastBossTime;
            const timeToNextBoss = Math.max(0, 180 - timeSinceLastBoss);
            document.getElementById('nextBoss').textContent = formatTime(timeToNextBoss);
            
            const expPercent = (game.player.exp / game.player.maxExp) * 100;
            document.getElementById('expFill').style.width = expPercent + '%';
        }
        
        // 绘制特效
        function drawEffects() {
            const now = Date.now();
            
            game.effects = game.effects.filter(effect => {
                const elapsed = now - effect.startTime;
                const progress = elapsed / effect.duration;
                
                if (progress >= 1) return false;
                
                if (effect.type === 'lightning') {
                    const screenX1 = effect.x1 - world.x;
                    const screenY1 = effect.y1 - world.y;
                    const screenX2 = effect.x2 - world.x;
                    const screenY2 = effect.y2 - world.y;
                    
                    ctx.strokeStyle = `rgba(255, 255, 0, ${1 - progress})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(screenX1, screenY1);
                    ctx.lineTo(screenX2, screenY2);
                    ctx.stroke();
                } else if (effect.type === 'explosion') {
                    const screenX = effect.x - world.x;
                    const screenY = effect.y - world.y;
                    
                    effect.radius = effect.maxRadius * progress;
                    
                    ctx.strokeStyle = `rgba(255, 100, 0, ${1 - progress})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, effect.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (effect.type === 'heal_text') {
                    const screenX = effect.x - world.x;
                    const screenY = effect.y - world.y;
                    
                    ctx.fillStyle = `rgba(76, 175, 80, ${1 - progress})`;
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`+${effect.amount}`, screenX, screenY - progress * 40);
                }
                
                return true;
            });
        }
        
        // 绘制粒子
        function drawParticles() {
            game.particles.forEach(particle => {
                const r = parseInt(particle.color.slice(1, 3), 16);
                const g = parseInt(particle.color.slice(3, 5), 16);
                const b = parseInt(particle.color.slice(5, 7), 16);
                
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.life})`;
                ctx.beginPath();
                ctx.arc(particle.x - world.x, particle.y - world.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // 绘制函数 - 调整绘制顺序
        function draw() {
            animationTime += 16;
            
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制网格背景
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = (-world.x % gridSize);
            const startY = (-world.y % gridSize);
            
            for (let x = startX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = startY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // 绘制竞技场边界
            drawArenaBorder();
            
            // 先绘制经验球（在敌人下方）
            game.expOrbs.forEach(orb => {
                const screenX = orb.x - world.x;
                const screenY = orb.y - world.y;
                
                if (screenX > -30 && screenX < canvas.width + 30 && 
                    screenY > -30 && screenY < canvas.height + 30) {
                    drawExpOrb(orb, screenX, screenY);
                }
            });
            
            // 绘制拾取物品（在敌人下方）
            game.pickups.forEach(pickup => {
                const screenX = pickup.x - world.x;
                const screenY = pickup.y - world.y;
                
                if (screenX > -30 && screenX < canvas.width + 30 && 
                    screenY > -30 && screenY < canvas.height + 30) {
                    drawPickup(pickup, screenX, screenY);
                }
            });
            
            // 绘制敌人
            game.enemies.forEach(enemy => {
                const screenX = enemy.x - world.x;
                const screenY = enemy.y - world.y;
                
                if (screenX > -60 && screenX < canvas.width + 60 && 
                    screenY > -60 && screenY < canvas.height + 60) {
                    
                    drawEnemy(enemy, screenX, screenY);
                    
                    // 敌人生命值条 - 固定长度
                    const enemyHealthPercent = Math.max(0, enemy.health / enemy.maxHealth);
                    const enemyBarWidth = 50; // 固定宽度
                    ctx.fillStyle = '#333';
                    ctx.fillRect(screenX - enemyBarWidth/2, screenY - enemy.size - 30, enemyBarWidth, 5);
                    ctx.fillStyle = enemy.poisoned ? '#4CAF50' : (enemy.frozen ? '#00BFFF' : enemyTypes[enemy.type].color);
                    ctx.fillRect(screenX - enemyBarWidth/2, screenY - enemy.size - 30, enemyBarWidth * enemyHealthPercent, 5);
                }
            });
            
            // 绘制Boss
            if (game.boss) {
                const bossScreenX = game.boss.x - world.x;
                const bossScreenY = game.boss.y - world.y;
                
                if (bossScreenX > -100 && bossScreenX < canvas.width + 100 && 
                    bossScreenY > -100 && bossScreenY < canvas.height + 100) {
                    
                    drawBoss(game.boss, bossScreenX, bossScreenY);
                    
                    // Boss生命值条 - 固定长度
                    const bossHealthPercent = Math.max(0, game.boss.health / game.boss.maxHealth);
                    const bossBarWidth = 80; // 固定宽度
                    ctx.fillStyle = '#333';
                    ctx.fillRect(bossScreenX - bossBarWidth/2, bossScreenY - game.boss.size - 40, bossBarWidth, 8);
                    ctx.fillStyle = game.boss.frozen ? '#00BFFF' : '#F44336';
                    ctx.fillRect(bossScreenX - bossBarWidth/2, bossScreenY - game.boss.size - 40, bossBarWidth * bossHealthPercent, 8);
                }
            }
            
            // 绘制玩家
            const playerScreenX = game.player.x - world.x;
            const playerScreenY = game.player.y - world.y;
            
            drawPlayer(playerScreenX, playerScreenY);
            
            // 绘制玩家生命值条
            const barWidth = 60;
            const barHeight = 8;
            const healthPercent = Math.max(0, game.player.health / game.player.maxHealth);
            
            ctx.fillStyle = '#333';
            ctx.fillRect(playerScreenX - barWidth/2, playerScreenY - game.player.size - 30, barWidth, barHeight);
            ctx.fillStyle = healthPercent > 0.5 ? '#4CAF50' : healthPercent > 0.25 ? '#FFC107' : '#F44336';
            ctx.fillRect(playerScreenX - barWidth/2, playerScreenY - game.player.size - 30, barWidth * healthPercent, barHeight);
            
            // 绘制子弹
            game.bullets.forEach(bullet => {
                const screenX = bullet.x - world.x;
                const screenY = bullet.y - world.y;
                
                if (screenX > -20 && screenX < canvas.width + 20 && 
                    screenY > -20 && screenY < canvas.height + 20) {
                    drawBullet(bullet, screenX, screenY);
                }
            });
            
            // 绘制敌人子弹
            game.enemyBullets.forEach(bullet => {
                const screenX = bullet.x - world.x;
                const screenY = bullet.y - world.y;
                
                if (screenX > -10 && screenX < canvas.width + 10 && 
                    screenY > -10 && screenY < canvas.height + 10) {
                    ctx.fillStyle = '#FF4444';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, bullet.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // 绘制特效和粒子
            drawEffects();
            drawParticles();
        }
        
        // 游戏主循环
        function gameLoop() {
            if (!game.paused && !game.gameOver && gameStarted) {
                movePlayer();
                checkBossSpawn();
                if (game.bossActive) {
                    updateBoss();
                } else {
                    spawnEnemy();
                }
                moveEnemies();
                moveEnemyBullets();
                autoShoot();
                moveBullets();
                checkCollisions();
                checkLightsaberDamage();
                updateBuffs();
                updateParticles();
                updateBuffsDisplay();
                updateUI();
            }
            
            if (gameStarted) {
                draw();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // 窗口大小改变时调整画布
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (joystick.el) {
                joystick.rect = joystick.el.getBoundingClientRect();
            }
        });
        
        // 初始化
        gameLoop();
    </script>
</body>
</html>
